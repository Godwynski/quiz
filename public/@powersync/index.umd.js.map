{"version":3,"file":"index.umd.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACVA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACt/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChCA;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9eA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sdk_web/webpack/universalModuleDefinition","webpack://sdk_web/../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.5.0/node_modules/@journeyapps/wa-sqlite/dist/mc-wa-sqlite-async.mjs","webpack://sdk_web/../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.5.0/node_modules/@journeyapps/wa-sqlite/dist/mc-wa-sqlite.mjs","webpack://sdk_web/../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.5.0/node_modules/@journeyapps/wa-sqlite/dist/wa-sqlite-async.mjs","webpack://sdk_web/../../node_modules/.pnpm/@journeyapps+wa-sqlite@1.5.0/node_modules/@journeyapps/wa-sqlite/dist/wa-sqlite.mjs","webpack://sdk_web/../../node_modules/.pnpm/bson@6.10.4/node_modules/bson/lib/bson.mjs","webpack://sdk_web/./lib/src/attachments/IndexDBFileSystemAdapter.js","webpack://sdk_web/./lib/src/db/NavigatorTriggerClaimManager.js","webpack://sdk_web/./lib/src/db/PowerSyncDatabase.js","webpack://sdk_web/./lib/src/db/adapters/AbstractWebPowerSyncDatabaseOpenFactory.js","webpack://sdk_web/./lib/src/db/adapters/AbstractWebSQLOpenFactory.js","webpack://sdk_web/./lib/src/db/adapters/AsyncDatabaseConnection.js","webpack://sdk_web/./lib/src/db/adapters/LockedAsyncDatabaseAdapter.js","webpack://sdk_web/./lib/src/db/adapters/SSRDBAdapter.js","webpack://sdk_web/./lib/src/db/adapters/WorkerWrappedAsyncDatabaseConnection.js","webpack://sdk_web/./lib/src/db/adapters/wa-sqlite/InternalWASQLiteDBAdapter.js","webpack://sdk_web/./lib/src/db/adapters/wa-sqlite/WASQLiteConnection.js","webpack://sdk_web/./lib/src/db/adapters/wa-sqlite/WASQLiteDBAdapter.js","webpack://sdk_web/./lib/src/db/adapters/wa-sqlite/WASQLiteOpenFactory.js","webpack://sdk_web/./lib/src/db/adapters/wa-sqlite/WASQLitePowerSyncDatabaseOpenFactory.js","webpack://sdk_web/./lib/src/db/adapters/web-sql-flags.js","webpack://sdk_web/./lib/src/db/sync/SSRWebStreamingSyncImplementation.js","webpack://sdk_web/./lib/src/db/sync/SharedWebStreamingSyncImplementation.js","webpack://sdk_web/./lib/src/db/sync/WebRemote.js","webpack://sdk_web/./lib/src/db/sync/WebStreamingSyncImplementation.js","webpack://sdk_web/./lib/src/db/sync/userAgent.js","webpack://sdk_web/./lib/src/shared/navigator.js","webpack://sdk_web/./lib/src/worker/db/open-worker-database.js","webpack://sdk_web/./lib/src/worker/sync/AbstractSharedSyncClientProvider.js","webpack://sdk_web/./lib/src/worker/sync/BroadcastLogger.js","webpack://sdk_web/./lib/src/worker/sync/SharedSyncImplementation.js","webpack://sdk_web/external umd \"@journeyapps/wa-sqlite\"","webpack://sdk_web/external umd \"@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js\"","webpack://sdk_web/external umd \"@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js\"","webpack://sdk_web/external umd \"@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js\"","webpack://sdk_web/external umd \"@powersync/common\"","webpack://sdk_web/external umd \"async-mutex\"","webpack://sdk_web/external umd \"comlink\"","webpack://sdk_web/webpack/bootstrap","webpack://sdk_web/webpack/runtime/create fake namespace object","webpack://sdk_web/webpack/runtime/define property getters","webpack://sdk_web/webpack/runtime/get javascript chunk filename","webpack://sdk_web/webpack/runtime/global","webpack://sdk_web/webpack/runtime/hasOwnProperty shorthand","webpack://sdk_web/webpack/runtime/make namespace object","webpack://sdk_web/webpack/runtime/publicPath","webpack://sdk_web/webpack/runtime/jsonp chunk loading","webpack://sdk_web/./lib/src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@powersync/common\"), require(\"async-mutex\"), require(\"comlink\"), require(\"@journeyapps/wa-sqlite\"), require(\"@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js\"), require(\"@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js\"), require(\"@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@powersync/common\", \"async-mutex\", \"comlink\", \"@journeyapps/wa-sqlite\", \"@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js\", \"@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js\", \"@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sdk_web\"] = factory(require(\"@powersync/common\"), require(\"async-mutex\"), require(\"comlink\"), require(\"@journeyapps/wa-sqlite\"), require(\"@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js\"), require(\"@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js\"), require(\"@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js\"));\n\telse\n\t\troot[\"sdk_web\"] = factory(root[\"@powersync/common\"], root[\"async-mutex\"], root[\"comlink\"], root[\"@journeyapps/wa-sqlite\"], root[\"@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js\"], root[\"@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js\"], root[\"@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__powersync_common__, __WEBPACK_EXTERNAL_MODULE_async_mutex__, __WEBPACK_EXTERNAL_MODULE_comlink__, __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite__, __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite_src_examples_OPFSCoopSyncVFS_js__, __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite_src_examples_AccessHandlePoolVFS_js__, __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite_src_examples_IDBBatchAtomicVFS_js__) => {\nreturn ","async function Module(moduleArg={}){var moduleRtn;var Module=moduleArg;var ENVIRONMENT_IS_WEB=!!globalThis.window;var ENVIRONMENT_IS_WORKER=!!globalThis.WorkerGlobalScope;var ENVIRONMENT_IS_NODE=globalThis.process?.versions?.node&&globalThis.process?.type!=\"renderer\";var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var _scriptName=import.meta.url;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){try{scriptDirectory=new URL(\".\",_scriptName).href}catch{}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=async url=>{var response=await fetch(url,{credentials:\"same-origin\"});if(response.ok){return response.arrayBuffer()}throw new Error(response.status+\" : \"+response.url)}}}else{}var out=console.log.bind(console);var err=console.error.bind(console);var wasmBinary;var ABORT=false;var EXITSTATUS;var readyPromiseResolve,readyPromiseReject;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var runtimeInitialized=false;function updateMemoryViews(){var b=wasmMemory.buffer;HEAP8=new Int8Array(b);HEAP16=new Int16Array(b);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(b);HEAPU16=new Uint16Array(b);Module[\"HEAP32\"]=HEAP32=new Int32Array(b);HEAPU32=new Uint32Array(b);HEAPF32=new Float32Array(b);HEAPF64=new Float64Array(b)}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(onPreRuns)}function initRuntime(){runtimeInitialized=true;if(!Module[\"noFSInit\"]&&!FS.initialized)FS.init();TTY.init();wasmExports[\"ra\"]();FS.ignorePermissions=false}function preMain(){}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(onPostRuns)}function abort(what){Module[\"onAbort\"]?.(what);what=\"Aborted(\"+what+\")\";err(what);ABORT=true;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject?.(e);throw e}var wasmBinaryFile;function findWasmBinary(){if(Module[\"locateFile\"]){return locateFile(\"mc-wa-sqlite-async.wasm\")}return new URL(\"mc-wa-sqlite-async.wasm\",import.meta.url).href}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}async function getWasmBinary(binaryFile){if(!wasmBinary){try{var response=await readAsync(binaryFile);return new Uint8Array(response)}catch{}}return getBinarySync(binaryFile)}async function instantiateArrayBuffer(binaryFile,imports){try{var binary=await getWasmBinary(binaryFile);var instance=await WebAssembly.instantiate(binary,imports);return instance}catch(reason){err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)}}async function instantiateAsync(binary,binaryFile,imports){if(!binary){try{var response=fetch(binaryFile,{credentials:\"same-origin\"});var instantiationResult=await WebAssembly.instantiateStreaming(response,imports);return instantiationResult}catch(reason){err(`wasm streaming compile failed: ${reason}`);err(\"falling back to ArrayBuffer instantiation\")}}return instantiateArrayBuffer(binaryFile,imports)}function getWasmImports(){var imports={a:wasmImports};return imports}async function createWasm(){function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=Asyncify.instrumentWasmExports(wasmExports);assignWasmExports(wasmExports);updateMemoryViews();return wasmExports}function receiveInstantiationResult(result){return receiveInstance(result[\"instance\"])}var info=getWasmImports();if(Module[\"instantiateWasm\"]){return new Promise((resolve,reject)=>{Module[\"instantiateWasm\"](info,(inst,mod)=>{resolve(receiveInstance(inst,mod))})})}wasmBinaryFile??=findWasmBinary();var result=await instantiateAsync(wasmBinary,wasmBinaryFile,info);var exports=receiveInstantiationResult(result);return exports}var tempDouble;var tempI64;class ExitStatus{name=\"ExitStatus\";constructor(status){this.message=`Program terminated with exit(${status})`;this.status=status}}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};var onPostRuns=[];var addOnPostRun=cb=>onPostRuns.push(cb);var onPreRuns=[];var addOnPreRun=cb=>onPreRuns.push(cb);var dynCalls={};function getValue(ptr,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":return HEAP8[ptr];case\"i8\":return HEAP8[ptr];case\"i16\":return HEAP16[ptr>>1];case\"i32\":return HEAP32[ptr>>2];case\"i64\":abort(\"to do getValue(i64) use WASM_BIGINT\");case\"float\":return HEAPF32[ptr>>2];case\"double\":return HEAPF64[ptr>>3];case\"*\":return HEAPU32[ptr>>2];default:abort(`invalid type for getValue: ${type}`)}}var noExitRuntime=true;function setValue(ptr,value,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":HEAP8[ptr]=value;break;case\"i8\":HEAP8[ptr]=value;break;case\"i16\":HEAP16[ptr>>1]=value;break;case\"i32\":HEAP32[ptr>>2]=value;break;case\"i64\":abort(\"to do setValue(i64) use WASM_BIGINT\");case\"float\":HEAPF32[ptr>>2]=value;break;case\"double\":HEAPF64[ptr>>3]=value;break;case\"*\":HEAPU32[ptr>>2]=value;break;default:abort(`invalid type for setValue: ${type}`)}}var stackRestore=val=>__emscripten_stack_restore(val);var stackSave=()=>_emscripten_stack_get_current();var UTF8Decoder=new TextDecoder;var findStringEnd=(heapOrArray,idx,maxBytesToRead,ignoreNul)=>{var maxIdx=idx+maxBytesToRead;if(ignoreNul)return maxIdx;while(heapOrArray[idx]&&!(idx>=maxIdx))++idx;return idx};var UTF8ToString=(ptr,maxBytesToRead,ignoreNul)=>{if(!ptr)return\"\";var end=findStringEnd(HEAPU8,ptr,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(HEAPU8.subarray(ptr,end))};var ___assert_fail=(condition,filename,line,func)=>abort(`Assertion failed: ${UTF8ToString(condition)}, at: `+[filename?UTF8ToString(filename):\"unknown filename\",line,func?UTF8ToString(func):\"unknown function\"]);var PATH={isAbs:path=>path.charAt(0)===\"/\",splitPath:filename=>{var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.slice(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(p=>!!p),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.slice(0,-1)}return root+dir},basename:path=>path&&path.match(/([^\\/]+|\\/)\\/*$/)[1],join:(...paths)=>PATH.normalize(paths.join(\"/\")),join2:(l,r)=>PATH.normalize(l+\"/\"+r)};var initRandomFill=()=>view=>crypto.getRandomValues(view);var randomFill=view=>{(randomFill=initRandomFill())(view)};var PATH_FS={resolve:(...args)=>{var resolvedPath=\"\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\"string\"){throw new TypeError(\"Arguments to path.resolve must be strings\")}else if(!path){return\"\"}resolvedPath=path+\"/\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\"/\").filter(p=>!!p),!resolvedAbsolute).join(\"/\");return(resolvedAbsolute?\"/\":\"\")+resolvedPath||\".\"},relative:(from,to)=>{from=PATH_FS.resolve(from).slice(1);to=PATH_FS.resolve(to).slice(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\"\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\"\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\"/\"));var toParts=trim(to.split(\"/\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\"..\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\"/\")}};var UTF8ArrayToString=(heapOrArray,idx=0,maxBytesToRead,ignoreNul)=>{var endPtr=findStringEnd(heapOrArray,idx,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(heapOrArray.buffer?heapOrArray.subarray(idx,endPtr):new Uint8Array(heapOrArray.slice(idx,endPtr)))};var FS_stdin_getChar_buffer=[];var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.codePointAt(i);if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;i++}}heap[outIdx]=0;return outIdx-startIdx};var intArrayFromString=(stringy,dontAddNull,length)=>{var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array};var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(globalThis.window?.prompt){result=window.prompt(\"Input: \");if(result!==null){result+=\"\\n\"}}else{}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){out(UTF8ArrayToString(tty.output));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){err(UTF8ArrayToString(tty.output));tty.output=[]}}}};var zeroMemory=(ptr,size)=>HEAPU8.fill(0,ptr,ptr+size);var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(ptr)zeroMemory(ptr,size);return ptr};var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\"/\",16895,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.atime=node.mtime=node.ctime=Date.now();if(parent){parent.contents[name]=node;parent.atime=parent.mtime=parent.ctime=node.atime}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.atime);attr.mtime=new Date(node.mtime);attr.ctime=new Date(node.ctime);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){for(const key of[\"mode\",\"atime\",\"mtime\",\"ctime\"]){if(attr[key]!=null){node[key]=attr[key]}}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){if(!MEMFS.doesNotExistError){MEMFS.doesNotExistError=new FS.ErrnoError(44);MEMFS.doesNotExistError.stack=\"<generic error, no stack>\"}throw MEMFS.doesNotExistError},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){if(FS.isDir(old_node.mode)){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}FS.hashRemoveNode(new_node)}delete old_node.parent.contents[old_node.name];new_dir.contents[new_name]=old_node;old_node.name=new_name;new_dir.ctime=new_dir.mtime=old_node.parent.ctime=old_node.parent.mtime=Date.now()},unlink(parent,name){delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},readdir(node){return[\".\",\"..\",...Object.keys(node.contents)]},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.mtime=node.ctime=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents&&contents.buffer===HEAP8.buffer){allocated=false;ptr=contents.byteOffset}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}if(contents){if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}HEAP8.set(contents,ptr)}}return{ptr,allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var FS_modeStringToFlags=str=>{var flagModes={r:0,\"r+\":2,w:512|64|1,\"w+\":512|64|2,a:1024|64|1,\"a+\":1024|64|2};var flags=flagModes[str];if(typeof flags==\"undefined\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};var asyncLoad=async url=>{var arrayBuffer=await readAsync(url);return new Uint8Array(arrayBuffer)};var FS_createDataFile=(...args)=>FS.createDataFile(...args);var getUniqueRunDependency=id=>id;var runDependencies=0;var dependenciesFulfilled=null;var removeRunDependency=id=>{runDependencies--;Module[\"monitorRunDependencies\"]?.(runDependencies);if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}};var addRunDependency=id=>{runDependencies++;Module[\"monitorRunDependencies\"]?.(runDependencies)};var preloadPlugins=[];var FS_handledByPreloadPlugin=async(byteArray,fullname)=>{if(typeof Browser!=\"undefined\")Browser.init();for(var plugin of preloadPlugins){if(plugin[\"canHandle\"](fullname)){return plugin[\"handle\"](byteArray,fullname)}}return byteArray};var FS_preloadFile=async(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);addRunDependency(dep);try{var byteArray=url;if(typeof url==\"string\"){byteArray=await asyncLoad(url)}byteArray=await FS_handledByPreloadPlugin(byteArray,fullname);preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}}finally{removeRunDependency(dep)}};var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{FS_preloadFile(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish).then(onload).catch(onerror)};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,filesystems:null,syncFSRequests:0,ErrnoError:class{name=\"ErrnoError\";constructor(errno){this.errno=errno}},FSStream:class{shared={};get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{node_ops={};stream_ops={};readMode=292|73;writeMode=146;mounted=null;constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.rdev=rdev;this.atime=this.mtime=this.ctime=Date.now()}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){if(!path){throw new FS.ErrnoError(44)}opts.follow_mount??=true;if(!PATH.isAbs(path)){path=FS.cwd()+\"/\"+path}linkloop:for(var nlinks=0;nlinks<40;nlinks++){var parts=path.split(\"/\").filter(p=>!!p);var current=FS.root;var current_path=\"/\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}if(parts[i]===\".\"){continue}if(parts[i]===\"..\"){current_path=PATH.dirname(current_path);if(FS.isRoot(current)){path=current_path+\"/\"+parts.slice(i+1).join(\"/\");nlinks--;continue linkloop}else{current=current.parent}continue}current_path=PATH.join2(current_path,parts[i]);try{current=FS.lookupNode(current,parts[i])}catch(e){if(e?.errno===44&&islast&&opts.noent_okay){return{path:current_path}}throw e}if(FS.isMountpoint(current)&&(!islast||opts.follow_mount)){current=current.mounted.root}if(FS.isLink(current.mode)&&(!islast||opts.follow)){if(!current.node_ops.readlink){throw new FS.ErrnoError(52)}var link=current.node_ops.readlink(current);if(!PATH.isAbs(link)){link=PATH.dirname(current_path)+\"/\"+link}path=link+\"/\"+parts.slice(i+1).join(\"/\");continue linkloop}}return{path:current_path,node:current}}throw new FS.ErrnoError(32)},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\"/\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\"r\",\"w\",\"rw\"][flag&3];if(flag&512){perms+=\"w\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\"r\")&&!(node.mode&292)){return 2}if(perms.includes(\"w\")&&!(node.mode&146)){return 2}if(perms.includes(\"x\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\"x\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){if(!FS.isDir(dir.mode)){return 54}try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\"wx\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\"wx\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else if(FS.isDir(node.mode)){return 31}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}var mode=FS.flagsToPermissionString(flags);if(FS.isDir(node.mode)){if(mode!==\"r\"||flags&(512|64)){return 31}}return FS.nodePermissions(node,mode)},checkOpExists(op,err){if(!op){throw new FS.ErrnoError(err)}return op},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},doSetAttr(stream,node,attr){var setattr=stream?.stream_ops.setattr;var arg=setattr?stream:node;setattr??=node.node_ops.setattr;FS.checkOpExists(setattr,63);setattr(arg,attr)},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\"function\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}for(var mount of mounts){if(mount.type.syncfs){mount.type.syncfs(mount,populate,done)}else{done(null)}}},mount(type,opts,mountpoint){var root=mountpoint===\"/\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type,opts,mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);for(var[hash,current]of Object.entries(FS.nameTable)){while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}}node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name){throw new FS.ErrnoError(28)}if(name===\".\"||name===\"..\"){throw new FS.ErrnoError(20)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},statfs(path){return FS.statfsNode(FS.lookupPath(path,{follow:true}).node)},statfsStream(stream){return FS.statfsNode(stream.node)},statfsNode(node){var rtn={bsize:4096,frsize:4096,blocks:1e6,bfree:5e5,bavail:5e5,files:FS.nextInode,ffree:FS.nextInode-1,fsid:42,flags:2,namelen:255};if(node.node_ops.statfs){Object.assign(rtn,node.node_ops.statfs(node.mount.opts.root))}return rtn},create(path,mode=438){mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode=511){mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\"/\");var d=\"\";for(var dir of dirs){if(!dir)continue;if(d||PATH.isAbs(path))d+=\"/\";d+=dir;try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\"undefined\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);old_node.parent=new_dir}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var readdir=FS.checkOpExists(node.node_ops.readdir,54);return readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return link.node_ops.readlink(link)},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;var getattr=FS.checkOpExists(node.node_ops.getattr,63);return getattr(node)},fstat(fd){var stream=FS.getStreamChecked(fd);var node=stream.node;var getattr=stream.stream_ops.getattr;var arg=getattr?stream:node;getattr??=node.node_ops.getattr;FS.checkOpExists(getattr,63);return getattr(arg)},lstat(path){return FS.stat(path,true)},doChmod(stream,node,mode,dontFollow){FS.doSetAttr(stream,node,{mode:mode&4095|node.mode&~4095,ctime:Date.now(),dontFollow})},chmod(path,mode,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChmod(null,node,mode,dontFollow)},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.doChmod(stream,stream.node,mode,false)},doChown(stream,node,dontFollow){FS.doSetAttr(stream,node,{timestamp:Date.now(),dontFollow})},chown(path,uid,gid,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChown(null,node,dontFollow)},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.doChown(stream,stream.node,false)},doTruncate(stream,node,len){if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}FS.doSetAttr(stream,node,{size:len,timestamp:Date.now()})},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}FS.doTruncate(null,node,len)},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if(len<0||(stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.doTruncate(stream,stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var setattr=FS.checkOpExists(node.node_ops.setattr,63);setattr(node,{atime,mtime})},open(path,flags,mode=438){if(path===\"\"){throw new FS.ErrnoError(44)}flags=typeof flags==\"string\"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;var isDirPath;if(typeof path==\"object\"){node=path}else{isDirPath=path.endsWith(\"/\");var lookup=FS.lookupPath(path,{follow:!(flags&131072),noent_okay:true});node=lookup.node;path=lookup.path}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else if(isDirPath){throw new FS.ErrnoError(31)}else{node=FS.mknod(path,mode|511,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node,path:FS.getPath(node),flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(created){FS.chmod(node,mode&511)}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}if(!length){throw new FS.ErrnoError(28)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\"binary\";if(opts.encoding!==\"utf8\"&&opts.encoding!==\"binary\"){abort(`Invalid encoding type \"${opts.encoding}\"`)}var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\"utf8\"){buf=UTF8ArrayToString(buf)}FS.close(stream);return buf},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\"string\"){data=new Uint8Array(intArrayFromString(data,true))}if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{abort(\"Unsupported data type\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\"x\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\"/tmp\");FS.mkdir(\"/home\");FS.mkdir(\"/home/web_user\")},createDefaultDevices(){FS.mkdir(\"/dev\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length,llseek:()=>0});FS.mkdev(\"/dev/null\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\"/dev/tty\",FS.makedev(5,0));FS.mkdev(\"/dev/tty1\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomFill(randomBuffer);randomLeft=randomBuffer.byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\"/dev\",\"random\",randomByte);FS.createDevice(\"/dev\",\"urandom\",randomByte);FS.mkdir(\"/dev/shm\");FS.mkdir(\"/dev/shm/tmp\")},createSpecialDirectories(){FS.mkdir(\"/proc\");var proc_self=FS.mkdir(\"/proc/self\");FS.mkdir(\"/proc/self/fd\");FS.mount({mount(){var node=FS.createNode(proc_self,\"fd\",16895,73);node.stream_ops={llseek:MEMFS.stream_ops.llseek};node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\"fake\"},node_ops:{readlink:()=>stream.path},id:fd+1};ret.parent=ret;return ret},readdir(){return Array.from(FS.streams.entries()).filter(([k,v])=>v).map(([k,v])=>k.toString())}};return node}},{},\"/proc/self/fd\")},createStandardStreams(input,output,error){if(input){FS.createDevice(\"/dev\",\"stdin\",input)}else{FS.symlink(\"/dev/tty\",\"/dev/stdin\")}if(output){FS.createDevice(\"/dev\",\"stdout\",null,output)}else{FS.symlink(\"/dev/tty\",\"/dev/stdout\")}if(error){FS.createDevice(\"/dev\",\"stderr\",null,error)}else{FS.symlink(\"/dev/tty1\",\"/dev/stderr\")}var stdin=FS.open(\"/dev/stdin\",0);var stdout=FS.open(\"/dev/stdout\",1);var stderr=FS.open(\"/dev/stderr\",1)},staticInit(){FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\"/\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={MEMFS}},init(input,output,error){FS.initialized=true;input??=Module[\"stdin\"];output??=Module[\"stdout\"];error??=Module[\"stderr\"];FS.createStandardStreams(input,output,error)},quit(){FS.initialized=false;for(var stream of FS.streams){if(stream){FS.close(stream)}}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\"/\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\"string\"?parent:FS.getPath(parent);var parts=path.split(\"/\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){if(e.errno!=20)throw e}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\"string\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\"string\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(globalThis.XMLHttpRequest){abort(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\")}else{try{obj.contents=readBinary(obj.url)}catch(e){throw new FS.ErrnoError(29)}}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{lengthKnown=false;chunks=[];get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\"HEAD\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);var datalength=Number(xhr.getResponseHeader(\"Content-length\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\"Accept-Ranges\"))&&header===\"bytes\";var usesGzip=(header=xhr.getResponseHeader(\"Content-Encoding\"))&&header===\"gzip\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)abort(\"invalid range (\"+from+\", \"+to+\") or no bytes requested!\");if(to>datalength-1)abort(\"only \"+datalength+\" bytes available! programmer error!\");var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\"Range\",\"bytes=\"+from+\"-\"+to);xhr.responseType=\"arraybuffer\";if(xhr.overrideMimeType){xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\"\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\"undefined\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\"undefined\")abort(\"doXHR failed!\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\"LazyFiles on gzip forces download of the whole file when length is accessed\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(globalThis.XMLHttpRequest){if(!ENVIRONMENT_IS_WORKER)abort(\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\");var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};for(const[key,fn]of Object.entries(node.stream_ops)){stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}}function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr,allocated:true}};node.stream_ops=stream_ops;return node}};var SYSCALLS={calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return dir+\"/\"+path},writeStat(buf,stat){HEAPU32[buf>>2]=stat.dev;HEAPU32[buf+4>>2]=stat.mode;HEAPU32[buf+8>>2]=stat.nlink;HEAPU32[buf+12>>2]=stat.uid;HEAPU32[buf+16>>2]=stat.gid;HEAPU32[buf+20>>2]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];HEAP32[buf+32>>2]=4096;HEAP32[buf+36>>2]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=atime%1e3*1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+56>>2]=tempI64[0],HEAP32[buf+60>>2]=tempI64[1];HEAPU32[buf+64>>2]=mtime%1e3*1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+72>>2]=tempI64[0],HEAP32[buf+76>>2]=tempI64[1];HEAPU32[buf+80>>2]=ctime%1e3*1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+88>>2]=tempI64[0],HEAP32[buf+92>>2]=tempI64[1];return 0},writeStatFs(buf,stats){HEAPU32[buf+4>>2]=stats.bsize;HEAPU32[buf+60>>2]=stats.bsize;tempI64=[stats.blocks>>>0,(tempDouble=stats.blocks,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+8>>2]=tempI64[0],HEAP32[buf+12>>2]=tempI64[1];tempI64=[stats.bfree>>>0,(tempDouble=stats.bfree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+16>>2]=tempI64[0],HEAP32[buf+20>>2]=tempI64[1];tempI64=[stats.bavail>>>0,(tempDouble=stats.bavail,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];tempI64=[stats.files>>>0,(tempDouble=stats.files,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+32>>2]=tempI64[0],HEAP32[buf+36>>2]=tempI64[1];tempI64=[stats.ffree>>>0,(tempDouble=stats.ffree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=stats.fsid;HEAPU32[buf+64>>2]=stats.flags;HEAPU32[buf+56>>2]=stats.namelen},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_chmod(path,mode){try{path=SYSCALLS.getStr(path);FS.chmod(path,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_faccessat(dirfd,path,amode,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(amode&~7){return-28}var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node){return-44}var perms=\"\";if(amode&4)perms+=\"r\";if(amode&2)perms+=\"w\";if(amode&1)perms+=\"x\";if(perms&&FS.nodePermissions(node,perms)){return-2}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchmod(fd,mode){try{FS.fchmod(fd,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchown32(fd,owner,group){try{FS.fchown(fd,owner,group);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var syscallGetVarargI=()=>{var ret=HEAP32[+SYSCALLS.varargs>>2];SYSCALLS.varargs+=4;return ret};var syscallGetVarargP=syscallGetVarargI;function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0}case 12:{var arg=syscallGetVarargP();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fstat64(fd,buf){try{return SYSCALLS.writeStat(buf,FS.fstat(fd))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;function ___syscall_ftruncate64(fd,length_low,length_high){var length=convertI32PairToI53Checked(length_low,length_high);try{if(isNaN(length))return-61;FS.ftruncate(fd,length);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);function ___syscall_getcwd(buf,size){try{if(size===0)return-28;var cwd=FS.cwd();var cwdLengthInBytes=lengthBytesUTF8(cwd)+1;if(size<cwdLengthInBytes)return-68;stringToUTF8(cwd,buf,size);return cwdLengthInBytes}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_lstat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.lstat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_mkdirat(dirfd,path,mode){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);FS.mkdir(path,mode,0);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_newfstatat(dirfd,path,buf,flags){try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~6400;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.writeStat(buf,nofollow?FS.lstat(path):FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_readlinkat(dirfd,path,buf,bufsize){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(bufsize<=0)return-28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_rmdir(path){try{path=SYSCALLS.getStr(path);FS.rmdir(path);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_unlinkat(dirfd,path,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(!flags){FS.unlink(path)}else if(flags===512){FS.rmdir(path)}else{return-28}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var readI53FromI64=ptr=>HEAPU32[ptr>>2]+HEAP32[ptr+4>>2]*4294967296;function ___syscall_utimensat(dirfd,path,times,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path,true);var now=Date.now(),atime,mtime;if(!times){atime=now;mtime=now}else{var seconds=readI53FromI64(times);var nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){atime=now}else if(nanoseconds==1073741822){atime=null}else{atime=seconds*1e3+nanoseconds/(1e3*1e3)}times+=16;seconds=readI53FromI64(times);nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){mtime=now}else if(nanoseconds==1073741822){mtime=null}else{mtime=seconds*1e3+nanoseconds/(1e3*1e3)}}if((mtime??atime)!==null){FS.utime(path,atime,mtime)}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var __abort_js=()=>abort(\"\");var runtimeKeepaliveCounter=0;var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);var MONTH_DAYS_LEAP_CUMULATIVE=[0,31,60,91,121,152,182,213,244,274,305,335];var MONTH_DAYS_REGULAR_CUMULATIVE=[0,31,59,90,120,151,181,212,243,273,304,334];var ydayFromDate=date=>{var leap=isLeapYear(date.getFullYear());var monthDaysCumulative=leap?MONTH_DAYS_LEAP_CUMULATIVE:MONTH_DAYS_REGULAR_CUMULATIVE;var yday=monthDaysCumulative[date.getMonth()]+date.getDate()-1;return yday};function __localtime_js(time_low,time_high,tmPtr){var time=convertI32PairToI53Checked(time_low,time_high);var date=new Date(time*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var yday=ydayFromDate(date)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst}function __mmap_js(len,prot,flags,fd,offset_low,offset_high,allocated,addr){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;HEAP32[allocated>>2]=res.allocated;HEAPU32[addr>>2]=ptr;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function __munmap_js(addr,len,prot,flags,fd,offset_low,offset_high){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var timers={};var handleException=e=>{if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)};var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module[\"onExit\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var _exit=exitJS;var maybeExit=()=>{if(!keepRuntimeAlive()){try{_exit(EXITSTATUS)}catch(e){handleException(e)}}};var callUserCallback=func=>{if(ABORT){return}try{return func()}catch(e){handleException(e)}finally{maybeExit()}};var _emscripten_get_now=()=>performance.now();var __setitimer_js=(which,timeout_ms)=>{if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0};var __tzset_js=(timezone,daylight,std_name,dst_name)=>{var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAPU32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{var sign=timezoneOffset>=0?\"-\":\"+\";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,\"0\");var minutes=String(absOffset%60).padStart(2,\"0\");return`UTC${sign}${hours}${minutes}`};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17)}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17)}};var _emscripten_date_now=()=>Date.now();var getHeapMax=()=>2147483648;var growMemory=size=>{var oldHeapSize=wasmMemory.buffer.byteLength;var pages=(size-oldHeapSize+65535)/65536|0;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var ENV={};var getExecutableName=()=>thisProgram||\"./this.program\";var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(globalThis.navigator?.language??\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:lang,_:getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};var _environ_get=(__environ,environ_buf)=>{var bufSize=0;var envp=0;for(var string of getEnvStrings()){var ptr=environ_buf+bufSize;HEAPU32[__environ+envp>>2]=ptr;bufSize+=stringToUTF8(string,ptr,Infinity)+1;envp+=4}return 0};var _environ_sizes_get=(penviron_count,penviron_buf_size)=>{var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;for(var string of strings){bufSize+=lengthBytesUTF8(string)+1}HEAPU32[penviron_buf_size>>2]=bufSize;return 0};function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_fdstat_get(fd,pbuf){try{var rightsBase=0;var rightsInheriting=0;var flags=0;{var stream=SYSCALLS.getStreamFromFD(fd);var type=stream.tty?2:FS.isDir(stream.mode)?3:FS.isLink(stream.mode)?7:4}HEAP8[pbuf]=type;HEAP16[pbuf+2>>1]=flags;tempI64=[rightsBase>>>0,(tempDouble=rightsBase,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+8>>2]=tempI64[0],HEAP32[pbuf+12>>2]=tempI64[1];tempI64=[rightsInheriting>>>0,(tempDouble=rightsInheriting,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+16>>2]=tempI64[0],HEAP32[pbuf+20>>2]=tempI64[1];return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var _fd_sync=function(fd){let innerFunc=()=>{try{var stream=SYSCALLS.getStreamFromFD(fd);var rtn=stream.stream_ops?.fsync?.(stream);return new Promise(resolve=>{var mount=stream.node.mount;if(mount?.type.syncfs){mount.type.syncfs(mount,false,err=>resolve(err?29:0))}else{resolve(rtn)}})}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}};return Asyncify.handleAsync(innerFunc)};_fd_sync.isAsync=true;var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){break}if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var adapters_support=function(){const handleAsync=typeof Asyncify===\"object\"?Asyncify.handleAsync.bind(Asyncify):null;Module[\"handleAsync\"]=handleAsync;const targets=new Map;Module[\"setCallback\"]=(key,target)=>targets.set(key,target);Module[\"getCallback\"]=key=>targets.get(key);Module[\"deleteCallback\"]=key=>targets.delete(key);adapters_support=function(isAsync,key,...args){const receiver=targets.get(key);let methodName=null;const f=typeof receiver===\"function\"?receiver:receiver[methodName=UTF8ToString(args.shift())];if(isAsync){if(handleAsync){return handleAsync(()=>f.apply(receiver,args))}throw new Error(\"Synchronous WebAssembly cannot call async function\")}const result=f.apply(receiver,args);if(typeof result?.then==\"function\"){console.error(\"unexpected Promise\",f);throw new Error(`${methodName} unexpectedly returned a Promise`)}return result}};function _ipp(...args){return adapters_support(false,...args)}function _ipp_async(...args){return adapters_support(true,...args)}_ipp_async.isAsync=true;function _ippipppp(...args){return adapters_support(false,...args)}function _ippipppp_async(...args){return adapters_support(true,...args)}_ippipppp_async.isAsync=true;function _ippp(...args){return adapters_support(false,...args)}function _ippp_async(...args){return adapters_support(true,...args)}_ippp_async.isAsync=true;function _ipppi(...args){return adapters_support(false,...args)}function _ipppi_async(...args){return adapters_support(true,...args)}_ipppi_async.isAsync=true;function _ipppiii(...args){return adapters_support(false,...args)}function _ipppiii_async(...args){return adapters_support(true,...args)}_ipppiii_async.isAsync=true;function _ipppiiip(...args){return adapters_support(false,...args)}function _ipppiiip_async(...args){return adapters_support(true,...args)}_ipppiiip_async.isAsync=true;function _ipppip(...args){return adapters_support(false,...args)}function _ipppip_async(...args){return adapters_support(true,...args)}_ipppip_async.isAsync=true;function _ipppj(...args){return adapters_support(false,...args)}function _ipppj_async(...args){return adapters_support(true,...args)}_ipppj_async.isAsync=true;function _ipppp(...args){return adapters_support(false,...args)}function _ipppp_async(...args){return adapters_support(true,...args)}_ipppp_async.isAsync=true;function _ippppi(...args){return adapters_support(false,...args)}function _ippppi_async(...args){return adapters_support(true,...args)}_ippppi_async.isAsync=true;function _ippppij(...args){return adapters_support(false,...args)}function _ippppij_async(...args){return adapters_support(true,...args)}_ippppij_async.isAsync=true;function _ippppip(...args){return adapters_support(false,...args)}function _ippppip_async(...args){return adapters_support(true,...args)}_ippppip_async.isAsync=true;function _ipppppip(...args){return adapters_support(false,...args)}function _ipppppip_async(...args){return adapters_support(true,...args)}_ipppppip_async.isAsync=true;function _random_get(buffer,size){try{randomFill(HEAPU8.subarray(buffer,buffer+size));return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _vppippii(...args){return adapters_support(false,...args)}function _vppippii_async(...args){return adapters_support(true,...args)}_vppippii_async.isAsync=true;function _vppp(...args){return adapters_support(false,...args)}function _vppp_async(...args){return adapters_support(true,...args)}_vppp_async.isAsync=true;function _vpppip(...args){return adapters_support(false,...args)}function _vpppip_async(...args){return adapters_support(true,...args)}_vpppip_async.isAsync=true;var runAndAbortIfError=func=>{try{return func()}catch(e){abort(e)}};var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1};var runtimeKeepalivePop=()=>{runtimeKeepaliveCounter-=1};var Asyncify={instrumentWasmImports(imports){var importPattern=/^(ipp|ipp_async|ippp|ippp_async|vppp|vppp_async|ipppj|ipppj_async|ipppi|ipppi_async|ipppp|ipppp_async|ipppip|ipppip_async|vpppip|vpppip_async|ippppi|ippppi_async|ippppij|ippppij_async|ipppiii|ipppiii_async|ippppip|ippppip_async|ippipppp|ippipppp_async|ipppppip|ipppppip_async|ipppiiip|ipppiiip_async|vppippii|vppippii_async|invoke_.*|__asyncjs__.*)$/;for(let[x,original]of Object.entries(imports)){if(typeof original==\"function\"){let isAsyncifyImport=original.isAsync||importPattern.test(x)}}},instrumentFunction(original){var wrapper=(...args)=>{Asyncify.exportCallStack.push(original);try{return original(...args)}finally{if(!ABORT){var top=Asyncify.exportCallStack.pop();Asyncify.maybeStopUnwind()}}};Asyncify.funcWrappers.set(original,wrapper);return wrapper},instrumentWasmExports(exports){var ret={};for(let[x,original]of Object.entries(exports)){if(typeof original==\"function\"){var wrapper=Asyncify.instrumentFunction(original);ret[x]=wrapper}else{ret[x]=original}}return ret},State:{Normal:0,Unwinding:1,Rewinding:2,Disabled:3},state:0,StackSize:16384,currData:null,handleSleepReturnValue:0,exportCallStack:[],callstackFuncToId:new Map,callStackIdToFunc:new Map,funcWrappers:new Map,callStackId:0,asyncPromiseHandlers:null,sleepCallbacks:[],getCallStackId(func){if(!Asyncify.callstackFuncToId.has(func)){var id=Asyncify.callStackId++;Asyncify.callstackFuncToId.set(func,id);Asyncify.callStackIdToFunc.set(id,func)}return Asyncify.callstackFuncToId.get(func)},maybeStopUnwind(){if(Asyncify.currData&&Asyncify.state===Asyncify.State.Unwinding&&Asyncify.exportCallStack.length===0){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_unwind);if(typeof Fibers!=\"undefined\"){Fibers.trampoline()}}},whenDone(){return new Promise((resolve,reject)=>{Asyncify.asyncPromiseHandlers={resolve,reject}})},allocateData(){var ptr=_malloc(12+Asyncify.StackSize);Asyncify.setDataHeader(ptr,ptr+12,Asyncify.StackSize);Asyncify.setDataRewindFunc(ptr);return ptr},setDataHeader(ptr,stack,stackSize){HEAPU32[ptr>>2]=stack;HEAPU32[ptr+4>>2]=stack+stackSize},setDataRewindFunc(ptr){var bottomOfCallStack=Asyncify.exportCallStack[0];var rewindId=Asyncify.getCallStackId(bottomOfCallStack);HEAP32[ptr+8>>2]=rewindId},getDataRewindFunc(ptr){var id=HEAP32[ptr+8>>2];var func=Asyncify.callStackIdToFunc.get(id);return func},doRewind(ptr){var original=Asyncify.getDataRewindFunc(ptr);var func=Asyncify.funcWrappers.get(original);return callUserCallback(func)},handleSleep(startAsync){if(ABORT)return;if(Asyncify.state===Asyncify.State.Normal){var reachedCallback=false;var reachedAfterCallback=false;startAsync((handleSleepReturnValue=0)=>{if(ABORT)return;Asyncify.handleSleepReturnValue=handleSleepReturnValue;reachedCallback=true;if(!reachedAfterCallback){return}Asyncify.state=Asyncify.State.Rewinding;runAndAbortIfError(()=>_asyncify_start_rewind(Asyncify.currData));if(typeof MainLoop!=\"undefined\"&&MainLoop.func){MainLoop.resume()}var asyncWasmReturnValue,isError=false;try{asyncWasmReturnValue=Asyncify.doRewind(Asyncify.currData)}catch(err){asyncWasmReturnValue=err;isError=true}var handled=false;if(!Asyncify.currData){var asyncPromiseHandlers=Asyncify.asyncPromiseHandlers;if(asyncPromiseHandlers){Asyncify.asyncPromiseHandlers=null;(isError?asyncPromiseHandlers.reject:asyncPromiseHandlers.resolve)(asyncWasmReturnValue);handled=true}}if(isError&&!handled){throw asyncWasmReturnValue}});reachedAfterCallback=true;if(!reachedCallback){Asyncify.state=Asyncify.State.Unwinding;Asyncify.currData=Asyncify.allocateData();if(typeof MainLoop!=\"undefined\"&&MainLoop.func){MainLoop.pause()}runAndAbortIfError(()=>_asyncify_start_unwind(Asyncify.currData))}}else if(Asyncify.state===Asyncify.State.Rewinding){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_rewind);_free(Asyncify.currData);Asyncify.currData=null;Asyncify.sleepCallbacks.forEach(callUserCallback)}else{abort(`invalid state: ${Asyncify.state}`)}return Asyncify.handleSleepReturnValue},handleAsync:startAsync=>Asyncify.handleSleep(async wakeUp=>{wakeUp(await startAsync())})};var getWasmTableEntry=funcPtr=>wasmTable.get(funcPtr);var updateTableMap=(offset,count)=>{if(functionsInTableMap){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i)}}}};var functionsInTableMap;var getFunctionAddress=func=>{if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length)}return functionsInTableMap.get(func)||0};var freeTableIndexes=[];var getEmptyTableSlot=()=>{if(freeTableIndexes.length){return freeTableIndexes.pop()}return wasmTable[\"grow\"](1)};var setWasmTableEntry=(idx,func)=>wasmTable.set(idx,func);var uleb128EncodeWithLen=arr=>{const n=arr.length;return[n%128|128,n>>7,...arr]};var wasmTypeCodes={i:127,p:127,j:126,f:125,d:124,e:111};var generateTypePack=types=>uleb128EncodeWithLen(Array.from(types,type=>{var code=wasmTypeCodes[type];return code}));var convertJsFunctionToWasm=(func,sig)=>{var bytes=Uint8Array.of(0,97,115,109,1,0,0,0,1,...uleb128EncodeWithLen([1,96,...generateTypePack(sig.slice(1)),...generateTypePack(sig[0]===\"v\"?\"\":sig[0])]),2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{e:{f:func}});var wrappedFunc=instance.exports[\"f\"];return wrappedFunc};var addFunction=(func,sig)=>{var rtn=getFunctionAddress(func);if(rtn){return rtn}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func)}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped)}functionsInTableMap.set(func,ret);return ret};var getCFunc=ident=>{var func=Module[\"_\"+ident];return func};var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer)};var stackAlloc=sz=>__emscripten_stack_alloc(sz);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={string:str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},array:arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\"string\"){return UTF8ToString(ret)}if(returnType===\"boolean\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var previousAsync=Asyncify.currData;var ret=func(...cArgs);function onDone(ret){runtimeKeepalivePop();if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}var asyncMode=opts?.async;runtimeKeepalivePush();if(Asyncify.currData!=previousAsync){return Asyncify.whenDone().then(onDone)}ret=onDone(ret);if(asyncMode)return Promise.resolve(ret);return ret};var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\"number\"||type===\"boolean\");var numericRet=returnType!==\"string\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};var getTempRet0=val=>__emscripten_tempret_get();var stringToUTF16=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr};var stringToUTF32=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codePoint=str.codePointAt(i);if(codePoint>65535){i++}HEAP32[outPtr>>2]=codePoint;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr};var AsciiToString=ptr=>{var str=\"\";while(1){var ch=HEAPU8[ptr++];if(!ch)return str;str+=String.fromCharCode(ch)}};var UTF16Decoder=new TextDecoder(\"utf-16le\");var UTF16ToString=(ptr,maxBytesToRead,ignoreNul)=>{var idx=ptr>>1;var endIdx=findStringEnd(HEAPU16,idx,maxBytesToRead/2,ignoreNul);return UTF16Decoder.decode(HEAPU16.subarray(idx,endIdx))};var UTF32ToString=(ptr,maxBytesToRead,ignoreNul)=>{var str=\"\";var startIdx=ptr>>2;for(var i=0;!(i>=maxBytesToRead/4);i++){var utf32=HEAPU32[startIdx+i];if(!utf32&&!ignoreNul)break;str+=String.fromCodePoint(utf32)}return str};var intArrayToString=array=>{var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join(\"\")};var _getTempRet0=getTempRet0;FS.createPreloadedFile=FS_createPreloadedFile;FS.preloadFile=FS_preloadFile;FS.staticInit();adapters_support();{if(Module[\"noExitRuntime\"])noExitRuntime=Module[\"noExitRuntime\"];if(Module[\"preloadPlugins\"])preloadPlugins=Module[\"preloadPlugins\"];if(Module[\"print\"])out=Module[\"print\"];if(Module[\"printErr\"])err=Module[\"printErr\"];if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].shift()()}}}Module[\"getTempRet0\"]=getTempRet0;Module[\"ccall\"]=ccall;Module[\"cwrap\"]=cwrap;Module[\"addFunction\"]=addFunction;Module[\"setValue\"]=setValue;Module[\"getValue\"]=getValue;Module[\"UTF8ToString\"]=UTF8ToString;Module[\"stringToUTF8\"]=stringToUTF8;Module[\"lengthBytesUTF8\"]=lengthBytesUTF8;Module[\"intArrayFromString\"]=intArrayFromString;Module[\"intArrayToString\"]=intArrayToString;Module[\"AsciiToString\"]=AsciiToString;Module[\"UTF16ToString\"]=UTF16ToString;Module[\"stringToUTF16\"]=stringToUTF16;Module[\"UTF32ToString\"]=UTF32ToString;Module[\"stringToUTF32\"]=stringToUTF32;Module[\"writeArrayToMemory\"]=writeArrayToMemory;Module[\"_getTempRet0\"]=_getTempRet0;var _powersync_init_static,_sqlite3_status64,_sqlite3_status,_sqlite3_msize,_sqlite3_db_status,_sqlite3_vfs_find,_sqlite3_vfs_register,_sqlite3_vfs_unregister,_sqlite3_release_memory,_sqlite3_soft_heap_limit64,_sqlite3_memory_used,_sqlite3_hard_heap_limit64,_sqlite3_memory_highwater,_sqlite3_malloc,_sqlite3_malloc64,_sqlite3_free,_sqlite3_realloc,_sqlite3_realloc64,_sqlite3_str_vappendf,_sqlite3_str_append,_sqlite3_str_appendchar,_sqlite3_str_appendall,_sqlite3_str_appendf,_sqlite3_str_finish,_sqlite3_str_errcode,_sqlite3_str_length,_sqlite3_str_value,_sqlite3_str_reset,_sqlite3_str_new,_sqlite3_vmprintf,_sqlite3_mprintf,_sqlite3_vsnprintf,_sqlite3_snprintf,_sqlite3_log,_sqlite3_randomness,_sqlite3_stricmp,_sqlite3_strnicmp,_sqlite3_os_init,_sqlite3_os_end,_sqlite3_serialize,_sqlite3_prepare_v2,_sqlite3_step,_sqlite3_column_int64,_sqlite3_reset,_sqlite3_exec,_sqlite3_column_int,_sqlite3_finalize,_sqlite3_deserialize,_sqlite3_database_file_object,_sqlite3_backup_init,_sqlite3_backup_step,_sqlite3_backup_finish,_sqlite3_backup_remaining,_sqlite3_backup_pagecount,_sqlite3_clear_bindings,_sqlite3_value_blob,_sqlite3_value_text,_sqlite3_value_bytes,_sqlite3_value_bytes16,_sqlite3_value_double,_sqlite3_value_int,_sqlite3_value_int64,_sqlite3_value_subtype,_sqlite3_value_pointer,_sqlite3_value_text16,_sqlite3_value_text16be,_sqlite3_value_text16le,_sqlite3_value_type,_sqlite3_value_encoding,_sqlite3_value_nochange,_sqlite3_value_frombind,_sqlite3_value_dup,_sqlite3_value_free,_sqlite3_result_blob,_sqlite3_result_blob64,_sqlite3_result_double,_sqlite3_result_error,_sqlite3_result_error16,_sqlite3_result_int,_sqlite3_result_int64,_sqlite3_result_null,_sqlite3_result_pointer,_sqlite3_result_subtype,_sqlite3_result_text,_sqlite3_result_text64,_sqlite3_result_text16,_sqlite3_result_text16be,_sqlite3_result_text16le,_sqlite3_result_value,_sqlite3_result_error_toobig,_sqlite3_result_zeroblob,_sqlite3_result_zeroblob64,_sqlite3_result_error_code,_sqlite3_result_error_nomem,_sqlite3_user_data,_sqlite3_context_db_handle,_sqlite3_vtab_nochange,_sqlite3_vtab_in_first,_sqlite3_vtab_in_next,_sqlite3_aggregate_context,_sqlite3_get_auxdata,_sqlite3_set_auxdata,_sqlite3_column_count,_sqlite3_data_count,_sqlite3_column_blob,_sqlite3_column_bytes,_sqlite3_column_bytes16,_sqlite3_column_double,_sqlite3_column_text,_sqlite3_column_value,_sqlite3_column_text16,_sqlite3_column_type,_sqlite3_column_name,_sqlite3_column_name16,_sqlite3_bind_blob,_sqlite3_bind_blob64,_sqlite3_bind_double,_sqlite3_bind_int,_sqlite3_bind_int64,_sqlite3_bind_null,_sqlite3_bind_pointer,_sqlite3_bind_text,_sqlite3_bind_text64,_sqlite3_bind_text16,_sqlite3_bind_value,_sqlite3_bind_zeroblob,_sqlite3_bind_zeroblob64,_sqlite3_bind_parameter_count,_sqlite3_bind_parameter_name,_sqlite3_bind_parameter_index,_sqlite3_db_handle,_sqlite3_stmt_readonly,_sqlite3_stmt_isexplain,_sqlite3_stmt_explain,_sqlite3_stmt_busy,_sqlite3_next_stmt,_sqlite3_stmt_status,_sqlite3_sql,_sqlite3_expanded_sql,_sqlite3_value_numeric_type,_sqlite3_blob_open,_sqlite3_blob_close,_sqlite3_blob_read,_sqlite3_blob_write,_sqlite3_blob_bytes,_sqlite3_blob_reopen,_sqlite3_set_authorizer,_sqlite3_strglob,_sqlite3_strlike,_sqlite3_errmsg,_sqlite3_load_extension,_sqlite3_enable_load_extension,_sqlite3_auto_extension,_sqlite3_cancel_auto_extension,_sqlite3_reset_auto_extension,_sqlite3_prepare,_sqlite3_prepare_v3,_sqlite3_prepare16,_sqlite3_prepare16_v2,_sqlite3_prepare16_v3,_sqlite3_get_table,_sqlite3_free_table,_sqlite3_create_module,_sqlite3_create_module_v2,_sqlite3_drop_modules,_sqlite3_declare_vtab,_sqlite3_vtab_on_conflict,_sqlite3_vtab_config,_sqlite3_vtab_collation,_sqlite3_vtab_in,_sqlite3_vtab_rhs_value,_sqlite3_vtab_distinct,_sqlite3_keyword_name,_sqlite3_keyword_count,_sqlite3_keyword_check,_sqlite3_complete,_sqlite3_complete16,_sqlite3_libversion,_sqlite3_libversion_number,_sqlite3_threadsafe,_sqlite3_initialize,_sqlite3_shutdown,_sqlite3_config,_sqlite3_db_mutex,_sqlite3_db_release_memory,_sqlite3_db_cacheflush,_sqlite3_db_config,_sqlite3_last_insert_rowid,_sqlite3_set_last_insert_rowid,_sqlite3_changes64,_sqlite3_changes,_sqlite3_total_changes64,_sqlite3_total_changes,_sqlite3_txn_state,_sqlite3_close,_sqlite3_close_v2,_sqlite3_busy_handler,_sqlite3_progress_handler,_sqlite3_busy_timeout,_sqlite3_interrupt,_sqlite3_is_interrupted,_sqlite3_create_function,_sqlite3_create_function_v2,_sqlite3_create_window_function,_sqlite3_create_function16,_sqlite3_overload_function,_sqlite3_trace_v2,_sqlite3_commit_hook,_sqlite3_update_hook,_sqlite3_rollback_hook,_sqlite3_autovacuum_pages,_sqlite3_wal_autocheckpoint,_sqlite3_wal_hook,_sqlite3_wal_checkpoint_v2,_sqlite3_wal_checkpoint,_sqlite3_error_offset,_sqlite3_errmsg16,_sqlite3_errcode,_sqlite3_extended_errcode,_sqlite3_system_errno,_sqlite3_errstr,_sqlite3_limit,_sqlite3_open,_sqlite3_open_v2,_sqlite3_open16,_sqlite3_create_collation,_sqlite3_create_collation_v2,_sqlite3_create_collation16,_sqlite3_collation_needed,_sqlite3_collation_needed16,_sqlite3_get_clientdata,_sqlite3_set_clientdata,_sqlite3_get_autocommit,_sqlite3_table_column_metadata,_sqlite3_sleep,_sqlite3_extended_result_codes,_sqlite3_file_control,_sqlite3_test_control,_sqlite3_create_filename,_sqlite3_free_filename,_sqlite3_uri_parameter,_sqlite3_uri_key,_sqlite3_uri_boolean,_sqlite3_uri_int64,_sqlite3_filename_database,_sqlite3_filename_journal,_sqlite3_filename_wal,_sqlite3_db_name,_sqlite3_db_filename,_sqlite3_db_readonly,_sqlite3_compileoption_used,_sqlite3_compileoption_get,_sqlite3_sourceid,_sqlite3mc_config,_sqlite3mc_cipher_count,_sqlite3mc_cipher_index,_sqlite3mc_cipher_name,_sqlite3mc_config_cipher,_sqlite3mc_vfs_create,_memcmp,_malloc,_free,_memset,_RegisterExtensionFunctions,_getSqliteFree,_main,_libauthorizer_set_authorizer,_libfunction_create_function,_libhook_commit_hook,_libhook_update_hook,_libprogress_progress_handler,_libvfs_vfs_register,_memcpy,_emscripten_builtin_memalign,__emscripten_timeout,__emscripten_tempret_get,__emscripten_stack_restore,__emscripten_stack_alloc,_emscripten_stack_get_current,dynCall_iii,dynCall_viiiij,dynCall_ii,dynCall_vi,dynCall_iiii,dynCall_viii,dynCall_iiiiiii,dynCall_iiiiii,dynCall_iiiii,dynCall_vii,dynCall_viiii,dynCall_iiiiiiiii,dynCall_vijii,dynCall_viiiii,dynCall_iiiij,dynCall_viji,dynCall_iij,dynCall_iidiiii,dynCall_iijii,dynCall_iiji,dynCall_i,dynCall_iiiiiij,dynCall_iiid,dynCall_iiij,dynCall_dii,dynCall_jii,dynCall_ji,dynCall_vid,dynCall_vij,dynCall_iiiiiiiiii,dynCall_di,dynCall_iiiiijii,dynCall_j,dynCall_jj,dynCall_jiij,dynCall_iiiiji,dynCall_iiiijii,dynCall_ij,dynCall_v,dynCall_viiji,dynCall_viijii,dynCall_iiiiiiiiiii,dynCall_iiiijji,dynCall_iiiiiiii,_asyncify_start_unwind,_asyncify_stop_unwind,_asyncify_start_rewind,_asyncify_stop_rewind,memory,_sqlite3_version,__indirect_function_table,wasmMemory,wasmTable;function assignWasmExports(wasmExports){_powersync_init_static=Module[\"_powersync_init_static\"]=wasmExports[\"sa\"];_sqlite3_status64=Module[\"_sqlite3_status64\"]=wasmExports[\"ta\"];_sqlite3_status=Module[\"_sqlite3_status\"]=wasmExports[\"ua\"];_sqlite3_msize=Module[\"_sqlite3_msize\"]=wasmExports[\"va\"];_sqlite3_db_status=Module[\"_sqlite3_db_status\"]=wasmExports[\"wa\"];_sqlite3_vfs_find=Module[\"_sqlite3_vfs_find\"]=wasmExports[\"xa\"];_sqlite3_vfs_register=Module[\"_sqlite3_vfs_register\"]=wasmExports[\"ya\"];_sqlite3_vfs_unregister=Module[\"_sqlite3_vfs_unregister\"]=wasmExports[\"za\"];_sqlite3_release_memory=Module[\"_sqlite3_release_memory\"]=wasmExports[\"Aa\"];_sqlite3_soft_heap_limit64=Module[\"_sqlite3_soft_heap_limit64\"]=wasmExports[\"Ba\"];_sqlite3_memory_used=Module[\"_sqlite3_memory_used\"]=wasmExports[\"Ca\"];_sqlite3_hard_heap_limit64=Module[\"_sqlite3_hard_heap_limit64\"]=wasmExports[\"Da\"];_sqlite3_memory_highwater=Module[\"_sqlite3_memory_highwater\"]=wasmExports[\"Ea\"];_sqlite3_malloc=Module[\"_sqlite3_malloc\"]=wasmExports[\"Fa\"];_sqlite3_malloc64=Module[\"_sqlite3_malloc64\"]=wasmExports[\"Ga\"];_sqlite3_free=Module[\"_sqlite3_free\"]=wasmExports[\"Ha\"];_sqlite3_realloc=Module[\"_sqlite3_realloc\"]=wasmExports[\"Ia\"];_sqlite3_realloc64=Module[\"_sqlite3_realloc64\"]=wasmExports[\"Ja\"];_sqlite3_str_vappendf=Module[\"_sqlite3_str_vappendf\"]=wasmExports[\"Ka\"];_sqlite3_str_append=Module[\"_sqlite3_str_append\"]=wasmExports[\"La\"];_sqlite3_str_appendchar=Module[\"_sqlite3_str_appendchar\"]=wasmExports[\"Ma\"];_sqlite3_str_appendall=Module[\"_sqlite3_str_appendall\"]=wasmExports[\"Na\"];_sqlite3_str_appendf=Module[\"_sqlite3_str_appendf\"]=wasmExports[\"Oa\"];_sqlite3_str_finish=Module[\"_sqlite3_str_finish\"]=wasmExports[\"Pa\"];_sqlite3_str_errcode=Module[\"_sqlite3_str_errcode\"]=wasmExports[\"Qa\"];_sqlite3_str_length=Module[\"_sqlite3_str_length\"]=wasmExports[\"Ra\"];_sqlite3_str_value=Module[\"_sqlite3_str_value\"]=wasmExports[\"Sa\"];_sqlite3_str_reset=Module[\"_sqlite3_str_reset\"]=wasmExports[\"Ta\"];_sqlite3_str_new=Module[\"_sqlite3_str_new\"]=wasmExports[\"Ua\"];_sqlite3_vmprintf=Module[\"_sqlite3_vmprintf\"]=wasmExports[\"Va\"];_sqlite3_mprintf=Module[\"_sqlite3_mprintf\"]=wasmExports[\"Wa\"];_sqlite3_vsnprintf=Module[\"_sqlite3_vsnprintf\"]=wasmExports[\"Xa\"];_sqlite3_snprintf=Module[\"_sqlite3_snprintf\"]=wasmExports[\"Ya\"];_sqlite3_log=Module[\"_sqlite3_log\"]=wasmExports[\"Za\"];_sqlite3_randomness=Module[\"_sqlite3_randomness\"]=wasmExports[\"_a\"];_sqlite3_stricmp=Module[\"_sqlite3_stricmp\"]=wasmExports[\"$a\"];_sqlite3_strnicmp=Module[\"_sqlite3_strnicmp\"]=wasmExports[\"ab\"];_sqlite3_os_init=Module[\"_sqlite3_os_init\"]=wasmExports[\"bb\"];_sqlite3_os_end=Module[\"_sqlite3_os_end\"]=wasmExports[\"cb\"];_sqlite3_serialize=Module[\"_sqlite3_serialize\"]=wasmExports[\"db\"];_sqlite3_prepare_v2=Module[\"_sqlite3_prepare_v2\"]=wasmExports[\"eb\"];_sqlite3_step=Module[\"_sqlite3_step\"]=wasmExports[\"fb\"];_sqlite3_column_int64=Module[\"_sqlite3_column_int64\"]=wasmExports[\"gb\"];_sqlite3_reset=Module[\"_sqlite3_reset\"]=wasmExports[\"hb\"];_sqlite3_exec=Module[\"_sqlite3_exec\"]=wasmExports[\"ib\"];_sqlite3_column_int=Module[\"_sqlite3_column_int\"]=wasmExports[\"jb\"];_sqlite3_finalize=Module[\"_sqlite3_finalize\"]=wasmExports[\"kb\"];_sqlite3_deserialize=Module[\"_sqlite3_deserialize\"]=wasmExports[\"lb\"];_sqlite3_database_file_object=Module[\"_sqlite3_database_file_object\"]=wasmExports[\"mb\"];_sqlite3_backup_init=Module[\"_sqlite3_backup_init\"]=wasmExports[\"nb\"];_sqlite3_backup_step=Module[\"_sqlite3_backup_step\"]=wasmExports[\"ob\"];_sqlite3_backup_finish=Module[\"_sqlite3_backup_finish\"]=wasmExports[\"pb\"];_sqlite3_backup_remaining=Module[\"_sqlite3_backup_remaining\"]=wasmExports[\"qb\"];_sqlite3_backup_pagecount=Module[\"_sqlite3_backup_pagecount\"]=wasmExports[\"rb\"];_sqlite3_clear_bindings=Module[\"_sqlite3_clear_bindings\"]=wasmExports[\"sb\"];_sqlite3_value_blob=Module[\"_sqlite3_value_blob\"]=wasmExports[\"tb\"];_sqlite3_value_text=Module[\"_sqlite3_value_text\"]=wasmExports[\"ub\"];_sqlite3_value_bytes=Module[\"_sqlite3_value_bytes\"]=wasmExports[\"vb\"];_sqlite3_value_bytes16=Module[\"_sqlite3_value_bytes16\"]=wasmExports[\"wb\"];_sqlite3_value_double=Module[\"_sqlite3_value_double\"]=wasmExports[\"xb\"];_sqlite3_value_int=Module[\"_sqlite3_value_int\"]=wasmExports[\"yb\"];_sqlite3_value_int64=Module[\"_sqlite3_value_int64\"]=wasmExports[\"zb\"];_sqlite3_value_subtype=Module[\"_sqlite3_value_subtype\"]=wasmExports[\"Ab\"];_sqlite3_value_pointer=Module[\"_sqlite3_value_pointer\"]=wasmExports[\"Bb\"];_sqlite3_value_text16=Module[\"_sqlite3_value_text16\"]=wasmExports[\"Cb\"];_sqlite3_value_text16be=Module[\"_sqlite3_value_text16be\"]=wasmExports[\"Db\"];_sqlite3_value_text16le=Module[\"_sqlite3_value_text16le\"]=wasmExports[\"Eb\"];_sqlite3_value_type=Module[\"_sqlite3_value_type\"]=wasmExports[\"Fb\"];_sqlite3_value_encoding=Module[\"_sqlite3_value_encoding\"]=wasmExports[\"Gb\"];_sqlite3_value_nochange=Module[\"_sqlite3_value_nochange\"]=wasmExports[\"Hb\"];_sqlite3_value_frombind=Module[\"_sqlite3_value_frombind\"]=wasmExports[\"Ib\"];_sqlite3_value_dup=Module[\"_sqlite3_value_dup\"]=wasmExports[\"Jb\"];_sqlite3_value_free=Module[\"_sqlite3_value_free\"]=wasmExports[\"Kb\"];_sqlite3_result_blob=Module[\"_sqlite3_result_blob\"]=wasmExports[\"Lb\"];_sqlite3_result_blob64=Module[\"_sqlite3_result_blob64\"]=wasmExports[\"Mb\"];_sqlite3_result_double=Module[\"_sqlite3_result_double\"]=wasmExports[\"Nb\"];_sqlite3_result_error=Module[\"_sqlite3_result_error\"]=wasmExports[\"Ob\"];_sqlite3_result_error16=Module[\"_sqlite3_result_error16\"]=wasmExports[\"Pb\"];_sqlite3_result_int=Module[\"_sqlite3_result_int\"]=wasmExports[\"Qb\"];_sqlite3_result_int64=Module[\"_sqlite3_result_int64\"]=wasmExports[\"Rb\"];_sqlite3_result_null=Module[\"_sqlite3_result_null\"]=wasmExports[\"Sb\"];_sqlite3_result_pointer=Module[\"_sqlite3_result_pointer\"]=wasmExports[\"Tb\"];_sqlite3_result_subtype=Module[\"_sqlite3_result_subtype\"]=wasmExports[\"Ub\"];_sqlite3_result_text=Module[\"_sqlite3_result_text\"]=wasmExports[\"Vb\"];_sqlite3_result_text64=Module[\"_sqlite3_result_text64\"]=wasmExports[\"Wb\"];_sqlite3_result_text16=Module[\"_sqlite3_result_text16\"]=wasmExports[\"Xb\"];_sqlite3_result_text16be=Module[\"_sqlite3_result_text16be\"]=wasmExports[\"Yb\"];_sqlite3_result_text16le=Module[\"_sqlite3_result_text16le\"]=wasmExports[\"Zb\"];_sqlite3_result_value=Module[\"_sqlite3_result_value\"]=wasmExports[\"_b\"];_sqlite3_result_error_toobig=Module[\"_sqlite3_result_error_toobig\"]=wasmExports[\"$b\"];_sqlite3_result_zeroblob=Module[\"_sqlite3_result_zeroblob\"]=wasmExports[\"ac\"];_sqlite3_result_zeroblob64=Module[\"_sqlite3_result_zeroblob64\"]=wasmExports[\"bc\"];_sqlite3_result_error_code=Module[\"_sqlite3_result_error_code\"]=wasmExports[\"cc\"];_sqlite3_result_error_nomem=Module[\"_sqlite3_result_error_nomem\"]=wasmExports[\"dc\"];_sqlite3_user_data=Module[\"_sqlite3_user_data\"]=wasmExports[\"ec\"];_sqlite3_context_db_handle=Module[\"_sqlite3_context_db_handle\"]=wasmExports[\"fc\"];_sqlite3_vtab_nochange=Module[\"_sqlite3_vtab_nochange\"]=wasmExports[\"gc\"];_sqlite3_vtab_in_first=Module[\"_sqlite3_vtab_in_first\"]=wasmExports[\"hc\"];_sqlite3_vtab_in_next=Module[\"_sqlite3_vtab_in_next\"]=wasmExports[\"ic\"];_sqlite3_aggregate_context=Module[\"_sqlite3_aggregate_context\"]=wasmExports[\"jc\"];_sqlite3_get_auxdata=Module[\"_sqlite3_get_auxdata\"]=wasmExports[\"kc\"];_sqlite3_set_auxdata=Module[\"_sqlite3_set_auxdata\"]=wasmExports[\"lc\"];_sqlite3_column_count=Module[\"_sqlite3_column_count\"]=wasmExports[\"mc\"];_sqlite3_data_count=Module[\"_sqlite3_data_count\"]=wasmExports[\"nc\"];_sqlite3_column_blob=Module[\"_sqlite3_column_blob\"]=wasmExports[\"oc\"];_sqlite3_column_bytes=Module[\"_sqlite3_column_bytes\"]=wasmExports[\"pc\"];_sqlite3_column_bytes16=Module[\"_sqlite3_column_bytes16\"]=wasmExports[\"qc\"];_sqlite3_column_double=Module[\"_sqlite3_column_double\"]=wasmExports[\"rc\"];_sqlite3_column_text=Module[\"_sqlite3_column_text\"]=wasmExports[\"sc\"];_sqlite3_column_value=Module[\"_sqlite3_column_value\"]=wasmExports[\"tc\"];_sqlite3_column_text16=Module[\"_sqlite3_column_text16\"]=wasmExports[\"uc\"];_sqlite3_column_type=Module[\"_sqlite3_column_type\"]=wasmExports[\"vc\"];_sqlite3_column_name=Module[\"_sqlite3_column_name\"]=wasmExports[\"wc\"];_sqlite3_column_name16=Module[\"_sqlite3_column_name16\"]=wasmExports[\"xc\"];_sqlite3_bind_blob=Module[\"_sqlite3_bind_blob\"]=wasmExports[\"yc\"];_sqlite3_bind_blob64=Module[\"_sqlite3_bind_blob64\"]=wasmExports[\"zc\"];_sqlite3_bind_double=Module[\"_sqlite3_bind_double\"]=wasmExports[\"Ac\"];_sqlite3_bind_int=Module[\"_sqlite3_bind_int\"]=wasmExports[\"Bc\"];_sqlite3_bind_int64=Module[\"_sqlite3_bind_int64\"]=wasmExports[\"Cc\"];_sqlite3_bind_null=Module[\"_sqlite3_bind_null\"]=wasmExports[\"Dc\"];_sqlite3_bind_pointer=Module[\"_sqlite3_bind_pointer\"]=wasmExports[\"Ec\"];_sqlite3_bind_text=Module[\"_sqlite3_bind_text\"]=wasmExports[\"Fc\"];_sqlite3_bind_text64=Module[\"_sqlite3_bind_text64\"]=wasmExports[\"Gc\"];_sqlite3_bind_text16=Module[\"_sqlite3_bind_text16\"]=wasmExports[\"Hc\"];_sqlite3_bind_value=Module[\"_sqlite3_bind_value\"]=wasmExports[\"Ic\"];_sqlite3_bind_zeroblob=Module[\"_sqlite3_bind_zeroblob\"]=wasmExports[\"Jc\"];_sqlite3_bind_zeroblob64=Module[\"_sqlite3_bind_zeroblob64\"]=wasmExports[\"Kc\"];_sqlite3_bind_parameter_count=Module[\"_sqlite3_bind_parameter_count\"]=wasmExports[\"Lc\"];_sqlite3_bind_parameter_name=Module[\"_sqlite3_bind_parameter_name\"]=wasmExports[\"Mc\"];_sqlite3_bind_parameter_index=Module[\"_sqlite3_bind_parameter_index\"]=wasmExports[\"Nc\"];_sqlite3_db_handle=Module[\"_sqlite3_db_handle\"]=wasmExports[\"Oc\"];_sqlite3_stmt_readonly=Module[\"_sqlite3_stmt_readonly\"]=wasmExports[\"Pc\"];_sqlite3_stmt_isexplain=Module[\"_sqlite3_stmt_isexplain\"]=wasmExports[\"Qc\"];_sqlite3_stmt_explain=Module[\"_sqlite3_stmt_explain\"]=wasmExports[\"Rc\"];_sqlite3_stmt_busy=Module[\"_sqlite3_stmt_busy\"]=wasmExports[\"Sc\"];_sqlite3_next_stmt=Module[\"_sqlite3_next_stmt\"]=wasmExports[\"Tc\"];_sqlite3_stmt_status=Module[\"_sqlite3_stmt_status\"]=wasmExports[\"Uc\"];_sqlite3_sql=Module[\"_sqlite3_sql\"]=wasmExports[\"Vc\"];_sqlite3_expanded_sql=Module[\"_sqlite3_expanded_sql\"]=wasmExports[\"Wc\"];_sqlite3_value_numeric_type=Module[\"_sqlite3_value_numeric_type\"]=wasmExports[\"Xc\"];_sqlite3_blob_open=Module[\"_sqlite3_blob_open\"]=wasmExports[\"Yc\"];_sqlite3_blob_close=Module[\"_sqlite3_blob_close\"]=wasmExports[\"Zc\"];_sqlite3_blob_read=Module[\"_sqlite3_blob_read\"]=wasmExports[\"_c\"];_sqlite3_blob_write=Module[\"_sqlite3_blob_write\"]=wasmExports[\"$c\"];_sqlite3_blob_bytes=Module[\"_sqlite3_blob_bytes\"]=wasmExports[\"ad\"];_sqlite3_blob_reopen=Module[\"_sqlite3_blob_reopen\"]=wasmExports[\"bd\"];_sqlite3_set_authorizer=Module[\"_sqlite3_set_authorizer\"]=wasmExports[\"cd\"];_sqlite3_strglob=Module[\"_sqlite3_strglob\"]=wasmExports[\"dd\"];_sqlite3_strlike=Module[\"_sqlite3_strlike\"]=wasmExports[\"ed\"];_sqlite3_errmsg=Module[\"_sqlite3_errmsg\"]=wasmExports[\"fd\"];_sqlite3_load_extension=Module[\"_sqlite3_load_extension\"]=wasmExports[\"gd\"];_sqlite3_enable_load_extension=Module[\"_sqlite3_enable_load_extension\"]=wasmExports[\"hd\"];_sqlite3_auto_extension=Module[\"_sqlite3_auto_extension\"]=wasmExports[\"id\"];_sqlite3_cancel_auto_extension=Module[\"_sqlite3_cancel_auto_extension\"]=wasmExports[\"jd\"];_sqlite3_reset_auto_extension=Module[\"_sqlite3_reset_auto_extension\"]=wasmExports[\"kd\"];_sqlite3_prepare=Module[\"_sqlite3_prepare\"]=wasmExports[\"ld\"];_sqlite3_prepare_v3=Module[\"_sqlite3_prepare_v3\"]=wasmExports[\"md\"];_sqlite3_prepare16=Module[\"_sqlite3_prepare16\"]=wasmExports[\"nd\"];_sqlite3_prepare16_v2=Module[\"_sqlite3_prepare16_v2\"]=wasmExports[\"od\"];_sqlite3_prepare16_v3=Module[\"_sqlite3_prepare16_v3\"]=wasmExports[\"pd\"];_sqlite3_get_table=Module[\"_sqlite3_get_table\"]=wasmExports[\"qd\"];_sqlite3_free_table=Module[\"_sqlite3_free_table\"]=wasmExports[\"rd\"];_sqlite3_create_module=Module[\"_sqlite3_create_module\"]=wasmExports[\"sd\"];_sqlite3_create_module_v2=Module[\"_sqlite3_create_module_v2\"]=wasmExports[\"td\"];_sqlite3_drop_modules=Module[\"_sqlite3_drop_modules\"]=wasmExports[\"ud\"];_sqlite3_declare_vtab=Module[\"_sqlite3_declare_vtab\"]=wasmExports[\"vd\"];_sqlite3_vtab_on_conflict=Module[\"_sqlite3_vtab_on_conflict\"]=wasmExports[\"wd\"];_sqlite3_vtab_config=Module[\"_sqlite3_vtab_config\"]=wasmExports[\"xd\"];_sqlite3_vtab_collation=Module[\"_sqlite3_vtab_collation\"]=wasmExports[\"yd\"];_sqlite3_vtab_in=Module[\"_sqlite3_vtab_in\"]=wasmExports[\"zd\"];_sqlite3_vtab_rhs_value=Module[\"_sqlite3_vtab_rhs_value\"]=wasmExports[\"Ad\"];_sqlite3_vtab_distinct=Module[\"_sqlite3_vtab_distinct\"]=wasmExports[\"Bd\"];_sqlite3_keyword_name=Module[\"_sqlite3_keyword_name\"]=wasmExports[\"Cd\"];_sqlite3_keyword_count=Module[\"_sqlite3_keyword_count\"]=wasmExports[\"Dd\"];_sqlite3_keyword_check=Module[\"_sqlite3_keyword_check\"]=wasmExports[\"Ed\"];_sqlite3_complete=Module[\"_sqlite3_complete\"]=wasmExports[\"Fd\"];_sqlite3_complete16=Module[\"_sqlite3_complete16\"]=wasmExports[\"Gd\"];_sqlite3_libversion=Module[\"_sqlite3_libversion\"]=wasmExports[\"Hd\"];_sqlite3_libversion_number=Module[\"_sqlite3_libversion_number\"]=wasmExports[\"Id\"];_sqlite3_threadsafe=Module[\"_sqlite3_threadsafe\"]=wasmExports[\"Jd\"];_sqlite3_initialize=Module[\"_sqlite3_initialize\"]=wasmExports[\"Kd\"];_sqlite3_shutdown=Module[\"_sqlite3_shutdown\"]=wasmExports[\"Ld\"];_sqlite3_config=Module[\"_sqlite3_config\"]=wasmExports[\"Md\"];_sqlite3_db_mutex=Module[\"_sqlite3_db_mutex\"]=wasmExports[\"Nd\"];_sqlite3_db_release_memory=Module[\"_sqlite3_db_release_memory\"]=wasmExports[\"Od\"];_sqlite3_db_cacheflush=Module[\"_sqlite3_db_cacheflush\"]=wasmExports[\"Pd\"];_sqlite3_db_config=Module[\"_sqlite3_db_config\"]=wasmExports[\"Qd\"];_sqlite3_last_insert_rowid=Module[\"_sqlite3_last_insert_rowid\"]=wasmExports[\"Rd\"];_sqlite3_set_last_insert_rowid=Module[\"_sqlite3_set_last_insert_rowid\"]=wasmExports[\"Sd\"];_sqlite3_changes64=Module[\"_sqlite3_changes64\"]=wasmExports[\"Td\"];_sqlite3_changes=Module[\"_sqlite3_changes\"]=wasmExports[\"Ud\"];_sqlite3_total_changes64=Module[\"_sqlite3_total_changes64\"]=wasmExports[\"Vd\"];_sqlite3_total_changes=Module[\"_sqlite3_total_changes\"]=wasmExports[\"Wd\"];_sqlite3_txn_state=Module[\"_sqlite3_txn_state\"]=wasmExports[\"Xd\"];_sqlite3_close=Module[\"_sqlite3_close\"]=wasmExports[\"Yd\"];_sqlite3_close_v2=Module[\"_sqlite3_close_v2\"]=wasmExports[\"Zd\"];_sqlite3_busy_handler=Module[\"_sqlite3_busy_handler\"]=wasmExports[\"_d\"];_sqlite3_progress_handler=Module[\"_sqlite3_progress_handler\"]=wasmExports[\"$d\"];_sqlite3_busy_timeout=Module[\"_sqlite3_busy_timeout\"]=wasmExports[\"ae\"];_sqlite3_interrupt=Module[\"_sqlite3_interrupt\"]=wasmExports[\"be\"];_sqlite3_is_interrupted=Module[\"_sqlite3_is_interrupted\"]=wasmExports[\"ce\"];_sqlite3_create_function=Module[\"_sqlite3_create_function\"]=wasmExports[\"de\"];_sqlite3_create_function_v2=Module[\"_sqlite3_create_function_v2\"]=wasmExports[\"ee\"];_sqlite3_create_window_function=Module[\"_sqlite3_create_window_function\"]=wasmExports[\"fe\"];_sqlite3_create_function16=Module[\"_sqlite3_create_function16\"]=wasmExports[\"ge\"];_sqlite3_overload_function=Module[\"_sqlite3_overload_function\"]=wasmExports[\"he\"];_sqlite3_trace_v2=Module[\"_sqlite3_trace_v2\"]=wasmExports[\"ie\"];_sqlite3_commit_hook=Module[\"_sqlite3_commit_hook\"]=wasmExports[\"je\"];_sqlite3_update_hook=Module[\"_sqlite3_update_hook\"]=wasmExports[\"ke\"];_sqlite3_rollback_hook=Module[\"_sqlite3_rollback_hook\"]=wasmExports[\"le\"];_sqlite3_autovacuum_pages=Module[\"_sqlite3_autovacuum_pages\"]=wasmExports[\"me\"];_sqlite3_wal_autocheckpoint=Module[\"_sqlite3_wal_autocheckpoint\"]=wasmExports[\"ne\"];_sqlite3_wal_hook=Module[\"_sqlite3_wal_hook\"]=wasmExports[\"oe\"];_sqlite3_wal_checkpoint_v2=Module[\"_sqlite3_wal_checkpoint_v2\"]=wasmExports[\"pe\"];_sqlite3_wal_checkpoint=Module[\"_sqlite3_wal_checkpoint\"]=wasmExports[\"qe\"];_sqlite3_error_offset=Module[\"_sqlite3_error_offset\"]=wasmExports[\"re\"];_sqlite3_errmsg16=Module[\"_sqlite3_errmsg16\"]=wasmExports[\"se\"];_sqlite3_errcode=Module[\"_sqlite3_errcode\"]=wasmExports[\"te\"];_sqlite3_extended_errcode=Module[\"_sqlite3_extended_errcode\"]=wasmExports[\"ue\"];_sqlite3_system_errno=Module[\"_sqlite3_system_errno\"]=wasmExports[\"ve\"];_sqlite3_errstr=Module[\"_sqlite3_errstr\"]=wasmExports[\"we\"];_sqlite3_limit=Module[\"_sqlite3_limit\"]=wasmExports[\"xe\"];_sqlite3_open=Module[\"_sqlite3_open\"]=wasmExports[\"ye\"];_sqlite3_open_v2=Module[\"_sqlite3_open_v2\"]=wasmExports[\"ze\"];_sqlite3_open16=Module[\"_sqlite3_open16\"]=wasmExports[\"Ae\"];_sqlite3_create_collation=Module[\"_sqlite3_create_collation\"]=wasmExports[\"Be\"];_sqlite3_create_collation_v2=Module[\"_sqlite3_create_collation_v2\"]=wasmExports[\"Ce\"];_sqlite3_create_collation16=Module[\"_sqlite3_create_collation16\"]=wasmExports[\"De\"];_sqlite3_collation_needed=Module[\"_sqlite3_collation_needed\"]=wasmExports[\"Ee\"];_sqlite3_collation_needed16=Module[\"_sqlite3_collation_needed16\"]=wasmExports[\"Fe\"];_sqlite3_get_clientdata=Module[\"_sqlite3_get_clientdata\"]=wasmExports[\"Ge\"];_sqlite3_set_clientdata=Module[\"_sqlite3_set_clientdata\"]=wasmExports[\"He\"];_sqlite3_get_autocommit=Module[\"_sqlite3_get_autocommit\"]=wasmExports[\"Ie\"];_sqlite3_table_column_metadata=Module[\"_sqlite3_table_column_metadata\"]=wasmExports[\"Je\"];_sqlite3_sleep=Module[\"_sqlite3_sleep\"]=wasmExports[\"Ke\"];_sqlite3_extended_result_codes=Module[\"_sqlite3_extended_result_codes\"]=wasmExports[\"Le\"];_sqlite3_file_control=Module[\"_sqlite3_file_control\"]=wasmExports[\"Me\"];_sqlite3_test_control=Module[\"_sqlite3_test_control\"]=wasmExports[\"Ne\"];_sqlite3_create_filename=Module[\"_sqlite3_create_filename\"]=wasmExports[\"Oe\"];_sqlite3_free_filename=Module[\"_sqlite3_free_filename\"]=wasmExports[\"Pe\"];_sqlite3_uri_parameter=Module[\"_sqlite3_uri_parameter\"]=wasmExports[\"Qe\"];_sqlite3_uri_key=Module[\"_sqlite3_uri_key\"]=wasmExports[\"Re\"];_sqlite3_uri_boolean=Module[\"_sqlite3_uri_boolean\"]=wasmExports[\"Se\"];_sqlite3_uri_int64=Module[\"_sqlite3_uri_int64\"]=wasmExports[\"Te\"];_sqlite3_filename_database=Module[\"_sqlite3_filename_database\"]=wasmExports[\"Ue\"];_sqlite3_filename_journal=Module[\"_sqlite3_filename_journal\"]=wasmExports[\"Ve\"];_sqlite3_filename_wal=Module[\"_sqlite3_filename_wal\"]=wasmExports[\"We\"];_sqlite3_db_name=Module[\"_sqlite3_db_name\"]=wasmExports[\"Xe\"];_sqlite3_db_filename=Module[\"_sqlite3_db_filename\"]=wasmExports[\"Ye\"];_sqlite3_db_readonly=Module[\"_sqlite3_db_readonly\"]=wasmExports[\"Ze\"];_sqlite3_compileoption_used=Module[\"_sqlite3_compileoption_used\"]=wasmExports[\"_e\"];_sqlite3_compileoption_get=Module[\"_sqlite3_compileoption_get\"]=wasmExports[\"$e\"];_sqlite3_sourceid=Module[\"_sqlite3_sourceid\"]=wasmExports[\"af\"];_sqlite3mc_config=Module[\"_sqlite3mc_config\"]=wasmExports[\"bf\"];_sqlite3mc_cipher_count=Module[\"_sqlite3mc_cipher_count\"]=wasmExports[\"cf\"];_sqlite3mc_cipher_index=Module[\"_sqlite3mc_cipher_index\"]=wasmExports[\"df\"];_sqlite3mc_cipher_name=Module[\"_sqlite3mc_cipher_name\"]=wasmExports[\"ef\"];_sqlite3mc_config_cipher=Module[\"_sqlite3mc_config_cipher\"]=wasmExports[\"ff\"];_sqlite3mc_vfs_create=Module[\"_sqlite3mc_vfs_create\"]=wasmExports[\"gf\"];_memcmp=Module[\"_memcmp\"]=wasmExports[\"hf\"];_malloc=Module[\"_malloc\"]=wasmExports[\"jf\"];_free=Module[\"_free\"]=wasmExports[\"kf\"];_memset=Module[\"_memset\"]=wasmExports[\"lf\"];_RegisterExtensionFunctions=Module[\"_RegisterExtensionFunctions\"]=wasmExports[\"nf\"];_getSqliteFree=Module[\"_getSqliteFree\"]=wasmExports[\"of\"];_main=Module[\"_main\"]=wasmExports[\"pf\"];_libauthorizer_set_authorizer=Module[\"_libauthorizer_set_authorizer\"]=wasmExports[\"qf\"];_libfunction_create_function=Module[\"_libfunction_create_function\"]=wasmExports[\"rf\"];_libhook_commit_hook=Module[\"_libhook_commit_hook\"]=wasmExports[\"sf\"];_libhook_update_hook=Module[\"_libhook_update_hook\"]=wasmExports[\"tf\"];_libprogress_progress_handler=Module[\"_libprogress_progress_handler\"]=wasmExports[\"uf\"];_libvfs_vfs_register=Module[\"_libvfs_vfs_register\"]=wasmExports[\"vf\"];_memcpy=Module[\"_memcpy\"]=wasmExports[\"wf\"];_emscripten_builtin_memalign=wasmExports[\"yf\"];__emscripten_timeout=wasmExports[\"zf\"];__emscripten_tempret_get=wasmExports[\"Af\"];__emscripten_stack_restore=wasmExports[\"Bf\"];__emscripten_stack_alloc=wasmExports[\"Cf\"];_emscripten_stack_get_current=wasmExports[\"Df\"];dynCall_iii=dynCalls[\"iii\"]=wasmExports[\"Ef\"];dynCall_viiiij=dynCalls[\"viiiij\"]=wasmExports[\"Ff\"];dynCall_ii=dynCalls[\"ii\"]=wasmExports[\"Gf\"];dynCall_vi=dynCalls[\"vi\"]=wasmExports[\"Hf\"];dynCall_iiii=dynCalls[\"iiii\"]=wasmExports[\"If\"];dynCall_viii=dynCalls[\"viii\"]=wasmExports[\"Jf\"];dynCall_iiiiiii=dynCalls[\"iiiiiii\"]=wasmExports[\"Kf\"];dynCall_iiiiii=dynCalls[\"iiiiii\"]=wasmExports[\"Lf\"];dynCall_iiiii=dynCalls[\"iiiii\"]=wasmExports[\"Mf\"];dynCall_vii=dynCalls[\"vii\"]=wasmExports[\"Nf\"];dynCall_viiii=dynCalls[\"viiii\"]=wasmExports[\"Of\"];dynCall_iiiiiiiii=dynCalls[\"iiiiiiiii\"]=wasmExports[\"Pf\"];dynCall_vijii=dynCalls[\"vijii\"]=wasmExports[\"Qf\"];dynCall_viiiii=dynCalls[\"viiiii\"]=wasmExports[\"Rf\"];dynCall_iiiij=dynCalls[\"iiiij\"]=wasmExports[\"Sf\"];dynCall_viji=dynCalls[\"viji\"]=wasmExports[\"Tf\"];dynCall_iij=dynCalls[\"iij\"]=wasmExports[\"Uf\"];dynCall_iidiiii=dynCalls[\"iidiiii\"]=wasmExports[\"Vf\"];dynCall_iijii=dynCalls[\"iijii\"]=wasmExports[\"Wf\"];dynCall_iiji=dynCalls[\"iiji\"]=wasmExports[\"Xf\"];dynCall_i=dynCalls[\"i\"]=wasmExports[\"Yf\"];dynCall_iiiiiij=dynCalls[\"iiiiiij\"]=wasmExports[\"Zf\"];dynCall_iiid=dynCalls[\"iiid\"]=wasmExports[\"_f\"];dynCall_iiij=dynCalls[\"iiij\"]=wasmExports[\"$f\"];dynCall_dii=dynCalls[\"dii\"]=wasmExports[\"ag\"];dynCall_jii=dynCalls[\"jii\"]=wasmExports[\"bg\"];dynCall_ji=dynCalls[\"ji\"]=wasmExports[\"cg\"];dynCall_vid=dynCalls[\"vid\"]=wasmExports[\"dg\"];dynCall_vij=dynCalls[\"vij\"]=wasmExports[\"eg\"];dynCall_iiiiiiiiii=dynCalls[\"iiiiiiiiii\"]=wasmExports[\"fg\"];dynCall_di=dynCalls[\"di\"]=wasmExports[\"gg\"];dynCall_iiiiijii=dynCalls[\"iiiiijii\"]=wasmExports[\"hg\"];dynCall_j=dynCalls[\"j\"]=wasmExports[\"ig\"];dynCall_jj=dynCalls[\"jj\"]=wasmExports[\"jg\"];dynCall_jiij=dynCalls[\"jiij\"]=wasmExports[\"kg\"];dynCall_iiiiji=dynCalls[\"iiiiji\"]=wasmExports[\"lg\"];dynCall_iiiijii=dynCalls[\"iiiijii\"]=wasmExports[\"mg\"];dynCall_ij=dynCalls[\"ij\"]=wasmExports[\"ng\"];dynCall_v=dynCalls[\"v\"]=wasmExports[\"og\"];dynCall_viiji=dynCalls[\"viiji\"]=wasmExports[\"pg\"];dynCall_viijii=dynCalls[\"viijii\"]=wasmExports[\"qg\"];dynCall_iiiiiiiiiii=dynCalls[\"iiiiiiiiiii\"]=wasmExports[\"rg\"];dynCall_iiiijji=dynCalls[\"iiiijji\"]=wasmExports[\"sg\"];dynCall_iiiiiiii=dynCalls[\"iiiiiiii\"]=wasmExports[\"tg\"];_asyncify_start_unwind=wasmExports[\"ug\"];_asyncify_stop_unwind=wasmExports[\"vg\"];_asyncify_start_rewind=wasmExports[\"wg\"];_asyncify_stop_rewind=wasmExports[\"xg\"];memory=wasmMemory=wasmExports[\"qa\"];_sqlite3_version=Module[\"_sqlite3_version\"]=wasmExports[\"mf\"].value;__indirect_function_table=wasmTable=wasmExports[\"xf\"]}var wasmImports={a:___assert_fail,aa:___syscall_chmod,ca:___syscall_faccessat,ba:___syscall_fchmod,$:___syscall_fchown32,b:___syscall_fcntl64,_:___syscall_fstat64,y:___syscall_ftruncate64,U:___syscall_getcwd,Y:___syscall_lstat64,Q:___syscall_mkdirat,W:___syscall_newfstatat,O:___syscall_openat,M:___syscall_readlinkat,L:___syscall_rmdir,Z:___syscall_stat64,J:___syscall_unlinkat,I:___syscall_utimensat,ea:__abort_js,E:__emscripten_runtime_keepalive_clear,w:__localtime_js,u:__mmap_js,v:__munmap_js,F:__setitimer_js,P:__tzset_js,n:_emscripten_date_now,g:_emscripten_get_now,G:_emscripten_resize_heap,R:_environ_get,S:_environ_sizes_get,o:_fd_close,H:_fd_fdstat_get,N:_fd_read,x:_fd_seek,V:_fd_sync,K:_fd_write,s:_ipp,t:_ipp_async,la:_ippipppp,pa:_ippipppp_async,j:_ippp,k:_ippp_async,c:_ipppi,d:_ipppi_async,ha:_ipppiii,ia:_ipppiii_async,ja:_ipppiiip,ka:_ipppiiip_async,h:_ipppip,i:_ipppip_async,z:_ipppj,A:_ipppj_async,e:_ipppp,f:_ipppp_async,fa:_ippppi,ga:_ippppi_async,B:_ippppij,C:_ippppij_async,p:_ippppip,q:_ippppip_async,ma:_ipppppip,na:_ipppppip_async,D:_proc_exit,T:_random_get,oa:_vppippii,r:_vppippii_async,l:_vppp,m:_vppp_async,X:_vpppip,da:_vpppip_async};function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){dependenciesFulfilled=run;return}preRun();if(runDependencies>0){dependenciesFulfilled=run;return}function doRun(){Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve?.(Module);Module[\"onRuntimeInitialized\"]?.();var noInitialRun=Module[\"noInitialRun\"]||false;if(!noInitialRun)callMain();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(()=>{setTimeout(()=>Module[\"setStatus\"](\"\"),1);doRun()},1)}else{doRun()}}var wasmExports;wasmExports=await (createWasm());run();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"set_authorizer\"]=function(db,xAuthorizer,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xAuthorizer instanceof AsyncFunction?1:0,\"i32\");const result=ccall(\"libauthorizer_set_authorizer\",\"number\",[\"number\",\"number\",\"number\"],[db,xAuthorizer?1:0,pAsyncFlags]);if(!result&&xAuthorizer){Module[\"setCallback\"](pAsyncFlags,(_,iAction,p3,p4,p5,p6)=>xAuthorizer(pApp,iAction,p3,p4,p5,p6))}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;const FUNC_METHODS=[\"xFunc\",\"xStep\",\"xFinal\"];const mapFunctionNameToKey=new Map;Module[\"create_function\"]=function(db,zFunctionName,nArg,eTextRep,pApp,xFunc,xStep,xFinal){const pAsyncFlags=Module[\"_sqlite3_malloc\"](4);const target={xFunc,xStep,xFinal};setValue(pAsyncFlags,FUNC_METHODS.reduce((mask,method,i)=>{if(target[method]instanceof AsyncFunction){return mask|1<<i}return mask},0),\"i32\");const result=ccall(\"libfunction_create_function\",\"number\",[\"number\",\"string\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"],[db,zFunctionName,nArg,eTextRep,pAsyncFlags,xFunc?1:0,xStep?1:0,xFinal?1:0]);if(!result){if(mapFunctionNameToKey.has(zFunctionName)){const oldKey=mapFunctionNameToKey.get(zFunctionName);Module[\"deleteCallback\"](oldKey)}mapFunctionNameToKey.set(zFunctionName,pAsyncFlags);Module[\"setCallback\"](pAsyncFlags,{xFunc,xStep,xFinal})}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"update_hook\"]=function(db,xUpdateHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xUpdateHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_update_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xUpdateHook?1:0,pAsyncFlags]);if(xUpdateHook){Module[\"setCallback\"](pAsyncFlags,(_,iUpdateType,dbName,tblName,lo32,hi32)=>xUpdateHook(iUpdateType,dbName,tblName,lo32,hi32))}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"commit_hook\"]=function(db,xCommitHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xCommitHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_commit_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xCommitHook?1:0,pAsyncFlags]);if(xCommitHook){Module[\"setCallback\"](pAsyncFlags,_=>xCommitHook())}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"progress_handler\"]=function(db,nOps,xProgress,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xProgress instanceof AsyncFunction?1:0,\"i32\");ccall(\"libprogress_progress_handler\",\"number\",[\"number\",\"number\",\"number\",\"number\"],[db,nOps,xProgress?1:0,pAsyncFlags]);if(xProgress){Module[\"setCallback\"](pAsyncFlags,_=>xProgress(pApp))}}})();(function(){const VFS_METHODS=[\"xOpen\",\"xDelete\",\"xAccess\",\"xFullPathname\",\"xRandomness\",\"xSleep\",\"xCurrentTime\",\"xGetLastError\",\"xCurrentTimeInt64\",\"xClose\",\"xRead\",\"xWrite\",\"xTruncate\",\"xSync\",\"xFileSize\",\"xLock\",\"xUnlock\",\"xCheckReservedLock\",\"xFileControl\",\"xSectorSize\",\"xDeviceCharacteristics\",\"xShmMap\",\"xShmLock\",\"xShmBarrier\",\"xShmUnmap\"];const mapVFSNameToKey=new Map;Module[\"vfs_register\"]=function(vfs,makeDefault){let methodMask=0;let asyncMask=0;VFS_METHODS.forEach((method,i)=>{if(vfs[method]){methodMask|=1<<i;if(vfs[\"hasAsyncMethod\"](method)){asyncMask|=1<<i}}});const vfsReturn=Module[\"_sqlite3_malloc\"](4);try{const result=ccall(\"libvfs_vfs_register\",\"number\",[\"string\",\"number\",\"number\",\"number\",\"number\",\"number\"],[vfs.name,vfs.mxPathname,methodMask,asyncMask,makeDefault?1:0,vfsReturn]);if(!result){if(mapVFSNameToKey.has(vfs.name)){const oldKey=mapVFSNameToKey.get(vfs.name);Module[\"deleteCallback\"](oldKey)}const key=getValue(vfsReturn,\"*\");mapVFSNameToKey.set(vfs.name,key);Module[\"setCallback\"](key,vfs)}return result}finally{Module[\"_sqlite3_free\"](vfsReturn)}}})();if(runtimeInitialized){moduleRtn=Module}else{moduleRtn=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject})}\n;return moduleRtn}export default Module;\n","async function Module(moduleArg={}){var moduleRtn;var Module=moduleArg;var ENVIRONMENT_IS_WEB=!!globalThis.window;var ENVIRONMENT_IS_WORKER=!!globalThis.WorkerGlobalScope;var ENVIRONMENT_IS_NODE=globalThis.process?.versions?.node&&globalThis.process?.type!=\"renderer\";var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var _scriptName=import.meta.url;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){try{scriptDirectory=new URL(\".\",_scriptName).href}catch{}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=async url=>{var response=await fetch(url,{credentials:\"same-origin\"});if(response.ok){return response.arrayBuffer()}throw new Error(response.status+\" : \"+response.url)}}}else{}var out=console.log.bind(console);var err=console.error.bind(console);var wasmBinary;var ABORT=false;var EXITSTATUS;var readyPromiseResolve,readyPromiseReject;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var runtimeInitialized=false;function updateMemoryViews(){var b=wasmMemory.buffer;HEAP8=new Int8Array(b);HEAP16=new Int16Array(b);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(b);HEAPU16=new Uint16Array(b);Module[\"HEAP32\"]=HEAP32=new Int32Array(b);HEAPU32=new Uint32Array(b);HEAPF32=new Float32Array(b);HEAPF64=new Float64Array(b)}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(onPreRuns)}function initRuntime(){runtimeInitialized=true;if(!Module[\"noFSInit\"]&&!FS.initialized)FS.init();TTY.init();wasmExports[\"ra\"]();FS.ignorePermissions=false}function preMain(){}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(onPostRuns)}function abort(what){Module[\"onAbort\"]?.(what);what=\"Aborted(\"+what+\")\";err(what);ABORT=true;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject?.(e);throw e}var wasmBinaryFile;function findWasmBinary(){if(Module[\"locateFile\"]){return locateFile(\"mc-wa-sqlite.wasm\")}return new URL(\"mc-wa-sqlite.wasm\",import.meta.url).href}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}async function getWasmBinary(binaryFile){if(!wasmBinary){try{var response=await readAsync(binaryFile);return new Uint8Array(response)}catch{}}return getBinarySync(binaryFile)}async function instantiateArrayBuffer(binaryFile,imports){try{var binary=await getWasmBinary(binaryFile);var instance=await WebAssembly.instantiate(binary,imports);return instance}catch(reason){err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)}}async function instantiateAsync(binary,binaryFile,imports){if(!binary){try{var response=fetch(binaryFile,{credentials:\"same-origin\"});var instantiationResult=await WebAssembly.instantiateStreaming(response,imports);return instantiationResult}catch(reason){err(`wasm streaming compile failed: ${reason}`);err(\"falling back to ArrayBuffer instantiation\")}}return instantiateArrayBuffer(binaryFile,imports)}function getWasmImports(){var imports={a:wasmImports};return imports}async function createWasm(){function receiveInstance(instance,module){wasmExports=instance.exports;assignWasmExports(wasmExports);updateMemoryViews();return wasmExports}function receiveInstantiationResult(result){return receiveInstance(result[\"instance\"])}var info=getWasmImports();if(Module[\"instantiateWasm\"]){return new Promise((resolve,reject)=>{Module[\"instantiateWasm\"](info,(inst,mod)=>{resolve(receiveInstance(inst,mod))})})}wasmBinaryFile??=findWasmBinary();var result=await instantiateAsync(wasmBinary,wasmBinaryFile,info);var exports=receiveInstantiationResult(result);return exports}var tempDouble;var tempI64;class ExitStatus{name=\"ExitStatus\";constructor(status){this.message=`Program terminated with exit(${status})`;this.status=status}}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};var onPostRuns=[];var addOnPostRun=cb=>onPostRuns.push(cb);var onPreRuns=[];var addOnPreRun=cb=>onPreRuns.push(cb);function getValue(ptr,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":return HEAP8[ptr];case\"i8\":return HEAP8[ptr];case\"i16\":return HEAP16[ptr>>1];case\"i32\":return HEAP32[ptr>>2];case\"i64\":abort(\"to do getValue(i64) use WASM_BIGINT\");case\"float\":return HEAPF32[ptr>>2];case\"double\":return HEAPF64[ptr>>3];case\"*\":return HEAPU32[ptr>>2];default:abort(`invalid type for getValue: ${type}`)}}var noExitRuntime=true;function setValue(ptr,value,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":HEAP8[ptr]=value;break;case\"i8\":HEAP8[ptr]=value;break;case\"i16\":HEAP16[ptr>>1]=value;break;case\"i32\":HEAP32[ptr>>2]=value;break;case\"i64\":abort(\"to do setValue(i64) use WASM_BIGINT\");case\"float\":HEAPF32[ptr>>2]=value;break;case\"double\":HEAPF64[ptr>>3]=value;break;case\"*\":HEAPU32[ptr>>2]=value;break;default:abort(`invalid type for setValue: ${type}`)}}var stackRestore=val=>__emscripten_stack_restore(val);var stackSave=()=>_emscripten_stack_get_current();var UTF8Decoder=new TextDecoder;var findStringEnd=(heapOrArray,idx,maxBytesToRead,ignoreNul)=>{var maxIdx=idx+maxBytesToRead;if(ignoreNul)return maxIdx;while(heapOrArray[idx]&&!(idx>=maxIdx))++idx;return idx};var UTF8ToString=(ptr,maxBytesToRead,ignoreNul)=>{if(!ptr)return\"\";var end=findStringEnd(HEAPU8,ptr,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(HEAPU8.subarray(ptr,end))};var ___assert_fail=(condition,filename,line,func)=>abort(`Assertion failed: ${UTF8ToString(condition)}, at: `+[filename?UTF8ToString(filename):\"unknown filename\",line,func?UTF8ToString(func):\"unknown function\"]);var PATH={isAbs:path=>path.charAt(0)===\"/\",splitPath:filename=>{var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.slice(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(p=>!!p),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.slice(0,-1)}return root+dir},basename:path=>path&&path.match(/([^\\/]+|\\/)\\/*$/)[1],join:(...paths)=>PATH.normalize(paths.join(\"/\")),join2:(l,r)=>PATH.normalize(l+\"/\"+r)};var initRandomFill=()=>view=>crypto.getRandomValues(view);var randomFill=view=>{(randomFill=initRandomFill())(view)};var PATH_FS={resolve:(...args)=>{var resolvedPath=\"\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\"string\"){throw new TypeError(\"Arguments to path.resolve must be strings\")}else if(!path){return\"\"}resolvedPath=path+\"/\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\"/\").filter(p=>!!p),!resolvedAbsolute).join(\"/\");return(resolvedAbsolute?\"/\":\"\")+resolvedPath||\".\"},relative:(from,to)=>{from=PATH_FS.resolve(from).slice(1);to=PATH_FS.resolve(to).slice(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\"\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\"\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\"/\"));var toParts=trim(to.split(\"/\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\"..\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\"/\")}};var UTF8ArrayToString=(heapOrArray,idx=0,maxBytesToRead,ignoreNul)=>{var endPtr=findStringEnd(heapOrArray,idx,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(heapOrArray.buffer?heapOrArray.subarray(idx,endPtr):new Uint8Array(heapOrArray.slice(idx,endPtr)))};var FS_stdin_getChar_buffer=[];var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.codePointAt(i);if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;i++}}heap[outIdx]=0;return outIdx-startIdx};var intArrayFromString=(stringy,dontAddNull,length)=>{var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array};var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(globalThis.window?.prompt){result=window.prompt(\"Input: \");if(result!==null){result+=\"\\n\"}}else{}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){out(UTF8ArrayToString(tty.output));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){err(UTF8ArrayToString(tty.output));tty.output=[]}}}};var zeroMemory=(ptr,size)=>HEAPU8.fill(0,ptr,ptr+size);var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(ptr)zeroMemory(ptr,size);return ptr};var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\"/\",16895,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.atime=node.mtime=node.ctime=Date.now();if(parent){parent.contents[name]=node;parent.atime=parent.mtime=parent.ctime=node.atime}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.atime);attr.mtime=new Date(node.mtime);attr.ctime=new Date(node.ctime);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){for(const key of[\"mode\",\"atime\",\"mtime\",\"ctime\"]){if(attr[key]!=null){node[key]=attr[key]}}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){if(!MEMFS.doesNotExistError){MEMFS.doesNotExistError=new FS.ErrnoError(44);MEMFS.doesNotExistError.stack=\"<generic error, no stack>\"}throw MEMFS.doesNotExistError},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){if(FS.isDir(old_node.mode)){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}FS.hashRemoveNode(new_node)}delete old_node.parent.contents[old_node.name];new_dir.contents[new_name]=old_node;old_node.name=new_name;new_dir.ctime=new_dir.mtime=old_node.parent.ctime=old_node.parent.mtime=Date.now()},unlink(parent,name){delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},readdir(node){return[\".\",\"..\",...Object.keys(node.contents)]},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.mtime=node.ctime=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents&&contents.buffer===HEAP8.buffer){allocated=false;ptr=contents.byteOffset}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}if(contents){if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}HEAP8.set(contents,ptr)}}return{ptr,allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var FS_modeStringToFlags=str=>{var flagModes={r:0,\"r+\":2,w:512|64|1,\"w+\":512|64|2,a:1024|64|1,\"a+\":1024|64|2};var flags=flagModes[str];if(typeof flags==\"undefined\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};var asyncLoad=async url=>{var arrayBuffer=await readAsync(url);return new Uint8Array(arrayBuffer)};var FS_createDataFile=(...args)=>FS.createDataFile(...args);var getUniqueRunDependency=id=>id;var runDependencies=0;var dependenciesFulfilled=null;var removeRunDependency=id=>{runDependencies--;Module[\"monitorRunDependencies\"]?.(runDependencies);if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}};var addRunDependency=id=>{runDependencies++;Module[\"monitorRunDependencies\"]?.(runDependencies)};var preloadPlugins=[];var FS_handledByPreloadPlugin=async(byteArray,fullname)=>{if(typeof Browser!=\"undefined\")Browser.init();for(var plugin of preloadPlugins){if(plugin[\"canHandle\"](fullname)){return plugin[\"handle\"](byteArray,fullname)}}return byteArray};var FS_preloadFile=async(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);addRunDependency(dep);try{var byteArray=url;if(typeof url==\"string\"){byteArray=await asyncLoad(url)}byteArray=await FS_handledByPreloadPlugin(byteArray,fullname);preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}}finally{removeRunDependency(dep)}};var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{FS_preloadFile(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish).then(onload).catch(onerror)};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,filesystems:null,syncFSRequests:0,ErrnoError:class{name=\"ErrnoError\";constructor(errno){this.errno=errno}},FSStream:class{shared={};get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{node_ops={};stream_ops={};readMode=292|73;writeMode=146;mounted=null;constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.rdev=rdev;this.atime=this.mtime=this.ctime=Date.now()}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){if(!path){throw new FS.ErrnoError(44)}opts.follow_mount??=true;if(!PATH.isAbs(path)){path=FS.cwd()+\"/\"+path}linkloop:for(var nlinks=0;nlinks<40;nlinks++){var parts=path.split(\"/\").filter(p=>!!p);var current=FS.root;var current_path=\"/\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}if(parts[i]===\".\"){continue}if(parts[i]===\"..\"){current_path=PATH.dirname(current_path);if(FS.isRoot(current)){path=current_path+\"/\"+parts.slice(i+1).join(\"/\");nlinks--;continue linkloop}else{current=current.parent}continue}current_path=PATH.join2(current_path,parts[i]);try{current=FS.lookupNode(current,parts[i])}catch(e){if(e?.errno===44&&islast&&opts.noent_okay){return{path:current_path}}throw e}if(FS.isMountpoint(current)&&(!islast||opts.follow_mount)){current=current.mounted.root}if(FS.isLink(current.mode)&&(!islast||opts.follow)){if(!current.node_ops.readlink){throw new FS.ErrnoError(52)}var link=current.node_ops.readlink(current);if(!PATH.isAbs(link)){link=PATH.dirname(current_path)+\"/\"+link}path=link+\"/\"+parts.slice(i+1).join(\"/\");continue linkloop}}return{path:current_path,node:current}}throw new FS.ErrnoError(32)},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\"/\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\"r\",\"w\",\"rw\"][flag&3];if(flag&512){perms+=\"w\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\"r\")&&!(node.mode&292)){return 2}if(perms.includes(\"w\")&&!(node.mode&146)){return 2}if(perms.includes(\"x\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\"x\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){if(!FS.isDir(dir.mode)){return 54}try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\"wx\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\"wx\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else if(FS.isDir(node.mode)){return 31}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}var mode=FS.flagsToPermissionString(flags);if(FS.isDir(node.mode)){if(mode!==\"r\"||flags&(512|64)){return 31}}return FS.nodePermissions(node,mode)},checkOpExists(op,err){if(!op){throw new FS.ErrnoError(err)}return op},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},doSetAttr(stream,node,attr){var setattr=stream?.stream_ops.setattr;var arg=setattr?stream:node;setattr??=node.node_ops.setattr;FS.checkOpExists(setattr,63);setattr(arg,attr)},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\"function\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}for(var mount of mounts){if(mount.type.syncfs){mount.type.syncfs(mount,populate,done)}else{done(null)}}},mount(type,opts,mountpoint){var root=mountpoint===\"/\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type,opts,mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);for(var[hash,current]of Object.entries(FS.nameTable)){while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}}node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name){throw new FS.ErrnoError(28)}if(name===\".\"||name===\"..\"){throw new FS.ErrnoError(20)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},statfs(path){return FS.statfsNode(FS.lookupPath(path,{follow:true}).node)},statfsStream(stream){return FS.statfsNode(stream.node)},statfsNode(node){var rtn={bsize:4096,frsize:4096,blocks:1e6,bfree:5e5,bavail:5e5,files:FS.nextInode,ffree:FS.nextInode-1,fsid:42,flags:2,namelen:255};if(node.node_ops.statfs){Object.assign(rtn,node.node_ops.statfs(node.mount.opts.root))}return rtn},create(path,mode=438){mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode=511){mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\"/\");var d=\"\";for(var dir of dirs){if(!dir)continue;if(d||PATH.isAbs(path))d+=\"/\";d+=dir;try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\"undefined\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);old_node.parent=new_dir}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var readdir=FS.checkOpExists(node.node_ops.readdir,54);return readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return link.node_ops.readlink(link)},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;var getattr=FS.checkOpExists(node.node_ops.getattr,63);return getattr(node)},fstat(fd){var stream=FS.getStreamChecked(fd);var node=stream.node;var getattr=stream.stream_ops.getattr;var arg=getattr?stream:node;getattr??=node.node_ops.getattr;FS.checkOpExists(getattr,63);return getattr(arg)},lstat(path){return FS.stat(path,true)},doChmod(stream,node,mode,dontFollow){FS.doSetAttr(stream,node,{mode:mode&4095|node.mode&~4095,ctime:Date.now(),dontFollow})},chmod(path,mode,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChmod(null,node,mode,dontFollow)},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.doChmod(stream,stream.node,mode,false)},doChown(stream,node,dontFollow){FS.doSetAttr(stream,node,{timestamp:Date.now(),dontFollow})},chown(path,uid,gid,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChown(null,node,dontFollow)},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.doChown(stream,stream.node,false)},doTruncate(stream,node,len){if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}FS.doSetAttr(stream,node,{size:len,timestamp:Date.now()})},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}FS.doTruncate(null,node,len)},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if(len<0||(stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.doTruncate(stream,stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var setattr=FS.checkOpExists(node.node_ops.setattr,63);setattr(node,{atime,mtime})},open(path,flags,mode=438){if(path===\"\"){throw new FS.ErrnoError(44)}flags=typeof flags==\"string\"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;var isDirPath;if(typeof path==\"object\"){node=path}else{isDirPath=path.endsWith(\"/\");var lookup=FS.lookupPath(path,{follow:!(flags&131072),noent_okay:true});node=lookup.node;path=lookup.path}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else if(isDirPath){throw new FS.ErrnoError(31)}else{node=FS.mknod(path,mode|511,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node,path:FS.getPath(node),flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(created){FS.chmod(node,mode&511)}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}if(!length){throw new FS.ErrnoError(28)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\"binary\";if(opts.encoding!==\"utf8\"&&opts.encoding!==\"binary\"){abort(`Invalid encoding type \"${opts.encoding}\"`)}var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\"utf8\"){buf=UTF8ArrayToString(buf)}FS.close(stream);return buf},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\"string\"){data=new Uint8Array(intArrayFromString(data,true))}if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{abort(\"Unsupported data type\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\"x\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\"/tmp\");FS.mkdir(\"/home\");FS.mkdir(\"/home/web_user\")},createDefaultDevices(){FS.mkdir(\"/dev\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length,llseek:()=>0});FS.mkdev(\"/dev/null\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\"/dev/tty\",FS.makedev(5,0));FS.mkdev(\"/dev/tty1\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomFill(randomBuffer);randomLeft=randomBuffer.byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\"/dev\",\"random\",randomByte);FS.createDevice(\"/dev\",\"urandom\",randomByte);FS.mkdir(\"/dev/shm\");FS.mkdir(\"/dev/shm/tmp\")},createSpecialDirectories(){FS.mkdir(\"/proc\");var proc_self=FS.mkdir(\"/proc/self\");FS.mkdir(\"/proc/self/fd\");FS.mount({mount(){var node=FS.createNode(proc_self,\"fd\",16895,73);node.stream_ops={llseek:MEMFS.stream_ops.llseek};node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\"fake\"},node_ops:{readlink:()=>stream.path},id:fd+1};ret.parent=ret;return ret},readdir(){return Array.from(FS.streams.entries()).filter(([k,v])=>v).map(([k,v])=>k.toString())}};return node}},{},\"/proc/self/fd\")},createStandardStreams(input,output,error){if(input){FS.createDevice(\"/dev\",\"stdin\",input)}else{FS.symlink(\"/dev/tty\",\"/dev/stdin\")}if(output){FS.createDevice(\"/dev\",\"stdout\",null,output)}else{FS.symlink(\"/dev/tty\",\"/dev/stdout\")}if(error){FS.createDevice(\"/dev\",\"stderr\",null,error)}else{FS.symlink(\"/dev/tty1\",\"/dev/stderr\")}var stdin=FS.open(\"/dev/stdin\",0);var stdout=FS.open(\"/dev/stdout\",1);var stderr=FS.open(\"/dev/stderr\",1)},staticInit(){FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\"/\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={MEMFS}},init(input,output,error){FS.initialized=true;input??=Module[\"stdin\"];output??=Module[\"stdout\"];error??=Module[\"stderr\"];FS.createStandardStreams(input,output,error)},quit(){FS.initialized=false;for(var stream of FS.streams){if(stream){FS.close(stream)}}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\"/\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\"string\"?parent:FS.getPath(parent);var parts=path.split(\"/\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){if(e.errno!=20)throw e}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\"string\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\"string\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(globalThis.XMLHttpRequest){abort(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\")}else{try{obj.contents=readBinary(obj.url)}catch(e){throw new FS.ErrnoError(29)}}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{lengthKnown=false;chunks=[];get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\"HEAD\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);var datalength=Number(xhr.getResponseHeader(\"Content-length\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\"Accept-Ranges\"))&&header===\"bytes\";var usesGzip=(header=xhr.getResponseHeader(\"Content-Encoding\"))&&header===\"gzip\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)abort(\"invalid range (\"+from+\", \"+to+\") or no bytes requested!\");if(to>datalength-1)abort(\"only \"+datalength+\" bytes available! programmer error!\");var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\"Range\",\"bytes=\"+from+\"-\"+to);xhr.responseType=\"arraybuffer\";if(xhr.overrideMimeType){xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\"\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\"undefined\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\"undefined\")abort(\"doXHR failed!\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\"LazyFiles on gzip forces download of the whole file when length is accessed\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(globalThis.XMLHttpRequest){if(!ENVIRONMENT_IS_WORKER)abort(\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\");var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};for(const[key,fn]of Object.entries(node.stream_ops)){stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}}function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr,allocated:true}};node.stream_ops=stream_ops;return node}};var SYSCALLS={calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return dir+\"/\"+path},writeStat(buf,stat){HEAPU32[buf>>2]=stat.dev;HEAPU32[buf+4>>2]=stat.mode;HEAPU32[buf+8>>2]=stat.nlink;HEAPU32[buf+12>>2]=stat.uid;HEAPU32[buf+16>>2]=stat.gid;HEAPU32[buf+20>>2]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];HEAP32[buf+32>>2]=4096;HEAP32[buf+36>>2]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=atime%1e3*1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+56>>2]=tempI64[0],HEAP32[buf+60>>2]=tempI64[1];HEAPU32[buf+64>>2]=mtime%1e3*1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+72>>2]=tempI64[0],HEAP32[buf+76>>2]=tempI64[1];HEAPU32[buf+80>>2]=ctime%1e3*1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+88>>2]=tempI64[0],HEAP32[buf+92>>2]=tempI64[1];return 0},writeStatFs(buf,stats){HEAPU32[buf+4>>2]=stats.bsize;HEAPU32[buf+60>>2]=stats.bsize;tempI64=[stats.blocks>>>0,(tempDouble=stats.blocks,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+8>>2]=tempI64[0],HEAP32[buf+12>>2]=tempI64[1];tempI64=[stats.bfree>>>0,(tempDouble=stats.bfree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+16>>2]=tempI64[0],HEAP32[buf+20>>2]=tempI64[1];tempI64=[stats.bavail>>>0,(tempDouble=stats.bavail,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];tempI64=[stats.files>>>0,(tempDouble=stats.files,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+32>>2]=tempI64[0],HEAP32[buf+36>>2]=tempI64[1];tempI64=[stats.ffree>>>0,(tempDouble=stats.ffree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=stats.fsid;HEAPU32[buf+64>>2]=stats.flags;HEAPU32[buf+56>>2]=stats.namelen},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_chmod(path,mode){try{path=SYSCALLS.getStr(path);FS.chmod(path,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_faccessat(dirfd,path,amode,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(amode&~7){return-28}var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node){return-44}var perms=\"\";if(amode&4)perms+=\"r\";if(amode&2)perms+=\"w\";if(amode&1)perms+=\"x\";if(perms&&FS.nodePermissions(node,perms)){return-2}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchmod(fd,mode){try{FS.fchmod(fd,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchown32(fd,owner,group){try{FS.fchown(fd,owner,group);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var syscallGetVarargI=()=>{var ret=HEAP32[+SYSCALLS.varargs>>2];SYSCALLS.varargs+=4;return ret};var syscallGetVarargP=syscallGetVarargI;function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0}case 12:{var arg=syscallGetVarargP();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fstat64(fd,buf){try{return SYSCALLS.writeStat(buf,FS.fstat(fd))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;function ___syscall_ftruncate64(fd,length_low,length_high){var length=convertI32PairToI53Checked(length_low,length_high);try{if(isNaN(length))return-61;FS.ftruncate(fd,length);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);function ___syscall_getcwd(buf,size){try{if(size===0)return-28;var cwd=FS.cwd();var cwdLengthInBytes=lengthBytesUTF8(cwd)+1;if(size<cwdLengthInBytes)return-68;stringToUTF8(cwd,buf,size);return cwdLengthInBytes}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_lstat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.lstat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_mkdirat(dirfd,path,mode){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);FS.mkdir(path,mode,0);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_newfstatat(dirfd,path,buf,flags){try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~6400;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.writeStat(buf,nofollow?FS.lstat(path):FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_readlinkat(dirfd,path,buf,bufsize){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(bufsize<=0)return-28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_rmdir(path){try{path=SYSCALLS.getStr(path);FS.rmdir(path);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_unlinkat(dirfd,path,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(!flags){FS.unlink(path)}else if(flags===512){FS.rmdir(path)}else{return-28}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var readI53FromI64=ptr=>HEAPU32[ptr>>2]+HEAP32[ptr+4>>2]*4294967296;function ___syscall_utimensat(dirfd,path,times,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path,true);var now=Date.now(),atime,mtime;if(!times){atime=now;mtime=now}else{var seconds=readI53FromI64(times);var nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){atime=now}else if(nanoseconds==1073741822){atime=null}else{atime=seconds*1e3+nanoseconds/(1e3*1e3)}times+=16;seconds=readI53FromI64(times);nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){mtime=now}else if(nanoseconds==1073741822){mtime=null}else{mtime=seconds*1e3+nanoseconds/(1e3*1e3)}}if((mtime??atime)!==null){FS.utime(path,atime,mtime)}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var __abort_js=()=>abort(\"\");var runtimeKeepaliveCounter=0;var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);var MONTH_DAYS_LEAP_CUMULATIVE=[0,31,60,91,121,152,182,213,244,274,305,335];var MONTH_DAYS_REGULAR_CUMULATIVE=[0,31,59,90,120,151,181,212,243,273,304,334];var ydayFromDate=date=>{var leap=isLeapYear(date.getFullYear());var monthDaysCumulative=leap?MONTH_DAYS_LEAP_CUMULATIVE:MONTH_DAYS_REGULAR_CUMULATIVE;var yday=monthDaysCumulative[date.getMonth()]+date.getDate()-1;return yday};function __localtime_js(time_low,time_high,tmPtr){var time=convertI32PairToI53Checked(time_low,time_high);var date=new Date(time*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var yday=ydayFromDate(date)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst}function __mmap_js(len,prot,flags,fd,offset_low,offset_high,allocated,addr){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;HEAP32[allocated>>2]=res.allocated;HEAPU32[addr>>2]=ptr;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function __munmap_js(addr,len,prot,flags,fd,offset_low,offset_high){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var timers={};var handleException=e=>{if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)};var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module[\"onExit\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var _exit=exitJS;var maybeExit=()=>{if(!keepRuntimeAlive()){try{_exit(EXITSTATUS)}catch(e){handleException(e)}}};var callUserCallback=func=>{if(ABORT){return}try{return func()}catch(e){handleException(e)}finally{maybeExit()}};var _emscripten_get_now=()=>performance.now();var __setitimer_js=(which,timeout_ms)=>{if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0};var __tzset_js=(timezone,daylight,std_name,dst_name)=>{var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAPU32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{var sign=timezoneOffset>=0?\"-\":\"+\";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,\"0\");var minutes=String(absOffset%60).padStart(2,\"0\");return`UTC${sign}${hours}${minutes}`};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17)}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17)}};var _emscripten_date_now=()=>Date.now();var getHeapMax=()=>2147483648;var growMemory=size=>{var oldHeapSize=wasmMemory.buffer.byteLength;var pages=(size-oldHeapSize+65535)/65536|0;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var ENV={};var getExecutableName=()=>thisProgram||\"./this.program\";var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(globalThis.navigator?.language??\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:lang,_:getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};var _environ_get=(__environ,environ_buf)=>{var bufSize=0;var envp=0;for(var string of getEnvStrings()){var ptr=environ_buf+bufSize;HEAPU32[__environ+envp>>2]=ptr;bufSize+=stringToUTF8(string,ptr,Infinity)+1;envp+=4}return 0};var _environ_sizes_get=(penviron_count,penviron_buf_size)=>{var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;for(var string of strings){bufSize+=lengthBytesUTF8(string)+1}HEAPU32[penviron_buf_size>>2]=bufSize;return 0};function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_fdstat_get(fd,pbuf){try{var rightsBase=0;var rightsInheriting=0;var flags=0;{var stream=SYSCALLS.getStreamFromFD(fd);var type=stream.tty?2:FS.isDir(stream.mode)?3:FS.isLink(stream.mode)?7:4}HEAP8[pbuf]=type;HEAP16[pbuf+2>>1]=flags;tempI64=[rightsBase>>>0,(tempDouble=rightsBase,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+8>>2]=tempI64[0],HEAP32[pbuf+12>>2]=tempI64[1];tempI64=[rightsInheriting>>>0,(tempDouble=rightsInheriting,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+16>>2]=tempI64[0],HEAP32[pbuf+20>>2]=tempI64[1];return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_sync(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);var rtn=stream.stream_ops?.fsync?.(stream);return rtn}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){break}if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var adapters_support=function(){const handleAsync=typeof Asyncify===\"object\"?Asyncify.handleAsync.bind(Asyncify):null;Module[\"handleAsync\"]=handleAsync;const targets=new Map;Module[\"setCallback\"]=(key,target)=>targets.set(key,target);Module[\"getCallback\"]=key=>targets.get(key);Module[\"deleteCallback\"]=key=>targets.delete(key);adapters_support=function(isAsync,key,...args){const receiver=targets.get(key);let methodName=null;const f=typeof receiver===\"function\"?receiver:receiver[methodName=UTF8ToString(args.shift())];if(isAsync){if(handleAsync){return handleAsync(()=>f.apply(receiver,args))}throw new Error(\"Synchronous WebAssembly cannot call async function\")}const result=f.apply(receiver,args);if(typeof result?.then==\"function\"){console.error(\"unexpected Promise\",f);throw new Error(`${methodName} unexpectedly returned a Promise`)}return result}};function _ipp(...args){return adapters_support(false,...args)}function _ipp_async(...args){return adapters_support(true,...args)}function _ippipppp(...args){return adapters_support(false,...args)}function _ippipppp_async(...args){return adapters_support(true,...args)}function _ippp(...args){return adapters_support(false,...args)}function _ippp_async(...args){return adapters_support(true,...args)}function _ipppi(...args){return adapters_support(false,...args)}function _ipppi_async(...args){return adapters_support(true,...args)}function _ipppiii(...args){return adapters_support(false,...args)}function _ipppiii_async(...args){return adapters_support(true,...args)}function _ipppiiip(...args){return adapters_support(false,...args)}function _ipppiiip_async(...args){return adapters_support(true,...args)}function _ipppip(...args){return adapters_support(false,...args)}function _ipppip_async(...args){return adapters_support(true,...args)}function _ipppj(...args){return adapters_support(false,...args)}function _ipppj_async(...args){return adapters_support(true,...args)}function _ipppp(...args){return adapters_support(false,...args)}function _ipppp_async(...args){return adapters_support(true,...args)}function _ippppi(...args){return adapters_support(false,...args)}function _ippppi_async(...args){return adapters_support(true,...args)}function _ippppij(...args){return adapters_support(false,...args)}function _ippppij_async(...args){return adapters_support(true,...args)}function _ippppip(...args){return adapters_support(false,...args)}function _ippppip_async(...args){return adapters_support(true,...args)}function _ipppppip(...args){return adapters_support(false,...args)}function _ipppppip_async(...args){return adapters_support(true,...args)}function _random_get(buffer,size){try{randomFill(HEAPU8.subarray(buffer,buffer+size));return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _vppippii(...args){return adapters_support(false,...args)}function _vppippii_async(...args){return adapters_support(true,...args)}function _vppp(...args){return adapters_support(false,...args)}function _vppp_async(...args){return adapters_support(true,...args)}function _vpppip(...args){return adapters_support(false,...args)}function _vpppip_async(...args){return adapters_support(true,...args)}var getWasmTableEntry=funcPtr=>wasmTable.get(funcPtr);var updateTableMap=(offset,count)=>{if(functionsInTableMap){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i)}}}};var functionsInTableMap;var getFunctionAddress=func=>{if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length)}return functionsInTableMap.get(func)||0};var freeTableIndexes=[];var getEmptyTableSlot=()=>{if(freeTableIndexes.length){return freeTableIndexes.pop()}return wasmTable[\"grow\"](1)};var setWasmTableEntry=(idx,func)=>wasmTable.set(idx,func);var uleb128EncodeWithLen=arr=>{const n=arr.length;return[n%128|128,n>>7,...arr]};var wasmTypeCodes={i:127,p:127,j:126,f:125,d:124,e:111};var generateTypePack=types=>uleb128EncodeWithLen(Array.from(types,type=>{var code=wasmTypeCodes[type];return code}));var convertJsFunctionToWasm=(func,sig)=>{var bytes=Uint8Array.of(0,97,115,109,1,0,0,0,1,...uleb128EncodeWithLen([1,96,...generateTypePack(sig.slice(1)),...generateTypePack(sig[0]===\"v\"?\"\":sig[0])]),2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{e:{f:func}});var wrappedFunc=instance.exports[\"f\"];return wrappedFunc};var addFunction=(func,sig)=>{var rtn=getFunctionAddress(func);if(rtn){return rtn}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func)}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped)}functionsInTableMap.set(func,ret);return ret};var getCFunc=ident=>{var func=Module[\"_\"+ident];return func};var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer)};var stackAlloc=sz=>__emscripten_stack_alloc(sz);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={string:str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},array:arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\"string\"){return UTF8ToString(ret)}if(returnType===\"boolean\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func(...cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret};var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\"number\"||type===\"boolean\");var numericRet=returnType!==\"string\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};var getTempRet0=val=>__emscripten_tempret_get();var stringToUTF16=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr};var stringToUTF32=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codePoint=str.codePointAt(i);if(codePoint>65535){i++}HEAP32[outPtr>>2]=codePoint;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr};var AsciiToString=ptr=>{var str=\"\";while(1){var ch=HEAPU8[ptr++];if(!ch)return str;str+=String.fromCharCode(ch)}};var UTF16Decoder=new TextDecoder(\"utf-16le\");var UTF16ToString=(ptr,maxBytesToRead,ignoreNul)=>{var idx=ptr>>1;var endIdx=findStringEnd(HEAPU16,idx,maxBytesToRead/2,ignoreNul);return UTF16Decoder.decode(HEAPU16.subarray(idx,endIdx))};var UTF32ToString=(ptr,maxBytesToRead,ignoreNul)=>{var str=\"\";var startIdx=ptr>>2;for(var i=0;!(i>=maxBytesToRead/4);i++){var utf32=HEAPU32[startIdx+i];if(!utf32&&!ignoreNul)break;str+=String.fromCodePoint(utf32)}return str};var intArrayToString=array=>{var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join(\"\")};var _getTempRet0=getTempRet0;FS.createPreloadedFile=FS_createPreloadedFile;FS.preloadFile=FS_preloadFile;FS.staticInit();adapters_support();{if(Module[\"noExitRuntime\"])noExitRuntime=Module[\"noExitRuntime\"];if(Module[\"preloadPlugins\"])preloadPlugins=Module[\"preloadPlugins\"];if(Module[\"print\"])out=Module[\"print\"];if(Module[\"printErr\"])err=Module[\"printErr\"];if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].shift()()}}}Module[\"getTempRet0\"]=getTempRet0;Module[\"ccall\"]=ccall;Module[\"cwrap\"]=cwrap;Module[\"addFunction\"]=addFunction;Module[\"setValue\"]=setValue;Module[\"getValue\"]=getValue;Module[\"UTF8ToString\"]=UTF8ToString;Module[\"stringToUTF8\"]=stringToUTF8;Module[\"lengthBytesUTF8\"]=lengthBytesUTF8;Module[\"intArrayFromString\"]=intArrayFromString;Module[\"intArrayToString\"]=intArrayToString;Module[\"AsciiToString\"]=AsciiToString;Module[\"UTF16ToString\"]=UTF16ToString;Module[\"stringToUTF16\"]=stringToUTF16;Module[\"UTF32ToString\"]=UTF32ToString;Module[\"stringToUTF32\"]=stringToUTF32;Module[\"writeArrayToMemory\"]=writeArrayToMemory;Module[\"_getTempRet0\"]=_getTempRet0;var _powersync_init_static,_sqlite3_status64,_sqlite3_status,_sqlite3_msize,_sqlite3_db_status,_sqlite3_vfs_find,_sqlite3_vfs_register,_sqlite3_vfs_unregister,_sqlite3_release_memory,_sqlite3_soft_heap_limit64,_sqlite3_memory_used,_sqlite3_hard_heap_limit64,_sqlite3_memory_highwater,_sqlite3_malloc,_sqlite3_malloc64,_sqlite3_free,_sqlite3_realloc,_sqlite3_realloc64,_sqlite3_str_vappendf,_sqlite3_str_append,_sqlite3_str_appendchar,_sqlite3_str_appendall,_sqlite3_str_appendf,_sqlite3_str_finish,_sqlite3_str_errcode,_sqlite3_str_length,_sqlite3_str_value,_sqlite3_str_reset,_sqlite3_str_new,_sqlite3_vmprintf,_sqlite3_mprintf,_sqlite3_vsnprintf,_sqlite3_snprintf,_sqlite3_log,_sqlite3_randomness,_sqlite3_stricmp,_sqlite3_strnicmp,_sqlite3_os_init,_sqlite3_os_end,_sqlite3_serialize,_sqlite3_prepare_v2,_sqlite3_step,_sqlite3_column_int64,_sqlite3_reset,_sqlite3_exec,_sqlite3_column_int,_sqlite3_finalize,_sqlite3_deserialize,_sqlite3_database_file_object,_sqlite3_backup_init,_sqlite3_backup_step,_sqlite3_backup_finish,_sqlite3_backup_remaining,_sqlite3_backup_pagecount,_sqlite3_clear_bindings,_sqlite3_value_blob,_sqlite3_value_text,_sqlite3_value_bytes,_sqlite3_value_bytes16,_sqlite3_value_double,_sqlite3_value_int,_sqlite3_value_int64,_sqlite3_value_subtype,_sqlite3_value_pointer,_sqlite3_value_text16,_sqlite3_value_text16be,_sqlite3_value_text16le,_sqlite3_value_type,_sqlite3_value_encoding,_sqlite3_value_nochange,_sqlite3_value_frombind,_sqlite3_value_dup,_sqlite3_value_free,_sqlite3_result_blob,_sqlite3_result_blob64,_sqlite3_result_double,_sqlite3_result_error,_sqlite3_result_error16,_sqlite3_result_int,_sqlite3_result_int64,_sqlite3_result_null,_sqlite3_result_pointer,_sqlite3_result_subtype,_sqlite3_result_text,_sqlite3_result_text64,_sqlite3_result_text16,_sqlite3_result_text16be,_sqlite3_result_text16le,_sqlite3_result_value,_sqlite3_result_error_toobig,_sqlite3_result_zeroblob,_sqlite3_result_zeroblob64,_sqlite3_result_error_code,_sqlite3_result_error_nomem,_sqlite3_user_data,_sqlite3_context_db_handle,_sqlite3_vtab_nochange,_sqlite3_vtab_in_first,_sqlite3_vtab_in_next,_sqlite3_aggregate_context,_sqlite3_get_auxdata,_sqlite3_set_auxdata,_sqlite3_column_count,_sqlite3_data_count,_sqlite3_column_blob,_sqlite3_column_bytes,_sqlite3_column_bytes16,_sqlite3_column_double,_sqlite3_column_text,_sqlite3_column_value,_sqlite3_column_text16,_sqlite3_column_type,_sqlite3_column_name,_sqlite3_column_name16,_sqlite3_bind_blob,_sqlite3_bind_blob64,_sqlite3_bind_double,_sqlite3_bind_int,_sqlite3_bind_int64,_sqlite3_bind_null,_sqlite3_bind_pointer,_sqlite3_bind_text,_sqlite3_bind_text64,_sqlite3_bind_text16,_sqlite3_bind_value,_sqlite3_bind_zeroblob,_sqlite3_bind_zeroblob64,_sqlite3_bind_parameter_count,_sqlite3_bind_parameter_name,_sqlite3_bind_parameter_index,_sqlite3_db_handle,_sqlite3_stmt_readonly,_sqlite3_stmt_isexplain,_sqlite3_stmt_explain,_sqlite3_stmt_busy,_sqlite3_next_stmt,_sqlite3_stmt_status,_sqlite3_sql,_sqlite3_expanded_sql,_sqlite3_value_numeric_type,_sqlite3_blob_open,_sqlite3_blob_close,_sqlite3_blob_read,_sqlite3_blob_write,_sqlite3_blob_bytes,_sqlite3_blob_reopen,_sqlite3_set_authorizer,_sqlite3_strglob,_sqlite3_strlike,_sqlite3_errmsg,_sqlite3_load_extension,_sqlite3_enable_load_extension,_sqlite3_auto_extension,_sqlite3_cancel_auto_extension,_sqlite3_reset_auto_extension,_sqlite3_prepare,_sqlite3_prepare_v3,_sqlite3_prepare16,_sqlite3_prepare16_v2,_sqlite3_prepare16_v3,_sqlite3_get_table,_sqlite3_free_table,_sqlite3_create_module,_sqlite3_create_module_v2,_sqlite3_drop_modules,_sqlite3_declare_vtab,_sqlite3_vtab_on_conflict,_sqlite3_vtab_config,_sqlite3_vtab_collation,_sqlite3_vtab_in,_sqlite3_vtab_rhs_value,_sqlite3_vtab_distinct,_sqlite3_keyword_name,_sqlite3_keyword_count,_sqlite3_keyword_check,_sqlite3_complete,_sqlite3_complete16,_sqlite3_libversion,_sqlite3_libversion_number,_sqlite3_threadsafe,_sqlite3_initialize,_sqlite3_shutdown,_sqlite3_config,_sqlite3_db_mutex,_sqlite3_db_release_memory,_sqlite3_db_cacheflush,_sqlite3_db_config,_sqlite3_last_insert_rowid,_sqlite3_set_last_insert_rowid,_sqlite3_changes64,_sqlite3_changes,_sqlite3_total_changes64,_sqlite3_total_changes,_sqlite3_txn_state,_sqlite3_close,_sqlite3_close_v2,_sqlite3_busy_handler,_sqlite3_progress_handler,_sqlite3_busy_timeout,_sqlite3_interrupt,_sqlite3_is_interrupted,_sqlite3_create_function,_sqlite3_create_function_v2,_sqlite3_create_window_function,_sqlite3_create_function16,_sqlite3_overload_function,_sqlite3_trace_v2,_sqlite3_commit_hook,_sqlite3_update_hook,_sqlite3_rollback_hook,_sqlite3_autovacuum_pages,_sqlite3_wal_autocheckpoint,_sqlite3_wal_hook,_sqlite3_wal_checkpoint_v2,_sqlite3_wal_checkpoint,_sqlite3_error_offset,_sqlite3_errmsg16,_sqlite3_errcode,_sqlite3_extended_errcode,_sqlite3_system_errno,_sqlite3_errstr,_sqlite3_limit,_sqlite3_open,_sqlite3_open_v2,_sqlite3_open16,_sqlite3_create_collation,_sqlite3_create_collation_v2,_sqlite3_create_collation16,_sqlite3_collation_needed,_sqlite3_collation_needed16,_sqlite3_get_clientdata,_sqlite3_set_clientdata,_sqlite3_get_autocommit,_sqlite3_table_column_metadata,_sqlite3_sleep,_sqlite3_extended_result_codes,_sqlite3_file_control,_sqlite3_test_control,_sqlite3_create_filename,_sqlite3_free_filename,_sqlite3_uri_parameter,_sqlite3_uri_key,_sqlite3_uri_boolean,_sqlite3_uri_int64,_sqlite3_filename_database,_sqlite3_filename_journal,_sqlite3_filename_wal,_sqlite3_db_name,_sqlite3_db_filename,_sqlite3_db_readonly,_sqlite3_compileoption_used,_sqlite3_compileoption_get,_sqlite3_sourceid,_sqlite3mc_config,_sqlite3mc_cipher_count,_sqlite3mc_cipher_index,_sqlite3mc_cipher_name,_sqlite3mc_config_cipher,_sqlite3mc_vfs_create,_memcmp,_malloc,_free,_memset,_RegisterExtensionFunctions,_getSqliteFree,_main,_libauthorizer_set_authorizer,_libfunction_create_function,_libhook_commit_hook,_libhook_update_hook,_libprogress_progress_handler,_libvfs_vfs_register,_memcpy,_emscripten_builtin_memalign,__emscripten_timeout,__emscripten_tempret_get,__emscripten_stack_restore,__emscripten_stack_alloc,_emscripten_stack_get_current,dynCall_viiiij,dynCall_vijii,dynCall_iiiij,dynCall_viji,dynCall_iij,dynCall_iijii,dynCall_iiji,dynCall_iiiiiij,dynCall_iiij,dynCall_jii,dynCall_ji,dynCall_vij,dynCall_iiiiijii,dynCall_j,dynCall_jj,dynCall_jiij,dynCall_iiiiji,dynCall_iiiijii,dynCall_ij,dynCall_viiji,dynCall_viijii,dynCall_iiiijji,memory,_sqlite3_version,__indirect_function_table,wasmMemory,wasmTable;function assignWasmExports(wasmExports){_powersync_init_static=Module[\"_powersync_init_static\"]=wasmExports[\"sa\"];_sqlite3_status64=Module[\"_sqlite3_status64\"]=wasmExports[\"ta\"];_sqlite3_status=Module[\"_sqlite3_status\"]=wasmExports[\"ua\"];_sqlite3_msize=Module[\"_sqlite3_msize\"]=wasmExports[\"va\"];_sqlite3_db_status=Module[\"_sqlite3_db_status\"]=wasmExports[\"wa\"];_sqlite3_vfs_find=Module[\"_sqlite3_vfs_find\"]=wasmExports[\"xa\"];_sqlite3_vfs_register=Module[\"_sqlite3_vfs_register\"]=wasmExports[\"ya\"];_sqlite3_vfs_unregister=Module[\"_sqlite3_vfs_unregister\"]=wasmExports[\"za\"];_sqlite3_release_memory=Module[\"_sqlite3_release_memory\"]=wasmExports[\"Aa\"];_sqlite3_soft_heap_limit64=Module[\"_sqlite3_soft_heap_limit64\"]=wasmExports[\"Ba\"];_sqlite3_memory_used=Module[\"_sqlite3_memory_used\"]=wasmExports[\"Ca\"];_sqlite3_hard_heap_limit64=Module[\"_sqlite3_hard_heap_limit64\"]=wasmExports[\"Da\"];_sqlite3_memory_highwater=Module[\"_sqlite3_memory_highwater\"]=wasmExports[\"Ea\"];_sqlite3_malloc=Module[\"_sqlite3_malloc\"]=wasmExports[\"Fa\"];_sqlite3_malloc64=Module[\"_sqlite3_malloc64\"]=wasmExports[\"Ga\"];_sqlite3_free=Module[\"_sqlite3_free\"]=wasmExports[\"Ha\"];_sqlite3_realloc=Module[\"_sqlite3_realloc\"]=wasmExports[\"Ia\"];_sqlite3_realloc64=Module[\"_sqlite3_realloc64\"]=wasmExports[\"Ja\"];_sqlite3_str_vappendf=Module[\"_sqlite3_str_vappendf\"]=wasmExports[\"Ka\"];_sqlite3_str_append=Module[\"_sqlite3_str_append\"]=wasmExports[\"La\"];_sqlite3_str_appendchar=Module[\"_sqlite3_str_appendchar\"]=wasmExports[\"Ma\"];_sqlite3_str_appendall=Module[\"_sqlite3_str_appendall\"]=wasmExports[\"Na\"];_sqlite3_str_appendf=Module[\"_sqlite3_str_appendf\"]=wasmExports[\"Oa\"];_sqlite3_str_finish=Module[\"_sqlite3_str_finish\"]=wasmExports[\"Pa\"];_sqlite3_str_errcode=Module[\"_sqlite3_str_errcode\"]=wasmExports[\"Qa\"];_sqlite3_str_length=Module[\"_sqlite3_str_length\"]=wasmExports[\"Ra\"];_sqlite3_str_value=Module[\"_sqlite3_str_value\"]=wasmExports[\"Sa\"];_sqlite3_str_reset=Module[\"_sqlite3_str_reset\"]=wasmExports[\"Ta\"];_sqlite3_str_new=Module[\"_sqlite3_str_new\"]=wasmExports[\"Ua\"];_sqlite3_vmprintf=Module[\"_sqlite3_vmprintf\"]=wasmExports[\"Va\"];_sqlite3_mprintf=Module[\"_sqlite3_mprintf\"]=wasmExports[\"Wa\"];_sqlite3_vsnprintf=Module[\"_sqlite3_vsnprintf\"]=wasmExports[\"Xa\"];_sqlite3_snprintf=Module[\"_sqlite3_snprintf\"]=wasmExports[\"Ya\"];_sqlite3_log=Module[\"_sqlite3_log\"]=wasmExports[\"Za\"];_sqlite3_randomness=Module[\"_sqlite3_randomness\"]=wasmExports[\"_a\"];_sqlite3_stricmp=Module[\"_sqlite3_stricmp\"]=wasmExports[\"$a\"];_sqlite3_strnicmp=Module[\"_sqlite3_strnicmp\"]=wasmExports[\"ab\"];_sqlite3_os_init=Module[\"_sqlite3_os_init\"]=wasmExports[\"bb\"];_sqlite3_os_end=Module[\"_sqlite3_os_end\"]=wasmExports[\"cb\"];_sqlite3_serialize=Module[\"_sqlite3_serialize\"]=wasmExports[\"db\"];_sqlite3_prepare_v2=Module[\"_sqlite3_prepare_v2\"]=wasmExports[\"eb\"];_sqlite3_step=Module[\"_sqlite3_step\"]=wasmExports[\"fb\"];_sqlite3_column_int64=Module[\"_sqlite3_column_int64\"]=wasmExports[\"gb\"];_sqlite3_reset=Module[\"_sqlite3_reset\"]=wasmExports[\"hb\"];_sqlite3_exec=Module[\"_sqlite3_exec\"]=wasmExports[\"ib\"];_sqlite3_column_int=Module[\"_sqlite3_column_int\"]=wasmExports[\"jb\"];_sqlite3_finalize=Module[\"_sqlite3_finalize\"]=wasmExports[\"kb\"];_sqlite3_deserialize=Module[\"_sqlite3_deserialize\"]=wasmExports[\"lb\"];_sqlite3_database_file_object=Module[\"_sqlite3_database_file_object\"]=wasmExports[\"mb\"];_sqlite3_backup_init=Module[\"_sqlite3_backup_init\"]=wasmExports[\"nb\"];_sqlite3_backup_step=Module[\"_sqlite3_backup_step\"]=wasmExports[\"ob\"];_sqlite3_backup_finish=Module[\"_sqlite3_backup_finish\"]=wasmExports[\"pb\"];_sqlite3_backup_remaining=Module[\"_sqlite3_backup_remaining\"]=wasmExports[\"qb\"];_sqlite3_backup_pagecount=Module[\"_sqlite3_backup_pagecount\"]=wasmExports[\"rb\"];_sqlite3_clear_bindings=Module[\"_sqlite3_clear_bindings\"]=wasmExports[\"sb\"];_sqlite3_value_blob=Module[\"_sqlite3_value_blob\"]=wasmExports[\"tb\"];_sqlite3_value_text=Module[\"_sqlite3_value_text\"]=wasmExports[\"ub\"];_sqlite3_value_bytes=Module[\"_sqlite3_value_bytes\"]=wasmExports[\"vb\"];_sqlite3_value_bytes16=Module[\"_sqlite3_value_bytes16\"]=wasmExports[\"wb\"];_sqlite3_value_double=Module[\"_sqlite3_value_double\"]=wasmExports[\"xb\"];_sqlite3_value_int=Module[\"_sqlite3_value_int\"]=wasmExports[\"yb\"];_sqlite3_value_int64=Module[\"_sqlite3_value_int64\"]=wasmExports[\"zb\"];_sqlite3_value_subtype=Module[\"_sqlite3_value_subtype\"]=wasmExports[\"Ab\"];_sqlite3_value_pointer=Module[\"_sqlite3_value_pointer\"]=wasmExports[\"Bb\"];_sqlite3_value_text16=Module[\"_sqlite3_value_text16\"]=wasmExports[\"Cb\"];_sqlite3_value_text16be=Module[\"_sqlite3_value_text16be\"]=wasmExports[\"Db\"];_sqlite3_value_text16le=Module[\"_sqlite3_value_text16le\"]=wasmExports[\"Eb\"];_sqlite3_value_type=Module[\"_sqlite3_value_type\"]=wasmExports[\"Fb\"];_sqlite3_value_encoding=Module[\"_sqlite3_value_encoding\"]=wasmExports[\"Gb\"];_sqlite3_value_nochange=Module[\"_sqlite3_value_nochange\"]=wasmExports[\"Hb\"];_sqlite3_value_frombind=Module[\"_sqlite3_value_frombind\"]=wasmExports[\"Ib\"];_sqlite3_value_dup=Module[\"_sqlite3_value_dup\"]=wasmExports[\"Jb\"];_sqlite3_value_free=Module[\"_sqlite3_value_free\"]=wasmExports[\"Kb\"];_sqlite3_result_blob=Module[\"_sqlite3_result_blob\"]=wasmExports[\"Lb\"];_sqlite3_result_blob64=Module[\"_sqlite3_result_blob64\"]=wasmExports[\"Mb\"];_sqlite3_result_double=Module[\"_sqlite3_result_double\"]=wasmExports[\"Nb\"];_sqlite3_result_error=Module[\"_sqlite3_result_error\"]=wasmExports[\"Ob\"];_sqlite3_result_error16=Module[\"_sqlite3_result_error16\"]=wasmExports[\"Pb\"];_sqlite3_result_int=Module[\"_sqlite3_result_int\"]=wasmExports[\"Qb\"];_sqlite3_result_int64=Module[\"_sqlite3_result_int64\"]=wasmExports[\"Rb\"];_sqlite3_result_null=Module[\"_sqlite3_result_null\"]=wasmExports[\"Sb\"];_sqlite3_result_pointer=Module[\"_sqlite3_result_pointer\"]=wasmExports[\"Tb\"];_sqlite3_result_subtype=Module[\"_sqlite3_result_subtype\"]=wasmExports[\"Ub\"];_sqlite3_result_text=Module[\"_sqlite3_result_text\"]=wasmExports[\"Vb\"];_sqlite3_result_text64=Module[\"_sqlite3_result_text64\"]=wasmExports[\"Wb\"];_sqlite3_result_text16=Module[\"_sqlite3_result_text16\"]=wasmExports[\"Xb\"];_sqlite3_result_text16be=Module[\"_sqlite3_result_text16be\"]=wasmExports[\"Yb\"];_sqlite3_result_text16le=Module[\"_sqlite3_result_text16le\"]=wasmExports[\"Zb\"];_sqlite3_result_value=Module[\"_sqlite3_result_value\"]=wasmExports[\"_b\"];_sqlite3_result_error_toobig=Module[\"_sqlite3_result_error_toobig\"]=wasmExports[\"$b\"];_sqlite3_result_zeroblob=Module[\"_sqlite3_result_zeroblob\"]=wasmExports[\"ac\"];_sqlite3_result_zeroblob64=Module[\"_sqlite3_result_zeroblob64\"]=wasmExports[\"bc\"];_sqlite3_result_error_code=Module[\"_sqlite3_result_error_code\"]=wasmExports[\"cc\"];_sqlite3_result_error_nomem=Module[\"_sqlite3_result_error_nomem\"]=wasmExports[\"dc\"];_sqlite3_user_data=Module[\"_sqlite3_user_data\"]=wasmExports[\"ec\"];_sqlite3_context_db_handle=Module[\"_sqlite3_context_db_handle\"]=wasmExports[\"fc\"];_sqlite3_vtab_nochange=Module[\"_sqlite3_vtab_nochange\"]=wasmExports[\"gc\"];_sqlite3_vtab_in_first=Module[\"_sqlite3_vtab_in_first\"]=wasmExports[\"hc\"];_sqlite3_vtab_in_next=Module[\"_sqlite3_vtab_in_next\"]=wasmExports[\"ic\"];_sqlite3_aggregate_context=Module[\"_sqlite3_aggregate_context\"]=wasmExports[\"jc\"];_sqlite3_get_auxdata=Module[\"_sqlite3_get_auxdata\"]=wasmExports[\"kc\"];_sqlite3_set_auxdata=Module[\"_sqlite3_set_auxdata\"]=wasmExports[\"lc\"];_sqlite3_column_count=Module[\"_sqlite3_column_count\"]=wasmExports[\"mc\"];_sqlite3_data_count=Module[\"_sqlite3_data_count\"]=wasmExports[\"nc\"];_sqlite3_column_blob=Module[\"_sqlite3_column_blob\"]=wasmExports[\"oc\"];_sqlite3_column_bytes=Module[\"_sqlite3_column_bytes\"]=wasmExports[\"pc\"];_sqlite3_column_bytes16=Module[\"_sqlite3_column_bytes16\"]=wasmExports[\"qc\"];_sqlite3_column_double=Module[\"_sqlite3_column_double\"]=wasmExports[\"rc\"];_sqlite3_column_text=Module[\"_sqlite3_column_text\"]=wasmExports[\"sc\"];_sqlite3_column_value=Module[\"_sqlite3_column_value\"]=wasmExports[\"tc\"];_sqlite3_column_text16=Module[\"_sqlite3_column_text16\"]=wasmExports[\"uc\"];_sqlite3_column_type=Module[\"_sqlite3_column_type\"]=wasmExports[\"vc\"];_sqlite3_column_name=Module[\"_sqlite3_column_name\"]=wasmExports[\"wc\"];_sqlite3_column_name16=Module[\"_sqlite3_column_name16\"]=wasmExports[\"xc\"];_sqlite3_bind_blob=Module[\"_sqlite3_bind_blob\"]=wasmExports[\"yc\"];_sqlite3_bind_blob64=Module[\"_sqlite3_bind_blob64\"]=wasmExports[\"zc\"];_sqlite3_bind_double=Module[\"_sqlite3_bind_double\"]=wasmExports[\"Ac\"];_sqlite3_bind_int=Module[\"_sqlite3_bind_int\"]=wasmExports[\"Bc\"];_sqlite3_bind_int64=Module[\"_sqlite3_bind_int64\"]=wasmExports[\"Cc\"];_sqlite3_bind_null=Module[\"_sqlite3_bind_null\"]=wasmExports[\"Dc\"];_sqlite3_bind_pointer=Module[\"_sqlite3_bind_pointer\"]=wasmExports[\"Ec\"];_sqlite3_bind_text=Module[\"_sqlite3_bind_text\"]=wasmExports[\"Fc\"];_sqlite3_bind_text64=Module[\"_sqlite3_bind_text64\"]=wasmExports[\"Gc\"];_sqlite3_bind_text16=Module[\"_sqlite3_bind_text16\"]=wasmExports[\"Hc\"];_sqlite3_bind_value=Module[\"_sqlite3_bind_value\"]=wasmExports[\"Ic\"];_sqlite3_bind_zeroblob=Module[\"_sqlite3_bind_zeroblob\"]=wasmExports[\"Jc\"];_sqlite3_bind_zeroblob64=Module[\"_sqlite3_bind_zeroblob64\"]=wasmExports[\"Kc\"];_sqlite3_bind_parameter_count=Module[\"_sqlite3_bind_parameter_count\"]=wasmExports[\"Lc\"];_sqlite3_bind_parameter_name=Module[\"_sqlite3_bind_parameter_name\"]=wasmExports[\"Mc\"];_sqlite3_bind_parameter_index=Module[\"_sqlite3_bind_parameter_index\"]=wasmExports[\"Nc\"];_sqlite3_db_handle=Module[\"_sqlite3_db_handle\"]=wasmExports[\"Oc\"];_sqlite3_stmt_readonly=Module[\"_sqlite3_stmt_readonly\"]=wasmExports[\"Pc\"];_sqlite3_stmt_isexplain=Module[\"_sqlite3_stmt_isexplain\"]=wasmExports[\"Qc\"];_sqlite3_stmt_explain=Module[\"_sqlite3_stmt_explain\"]=wasmExports[\"Rc\"];_sqlite3_stmt_busy=Module[\"_sqlite3_stmt_busy\"]=wasmExports[\"Sc\"];_sqlite3_next_stmt=Module[\"_sqlite3_next_stmt\"]=wasmExports[\"Tc\"];_sqlite3_stmt_status=Module[\"_sqlite3_stmt_status\"]=wasmExports[\"Uc\"];_sqlite3_sql=Module[\"_sqlite3_sql\"]=wasmExports[\"Vc\"];_sqlite3_expanded_sql=Module[\"_sqlite3_expanded_sql\"]=wasmExports[\"Wc\"];_sqlite3_value_numeric_type=Module[\"_sqlite3_value_numeric_type\"]=wasmExports[\"Xc\"];_sqlite3_blob_open=Module[\"_sqlite3_blob_open\"]=wasmExports[\"Yc\"];_sqlite3_blob_close=Module[\"_sqlite3_blob_close\"]=wasmExports[\"Zc\"];_sqlite3_blob_read=Module[\"_sqlite3_blob_read\"]=wasmExports[\"_c\"];_sqlite3_blob_write=Module[\"_sqlite3_blob_write\"]=wasmExports[\"$c\"];_sqlite3_blob_bytes=Module[\"_sqlite3_blob_bytes\"]=wasmExports[\"ad\"];_sqlite3_blob_reopen=Module[\"_sqlite3_blob_reopen\"]=wasmExports[\"bd\"];_sqlite3_set_authorizer=Module[\"_sqlite3_set_authorizer\"]=wasmExports[\"cd\"];_sqlite3_strglob=Module[\"_sqlite3_strglob\"]=wasmExports[\"dd\"];_sqlite3_strlike=Module[\"_sqlite3_strlike\"]=wasmExports[\"ed\"];_sqlite3_errmsg=Module[\"_sqlite3_errmsg\"]=wasmExports[\"fd\"];_sqlite3_load_extension=Module[\"_sqlite3_load_extension\"]=wasmExports[\"gd\"];_sqlite3_enable_load_extension=Module[\"_sqlite3_enable_load_extension\"]=wasmExports[\"hd\"];_sqlite3_auto_extension=Module[\"_sqlite3_auto_extension\"]=wasmExports[\"id\"];_sqlite3_cancel_auto_extension=Module[\"_sqlite3_cancel_auto_extension\"]=wasmExports[\"jd\"];_sqlite3_reset_auto_extension=Module[\"_sqlite3_reset_auto_extension\"]=wasmExports[\"kd\"];_sqlite3_prepare=Module[\"_sqlite3_prepare\"]=wasmExports[\"ld\"];_sqlite3_prepare_v3=Module[\"_sqlite3_prepare_v3\"]=wasmExports[\"md\"];_sqlite3_prepare16=Module[\"_sqlite3_prepare16\"]=wasmExports[\"nd\"];_sqlite3_prepare16_v2=Module[\"_sqlite3_prepare16_v2\"]=wasmExports[\"od\"];_sqlite3_prepare16_v3=Module[\"_sqlite3_prepare16_v3\"]=wasmExports[\"pd\"];_sqlite3_get_table=Module[\"_sqlite3_get_table\"]=wasmExports[\"qd\"];_sqlite3_free_table=Module[\"_sqlite3_free_table\"]=wasmExports[\"rd\"];_sqlite3_create_module=Module[\"_sqlite3_create_module\"]=wasmExports[\"sd\"];_sqlite3_create_module_v2=Module[\"_sqlite3_create_module_v2\"]=wasmExports[\"td\"];_sqlite3_drop_modules=Module[\"_sqlite3_drop_modules\"]=wasmExports[\"ud\"];_sqlite3_declare_vtab=Module[\"_sqlite3_declare_vtab\"]=wasmExports[\"vd\"];_sqlite3_vtab_on_conflict=Module[\"_sqlite3_vtab_on_conflict\"]=wasmExports[\"wd\"];_sqlite3_vtab_config=Module[\"_sqlite3_vtab_config\"]=wasmExports[\"xd\"];_sqlite3_vtab_collation=Module[\"_sqlite3_vtab_collation\"]=wasmExports[\"yd\"];_sqlite3_vtab_in=Module[\"_sqlite3_vtab_in\"]=wasmExports[\"zd\"];_sqlite3_vtab_rhs_value=Module[\"_sqlite3_vtab_rhs_value\"]=wasmExports[\"Ad\"];_sqlite3_vtab_distinct=Module[\"_sqlite3_vtab_distinct\"]=wasmExports[\"Bd\"];_sqlite3_keyword_name=Module[\"_sqlite3_keyword_name\"]=wasmExports[\"Cd\"];_sqlite3_keyword_count=Module[\"_sqlite3_keyword_count\"]=wasmExports[\"Dd\"];_sqlite3_keyword_check=Module[\"_sqlite3_keyword_check\"]=wasmExports[\"Ed\"];_sqlite3_complete=Module[\"_sqlite3_complete\"]=wasmExports[\"Fd\"];_sqlite3_complete16=Module[\"_sqlite3_complete16\"]=wasmExports[\"Gd\"];_sqlite3_libversion=Module[\"_sqlite3_libversion\"]=wasmExports[\"Hd\"];_sqlite3_libversion_number=Module[\"_sqlite3_libversion_number\"]=wasmExports[\"Id\"];_sqlite3_threadsafe=Module[\"_sqlite3_threadsafe\"]=wasmExports[\"Jd\"];_sqlite3_initialize=Module[\"_sqlite3_initialize\"]=wasmExports[\"Kd\"];_sqlite3_shutdown=Module[\"_sqlite3_shutdown\"]=wasmExports[\"Ld\"];_sqlite3_config=Module[\"_sqlite3_config\"]=wasmExports[\"Md\"];_sqlite3_db_mutex=Module[\"_sqlite3_db_mutex\"]=wasmExports[\"Nd\"];_sqlite3_db_release_memory=Module[\"_sqlite3_db_release_memory\"]=wasmExports[\"Od\"];_sqlite3_db_cacheflush=Module[\"_sqlite3_db_cacheflush\"]=wasmExports[\"Pd\"];_sqlite3_db_config=Module[\"_sqlite3_db_config\"]=wasmExports[\"Qd\"];_sqlite3_last_insert_rowid=Module[\"_sqlite3_last_insert_rowid\"]=wasmExports[\"Rd\"];_sqlite3_set_last_insert_rowid=Module[\"_sqlite3_set_last_insert_rowid\"]=wasmExports[\"Sd\"];_sqlite3_changes64=Module[\"_sqlite3_changes64\"]=wasmExports[\"Td\"];_sqlite3_changes=Module[\"_sqlite3_changes\"]=wasmExports[\"Ud\"];_sqlite3_total_changes64=Module[\"_sqlite3_total_changes64\"]=wasmExports[\"Vd\"];_sqlite3_total_changes=Module[\"_sqlite3_total_changes\"]=wasmExports[\"Wd\"];_sqlite3_txn_state=Module[\"_sqlite3_txn_state\"]=wasmExports[\"Xd\"];_sqlite3_close=Module[\"_sqlite3_close\"]=wasmExports[\"Yd\"];_sqlite3_close_v2=Module[\"_sqlite3_close_v2\"]=wasmExports[\"Zd\"];_sqlite3_busy_handler=Module[\"_sqlite3_busy_handler\"]=wasmExports[\"_d\"];_sqlite3_progress_handler=Module[\"_sqlite3_progress_handler\"]=wasmExports[\"$d\"];_sqlite3_busy_timeout=Module[\"_sqlite3_busy_timeout\"]=wasmExports[\"ae\"];_sqlite3_interrupt=Module[\"_sqlite3_interrupt\"]=wasmExports[\"be\"];_sqlite3_is_interrupted=Module[\"_sqlite3_is_interrupted\"]=wasmExports[\"ce\"];_sqlite3_create_function=Module[\"_sqlite3_create_function\"]=wasmExports[\"de\"];_sqlite3_create_function_v2=Module[\"_sqlite3_create_function_v2\"]=wasmExports[\"ee\"];_sqlite3_create_window_function=Module[\"_sqlite3_create_window_function\"]=wasmExports[\"fe\"];_sqlite3_create_function16=Module[\"_sqlite3_create_function16\"]=wasmExports[\"ge\"];_sqlite3_overload_function=Module[\"_sqlite3_overload_function\"]=wasmExports[\"he\"];_sqlite3_trace_v2=Module[\"_sqlite3_trace_v2\"]=wasmExports[\"ie\"];_sqlite3_commit_hook=Module[\"_sqlite3_commit_hook\"]=wasmExports[\"je\"];_sqlite3_update_hook=Module[\"_sqlite3_update_hook\"]=wasmExports[\"ke\"];_sqlite3_rollback_hook=Module[\"_sqlite3_rollback_hook\"]=wasmExports[\"le\"];_sqlite3_autovacuum_pages=Module[\"_sqlite3_autovacuum_pages\"]=wasmExports[\"me\"];_sqlite3_wal_autocheckpoint=Module[\"_sqlite3_wal_autocheckpoint\"]=wasmExports[\"ne\"];_sqlite3_wal_hook=Module[\"_sqlite3_wal_hook\"]=wasmExports[\"oe\"];_sqlite3_wal_checkpoint_v2=Module[\"_sqlite3_wal_checkpoint_v2\"]=wasmExports[\"pe\"];_sqlite3_wal_checkpoint=Module[\"_sqlite3_wal_checkpoint\"]=wasmExports[\"qe\"];_sqlite3_error_offset=Module[\"_sqlite3_error_offset\"]=wasmExports[\"re\"];_sqlite3_errmsg16=Module[\"_sqlite3_errmsg16\"]=wasmExports[\"se\"];_sqlite3_errcode=Module[\"_sqlite3_errcode\"]=wasmExports[\"te\"];_sqlite3_extended_errcode=Module[\"_sqlite3_extended_errcode\"]=wasmExports[\"ue\"];_sqlite3_system_errno=Module[\"_sqlite3_system_errno\"]=wasmExports[\"ve\"];_sqlite3_errstr=Module[\"_sqlite3_errstr\"]=wasmExports[\"we\"];_sqlite3_limit=Module[\"_sqlite3_limit\"]=wasmExports[\"xe\"];_sqlite3_open=Module[\"_sqlite3_open\"]=wasmExports[\"ye\"];_sqlite3_open_v2=Module[\"_sqlite3_open_v2\"]=wasmExports[\"ze\"];_sqlite3_open16=Module[\"_sqlite3_open16\"]=wasmExports[\"Ae\"];_sqlite3_create_collation=Module[\"_sqlite3_create_collation\"]=wasmExports[\"Be\"];_sqlite3_create_collation_v2=Module[\"_sqlite3_create_collation_v2\"]=wasmExports[\"Ce\"];_sqlite3_create_collation16=Module[\"_sqlite3_create_collation16\"]=wasmExports[\"De\"];_sqlite3_collation_needed=Module[\"_sqlite3_collation_needed\"]=wasmExports[\"Ee\"];_sqlite3_collation_needed16=Module[\"_sqlite3_collation_needed16\"]=wasmExports[\"Fe\"];_sqlite3_get_clientdata=Module[\"_sqlite3_get_clientdata\"]=wasmExports[\"Ge\"];_sqlite3_set_clientdata=Module[\"_sqlite3_set_clientdata\"]=wasmExports[\"He\"];_sqlite3_get_autocommit=Module[\"_sqlite3_get_autocommit\"]=wasmExports[\"Ie\"];_sqlite3_table_column_metadata=Module[\"_sqlite3_table_column_metadata\"]=wasmExports[\"Je\"];_sqlite3_sleep=Module[\"_sqlite3_sleep\"]=wasmExports[\"Ke\"];_sqlite3_extended_result_codes=Module[\"_sqlite3_extended_result_codes\"]=wasmExports[\"Le\"];_sqlite3_file_control=Module[\"_sqlite3_file_control\"]=wasmExports[\"Me\"];_sqlite3_test_control=Module[\"_sqlite3_test_control\"]=wasmExports[\"Ne\"];_sqlite3_create_filename=Module[\"_sqlite3_create_filename\"]=wasmExports[\"Oe\"];_sqlite3_free_filename=Module[\"_sqlite3_free_filename\"]=wasmExports[\"Pe\"];_sqlite3_uri_parameter=Module[\"_sqlite3_uri_parameter\"]=wasmExports[\"Qe\"];_sqlite3_uri_key=Module[\"_sqlite3_uri_key\"]=wasmExports[\"Re\"];_sqlite3_uri_boolean=Module[\"_sqlite3_uri_boolean\"]=wasmExports[\"Se\"];_sqlite3_uri_int64=Module[\"_sqlite3_uri_int64\"]=wasmExports[\"Te\"];_sqlite3_filename_database=Module[\"_sqlite3_filename_database\"]=wasmExports[\"Ue\"];_sqlite3_filename_journal=Module[\"_sqlite3_filename_journal\"]=wasmExports[\"Ve\"];_sqlite3_filename_wal=Module[\"_sqlite3_filename_wal\"]=wasmExports[\"We\"];_sqlite3_db_name=Module[\"_sqlite3_db_name\"]=wasmExports[\"Xe\"];_sqlite3_db_filename=Module[\"_sqlite3_db_filename\"]=wasmExports[\"Ye\"];_sqlite3_db_readonly=Module[\"_sqlite3_db_readonly\"]=wasmExports[\"Ze\"];_sqlite3_compileoption_used=Module[\"_sqlite3_compileoption_used\"]=wasmExports[\"_e\"];_sqlite3_compileoption_get=Module[\"_sqlite3_compileoption_get\"]=wasmExports[\"$e\"];_sqlite3_sourceid=Module[\"_sqlite3_sourceid\"]=wasmExports[\"af\"];_sqlite3mc_config=Module[\"_sqlite3mc_config\"]=wasmExports[\"bf\"];_sqlite3mc_cipher_count=Module[\"_sqlite3mc_cipher_count\"]=wasmExports[\"cf\"];_sqlite3mc_cipher_index=Module[\"_sqlite3mc_cipher_index\"]=wasmExports[\"df\"];_sqlite3mc_cipher_name=Module[\"_sqlite3mc_cipher_name\"]=wasmExports[\"ef\"];_sqlite3mc_config_cipher=Module[\"_sqlite3mc_config_cipher\"]=wasmExports[\"ff\"];_sqlite3mc_vfs_create=Module[\"_sqlite3mc_vfs_create\"]=wasmExports[\"gf\"];_memcmp=Module[\"_memcmp\"]=wasmExports[\"hf\"];_malloc=Module[\"_malloc\"]=wasmExports[\"jf\"];_free=Module[\"_free\"]=wasmExports[\"kf\"];_memset=Module[\"_memset\"]=wasmExports[\"lf\"];_RegisterExtensionFunctions=Module[\"_RegisterExtensionFunctions\"]=wasmExports[\"nf\"];_getSqliteFree=Module[\"_getSqliteFree\"]=wasmExports[\"of\"];_main=Module[\"_main\"]=wasmExports[\"pf\"];_libauthorizer_set_authorizer=Module[\"_libauthorizer_set_authorizer\"]=wasmExports[\"qf\"];_libfunction_create_function=Module[\"_libfunction_create_function\"]=wasmExports[\"rf\"];_libhook_commit_hook=Module[\"_libhook_commit_hook\"]=wasmExports[\"sf\"];_libhook_update_hook=Module[\"_libhook_update_hook\"]=wasmExports[\"tf\"];_libprogress_progress_handler=Module[\"_libprogress_progress_handler\"]=wasmExports[\"uf\"];_libvfs_vfs_register=Module[\"_libvfs_vfs_register\"]=wasmExports[\"vf\"];_memcpy=Module[\"_memcpy\"]=wasmExports[\"wf\"];_emscripten_builtin_memalign=wasmExports[\"yf\"];__emscripten_timeout=wasmExports[\"zf\"];__emscripten_tempret_get=wasmExports[\"Af\"];__emscripten_stack_restore=wasmExports[\"Bf\"];__emscripten_stack_alloc=wasmExports[\"Cf\"];_emscripten_stack_get_current=wasmExports[\"Df\"];dynCall_viiiij=wasmExports[\"dynCall_viiiij\"];dynCall_vijii=wasmExports[\"dynCall_vijii\"];dynCall_iiiij=wasmExports[\"dynCall_iiiij\"];dynCall_viji=wasmExports[\"dynCall_viji\"];dynCall_iij=wasmExports[\"dynCall_iij\"];dynCall_iijii=wasmExports[\"dynCall_iijii\"];dynCall_iiji=wasmExports[\"dynCall_iiji\"];dynCall_iiiiiij=wasmExports[\"dynCall_iiiiiij\"];dynCall_iiij=wasmExports[\"dynCall_iiij\"];dynCall_jii=wasmExports[\"dynCall_jii\"];dynCall_ji=wasmExports[\"dynCall_ji\"];dynCall_vij=wasmExports[\"dynCall_vij\"];dynCall_iiiiijii=wasmExports[\"dynCall_iiiiijii\"];dynCall_j=wasmExports[\"dynCall_j\"];dynCall_jj=wasmExports[\"dynCall_jj\"];dynCall_jiij=wasmExports[\"dynCall_jiij\"];dynCall_iiiiji=wasmExports[\"dynCall_iiiiji\"];dynCall_iiiijii=wasmExports[\"dynCall_iiiijii\"];dynCall_ij=wasmExports[\"dynCall_ij\"];dynCall_viiji=wasmExports[\"dynCall_viiji\"];dynCall_viijii=wasmExports[\"dynCall_viijii\"];dynCall_iiiijji=wasmExports[\"dynCall_iiiijji\"];memory=wasmMemory=wasmExports[\"qa\"];_sqlite3_version=Module[\"_sqlite3_version\"]=wasmExports[\"mf\"].value;__indirect_function_table=wasmTable=wasmExports[\"xf\"]}var wasmImports={a:___assert_fail,aa:___syscall_chmod,ca:___syscall_faccessat,ba:___syscall_fchmod,$:___syscall_fchown32,b:___syscall_fcntl64,_:___syscall_fstat64,y:___syscall_ftruncate64,U:___syscall_getcwd,Y:___syscall_lstat64,Q:___syscall_mkdirat,W:___syscall_newfstatat,O:___syscall_openat,M:___syscall_readlinkat,L:___syscall_rmdir,Z:___syscall_stat64,J:___syscall_unlinkat,I:___syscall_utimensat,ea:__abort_js,E:__emscripten_runtime_keepalive_clear,w:__localtime_js,u:__mmap_js,v:__munmap_js,F:__setitimer_js,P:__tzset_js,n:_emscripten_date_now,g:_emscripten_get_now,G:_emscripten_resize_heap,R:_environ_get,S:_environ_sizes_get,o:_fd_close,H:_fd_fdstat_get,N:_fd_read,x:_fd_seek,V:_fd_sync,K:_fd_write,s:_ipp,t:_ipp_async,la:_ippipppp,pa:_ippipppp_async,j:_ippp,k:_ippp_async,c:_ipppi,d:_ipppi_async,ha:_ipppiii,ia:_ipppiii_async,ja:_ipppiiip,ka:_ipppiiip_async,h:_ipppip,i:_ipppip_async,z:_ipppj,A:_ipppj_async,e:_ipppp,f:_ipppp_async,fa:_ippppi,ga:_ippppi_async,B:_ippppij,C:_ippppij_async,p:_ippppip,q:_ippppip_async,ma:_ipppppip,na:_ipppppip_async,D:_proc_exit,T:_random_get,oa:_vppippii,r:_vppippii_async,l:_vppp,m:_vppp_async,X:_vpppip,da:_vpppip_async};function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){dependenciesFulfilled=run;return}preRun();if(runDependencies>0){dependenciesFulfilled=run;return}function doRun(){Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve?.(Module);Module[\"onRuntimeInitialized\"]?.();var noInitialRun=Module[\"noInitialRun\"]||false;if(!noInitialRun)callMain();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(()=>{setTimeout(()=>Module[\"setStatus\"](\"\"),1);doRun()},1)}else{doRun()}}var wasmExports;wasmExports=await (createWasm());run();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"set_authorizer\"]=function(db,xAuthorizer,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xAuthorizer instanceof AsyncFunction?1:0,\"i32\");const result=ccall(\"libauthorizer_set_authorizer\",\"number\",[\"number\",\"number\",\"number\"],[db,xAuthorizer?1:0,pAsyncFlags]);if(!result&&xAuthorizer){Module[\"setCallback\"](pAsyncFlags,(_,iAction,p3,p4,p5,p6)=>xAuthorizer(pApp,iAction,p3,p4,p5,p6))}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;const FUNC_METHODS=[\"xFunc\",\"xStep\",\"xFinal\"];const mapFunctionNameToKey=new Map;Module[\"create_function\"]=function(db,zFunctionName,nArg,eTextRep,pApp,xFunc,xStep,xFinal){const pAsyncFlags=Module[\"_sqlite3_malloc\"](4);const target={xFunc,xStep,xFinal};setValue(pAsyncFlags,FUNC_METHODS.reduce((mask,method,i)=>{if(target[method]instanceof AsyncFunction){return mask|1<<i}return mask},0),\"i32\");const result=ccall(\"libfunction_create_function\",\"number\",[\"number\",\"string\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"],[db,zFunctionName,nArg,eTextRep,pAsyncFlags,xFunc?1:0,xStep?1:0,xFinal?1:0]);if(!result){if(mapFunctionNameToKey.has(zFunctionName)){const oldKey=mapFunctionNameToKey.get(zFunctionName);Module[\"deleteCallback\"](oldKey)}mapFunctionNameToKey.set(zFunctionName,pAsyncFlags);Module[\"setCallback\"](pAsyncFlags,{xFunc,xStep,xFinal})}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"update_hook\"]=function(db,xUpdateHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xUpdateHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_update_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xUpdateHook?1:0,pAsyncFlags]);if(xUpdateHook){Module[\"setCallback\"](pAsyncFlags,(_,iUpdateType,dbName,tblName,lo32,hi32)=>xUpdateHook(iUpdateType,dbName,tblName,lo32,hi32))}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"commit_hook\"]=function(db,xCommitHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xCommitHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_commit_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xCommitHook?1:0,pAsyncFlags]);if(xCommitHook){Module[\"setCallback\"](pAsyncFlags,_=>xCommitHook())}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"progress_handler\"]=function(db,nOps,xProgress,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xProgress instanceof AsyncFunction?1:0,\"i32\");ccall(\"libprogress_progress_handler\",\"number\",[\"number\",\"number\",\"number\",\"number\"],[db,nOps,xProgress?1:0,pAsyncFlags]);if(xProgress){Module[\"setCallback\"](pAsyncFlags,_=>xProgress(pApp))}}})();(function(){const VFS_METHODS=[\"xOpen\",\"xDelete\",\"xAccess\",\"xFullPathname\",\"xRandomness\",\"xSleep\",\"xCurrentTime\",\"xGetLastError\",\"xCurrentTimeInt64\",\"xClose\",\"xRead\",\"xWrite\",\"xTruncate\",\"xSync\",\"xFileSize\",\"xLock\",\"xUnlock\",\"xCheckReservedLock\",\"xFileControl\",\"xSectorSize\",\"xDeviceCharacteristics\",\"xShmMap\",\"xShmLock\",\"xShmBarrier\",\"xShmUnmap\"];const mapVFSNameToKey=new Map;Module[\"vfs_register\"]=function(vfs,makeDefault){let methodMask=0;let asyncMask=0;VFS_METHODS.forEach((method,i)=>{if(vfs[method]){methodMask|=1<<i;if(vfs[\"hasAsyncMethod\"](method)){asyncMask|=1<<i}}});const vfsReturn=Module[\"_sqlite3_malloc\"](4);try{const result=ccall(\"libvfs_vfs_register\",\"number\",[\"string\",\"number\",\"number\",\"number\",\"number\",\"number\"],[vfs.name,vfs.mxPathname,methodMask,asyncMask,makeDefault?1:0,vfsReturn]);if(!result){if(mapVFSNameToKey.has(vfs.name)){const oldKey=mapVFSNameToKey.get(vfs.name);Module[\"deleteCallback\"](oldKey)}const key=getValue(vfsReturn,\"*\");mapVFSNameToKey.set(vfs.name,key);Module[\"setCallback\"](key,vfs)}return result}finally{Module[\"_sqlite3_free\"](vfsReturn)}}})();if(runtimeInitialized){moduleRtn=Module}else{moduleRtn=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject})}\n;return moduleRtn}export default Module;\n","async function Module(moduleArg={}){var moduleRtn;var Module=moduleArg;var ENVIRONMENT_IS_WEB=!!globalThis.window;var ENVIRONMENT_IS_WORKER=!!globalThis.WorkerGlobalScope;var ENVIRONMENT_IS_NODE=globalThis.process?.versions?.node&&globalThis.process?.type!=\"renderer\";var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var _scriptName=import.meta.url;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){try{scriptDirectory=new URL(\".\",_scriptName).href}catch{}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=async url=>{var response=await fetch(url,{credentials:\"same-origin\"});if(response.ok){return response.arrayBuffer()}throw new Error(response.status+\" : \"+response.url)}}}else{}var out=console.log.bind(console);var err=console.error.bind(console);var wasmBinary;var ABORT=false;var EXITSTATUS;var readyPromiseResolve,readyPromiseReject;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var runtimeInitialized=false;function updateMemoryViews(){var b=wasmMemory.buffer;HEAP8=new Int8Array(b);HEAP16=new Int16Array(b);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(b);HEAPU16=new Uint16Array(b);Module[\"HEAP32\"]=HEAP32=new Int32Array(b);HEAPU32=new Uint32Array(b);HEAPF32=new Float32Array(b);HEAPF64=new Float64Array(b)}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(onPreRuns)}function initRuntime(){runtimeInitialized=true;if(!Module[\"noFSInit\"]&&!FS.initialized)FS.init();TTY.init();wasmExports[\"qa\"]();FS.ignorePermissions=false}function preMain(){}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(onPostRuns)}function abort(what){Module[\"onAbort\"]?.(what);what=\"Aborted(\"+what+\")\";err(what);ABORT=true;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject?.(e);throw e}var wasmBinaryFile;function findWasmBinary(){if(Module[\"locateFile\"]){return locateFile(\"wa-sqlite-async.wasm\")}return new URL(\"wa-sqlite-async.wasm\",import.meta.url).href}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}async function getWasmBinary(binaryFile){if(!wasmBinary){try{var response=await readAsync(binaryFile);return new Uint8Array(response)}catch{}}return getBinarySync(binaryFile)}async function instantiateArrayBuffer(binaryFile,imports){try{var binary=await getWasmBinary(binaryFile);var instance=await WebAssembly.instantiate(binary,imports);return instance}catch(reason){err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)}}async function instantiateAsync(binary,binaryFile,imports){if(!binary){try{var response=fetch(binaryFile,{credentials:\"same-origin\"});var instantiationResult=await WebAssembly.instantiateStreaming(response,imports);return instantiationResult}catch(reason){err(`wasm streaming compile failed: ${reason}`);err(\"falling back to ArrayBuffer instantiation\")}}return instantiateArrayBuffer(binaryFile,imports)}function getWasmImports(){var imports={a:wasmImports};return imports}async function createWasm(){function receiveInstance(instance,module){wasmExports=instance.exports;wasmExports=Asyncify.instrumentWasmExports(wasmExports);assignWasmExports(wasmExports);updateMemoryViews();return wasmExports}function receiveInstantiationResult(result){return receiveInstance(result[\"instance\"])}var info=getWasmImports();if(Module[\"instantiateWasm\"]){return new Promise((resolve,reject)=>{Module[\"instantiateWasm\"](info,(inst,mod)=>{resolve(receiveInstance(inst,mod))})})}wasmBinaryFile??=findWasmBinary();var result=await instantiateAsync(wasmBinary,wasmBinaryFile,info);var exports=receiveInstantiationResult(result);return exports}var tempDouble;var tempI64;class ExitStatus{name=\"ExitStatus\";constructor(status){this.message=`Program terminated with exit(${status})`;this.status=status}}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};var onPostRuns=[];var addOnPostRun=cb=>onPostRuns.push(cb);var onPreRuns=[];var addOnPreRun=cb=>onPreRuns.push(cb);var dynCalls={};function getValue(ptr,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":return HEAP8[ptr];case\"i8\":return HEAP8[ptr];case\"i16\":return HEAP16[ptr>>1];case\"i32\":return HEAP32[ptr>>2];case\"i64\":abort(\"to do getValue(i64) use WASM_BIGINT\");case\"float\":return HEAPF32[ptr>>2];case\"double\":return HEAPF64[ptr>>3];case\"*\":return HEAPU32[ptr>>2];default:abort(`invalid type for getValue: ${type}`)}}var noExitRuntime=true;function setValue(ptr,value,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":HEAP8[ptr]=value;break;case\"i8\":HEAP8[ptr]=value;break;case\"i16\":HEAP16[ptr>>1]=value;break;case\"i32\":HEAP32[ptr>>2]=value;break;case\"i64\":abort(\"to do setValue(i64) use WASM_BIGINT\");case\"float\":HEAPF32[ptr>>2]=value;break;case\"double\":HEAPF64[ptr>>3]=value;break;case\"*\":HEAPU32[ptr>>2]=value;break;default:abort(`invalid type for setValue: ${type}`)}}var stackRestore=val=>__emscripten_stack_restore(val);var stackSave=()=>_emscripten_stack_get_current();var UTF8Decoder=new TextDecoder;var findStringEnd=(heapOrArray,idx,maxBytesToRead,ignoreNul)=>{var maxIdx=idx+maxBytesToRead;if(ignoreNul)return maxIdx;while(heapOrArray[idx]&&!(idx>=maxIdx))++idx;return idx};var UTF8ToString=(ptr,maxBytesToRead,ignoreNul)=>{if(!ptr)return\"\";var end=findStringEnd(HEAPU8,ptr,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(HEAPU8.subarray(ptr,end))};var ___assert_fail=(condition,filename,line,func)=>abort(`Assertion failed: ${UTF8ToString(condition)}, at: `+[filename?UTF8ToString(filename):\"unknown filename\",line,func?UTF8ToString(func):\"unknown function\"]);var PATH={isAbs:path=>path.charAt(0)===\"/\",splitPath:filename=>{var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.slice(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(p=>!!p),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.slice(0,-1)}return root+dir},basename:path=>path&&path.match(/([^\\/]+|\\/)\\/*$/)[1],join:(...paths)=>PATH.normalize(paths.join(\"/\")),join2:(l,r)=>PATH.normalize(l+\"/\"+r)};var initRandomFill=()=>view=>crypto.getRandomValues(view);var randomFill=view=>{(randomFill=initRandomFill())(view)};var PATH_FS={resolve:(...args)=>{var resolvedPath=\"\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\"string\"){throw new TypeError(\"Arguments to path.resolve must be strings\")}else if(!path){return\"\"}resolvedPath=path+\"/\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\"/\").filter(p=>!!p),!resolvedAbsolute).join(\"/\");return(resolvedAbsolute?\"/\":\"\")+resolvedPath||\".\"},relative:(from,to)=>{from=PATH_FS.resolve(from).slice(1);to=PATH_FS.resolve(to).slice(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\"\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\"\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\"/\"));var toParts=trim(to.split(\"/\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\"..\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\"/\")}};var UTF8ArrayToString=(heapOrArray,idx=0,maxBytesToRead,ignoreNul)=>{var endPtr=findStringEnd(heapOrArray,idx,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(heapOrArray.buffer?heapOrArray.subarray(idx,endPtr):new Uint8Array(heapOrArray.slice(idx,endPtr)))};var FS_stdin_getChar_buffer=[];var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.codePointAt(i);if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;i++}}heap[outIdx]=0;return outIdx-startIdx};var intArrayFromString=(stringy,dontAddNull,length)=>{var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array};var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(globalThis.window?.prompt){result=window.prompt(\"Input: \");if(result!==null){result+=\"\\n\"}}else{}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){out(UTF8ArrayToString(tty.output));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){err(UTF8ArrayToString(tty.output));tty.output=[]}}}};var zeroMemory=(ptr,size)=>HEAPU8.fill(0,ptr,ptr+size);var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(ptr)zeroMemory(ptr,size);return ptr};var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\"/\",16895,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.atime=node.mtime=node.ctime=Date.now();if(parent){parent.contents[name]=node;parent.atime=parent.mtime=parent.ctime=node.atime}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.atime);attr.mtime=new Date(node.mtime);attr.ctime=new Date(node.ctime);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){for(const key of[\"mode\",\"atime\",\"mtime\",\"ctime\"]){if(attr[key]!=null){node[key]=attr[key]}}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){if(!MEMFS.doesNotExistError){MEMFS.doesNotExistError=new FS.ErrnoError(44);MEMFS.doesNotExistError.stack=\"<generic error, no stack>\"}throw MEMFS.doesNotExistError},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){if(FS.isDir(old_node.mode)){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}FS.hashRemoveNode(new_node)}delete old_node.parent.contents[old_node.name];new_dir.contents[new_name]=old_node;old_node.name=new_name;new_dir.ctime=new_dir.mtime=old_node.parent.ctime=old_node.parent.mtime=Date.now()},unlink(parent,name){delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},readdir(node){return[\".\",\"..\",...Object.keys(node.contents)]},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.mtime=node.ctime=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents&&contents.buffer===HEAP8.buffer){allocated=false;ptr=contents.byteOffset}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}if(contents){if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}HEAP8.set(contents,ptr)}}return{ptr,allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var FS_modeStringToFlags=str=>{var flagModes={r:0,\"r+\":2,w:512|64|1,\"w+\":512|64|2,a:1024|64|1,\"a+\":1024|64|2};var flags=flagModes[str];if(typeof flags==\"undefined\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};var asyncLoad=async url=>{var arrayBuffer=await readAsync(url);return new Uint8Array(arrayBuffer)};var FS_createDataFile=(...args)=>FS.createDataFile(...args);var getUniqueRunDependency=id=>id;var runDependencies=0;var dependenciesFulfilled=null;var removeRunDependency=id=>{runDependencies--;Module[\"monitorRunDependencies\"]?.(runDependencies);if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}};var addRunDependency=id=>{runDependencies++;Module[\"monitorRunDependencies\"]?.(runDependencies)};var preloadPlugins=[];var FS_handledByPreloadPlugin=async(byteArray,fullname)=>{if(typeof Browser!=\"undefined\")Browser.init();for(var plugin of preloadPlugins){if(plugin[\"canHandle\"](fullname)){return plugin[\"handle\"](byteArray,fullname)}}return byteArray};var FS_preloadFile=async(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);addRunDependency(dep);try{var byteArray=url;if(typeof url==\"string\"){byteArray=await asyncLoad(url)}byteArray=await FS_handledByPreloadPlugin(byteArray,fullname);preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}}finally{removeRunDependency(dep)}};var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{FS_preloadFile(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish).then(onload).catch(onerror)};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,filesystems:null,syncFSRequests:0,ErrnoError:class{name=\"ErrnoError\";constructor(errno){this.errno=errno}},FSStream:class{shared={};get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{node_ops={};stream_ops={};readMode=292|73;writeMode=146;mounted=null;constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.rdev=rdev;this.atime=this.mtime=this.ctime=Date.now()}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){if(!path){throw new FS.ErrnoError(44)}opts.follow_mount??=true;if(!PATH.isAbs(path)){path=FS.cwd()+\"/\"+path}linkloop:for(var nlinks=0;nlinks<40;nlinks++){var parts=path.split(\"/\").filter(p=>!!p);var current=FS.root;var current_path=\"/\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}if(parts[i]===\".\"){continue}if(parts[i]===\"..\"){current_path=PATH.dirname(current_path);if(FS.isRoot(current)){path=current_path+\"/\"+parts.slice(i+1).join(\"/\");nlinks--;continue linkloop}else{current=current.parent}continue}current_path=PATH.join2(current_path,parts[i]);try{current=FS.lookupNode(current,parts[i])}catch(e){if(e?.errno===44&&islast&&opts.noent_okay){return{path:current_path}}throw e}if(FS.isMountpoint(current)&&(!islast||opts.follow_mount)){current=current.mounted.root}if(FS.isLink(current.mode)&&(!islast||opts.follow)){if(!current.node_ops.readlink){throw new FS.ErrnoError(52)}var link=current.node_ops.readlink(current);if(!PATH.isAbs(link)){link=PATH.dirname(current_path)+\"/\"+link}path=link+\"/\"+parts.slice(i+1).join(\"/\");continue linkloop}}return{path:current_path,node:current}}throw new FS.ErrnoError(32)},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\"/\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\"r\",\"w\",\"rw\"][flag&3];if(flag&512){perms+=\"w\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\"r\")&&!(node.mode&292)){return 2}if(perms.includes(\"w\")&&!(node.mode&146)){return 2}if(perms.includes(\"x\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\"x\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){if(!FS.isDir(dir.mode)){return 54}try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\"wx\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\"wx\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else if(FS.isDir(node.mode)){return 31}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}var mode=FS.flagsToPermissionString(flags);if(FS.isDir(node.mode)){if(mode!==\"r\"||flags&(512|64)){return 31}}return FS.nodePermissions(node,mode)},checkOpExists(op,err){if(!op){throw new FS.ErrnoError(err)}return op},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},doSetAttr(stream,node,attr){var setattr=stream?.stream_ops.setattr;var arg=setattr?stream:node;setattr??=node.node_ops.setattr;FS.checkOpExists(setattr,63);setattr(arg,attr)},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\"function\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}for(var mount of mounts){if(mount.type.syncfs){mount.type.syncfs(mount,populate,done)}else{done(null)}}},mount(type,opts,mountpoint){var root=mountpoint===\"/\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type,opts,mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);for(var[hash,current]of Object.entries(FS.nameTable)){while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}}node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name){throw new FS.ErrnoError(28)}if(name===\".\"||name===\"..\"){throw new FS.ErrnoError(20)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},statfs(path){return FS.statfsNode(FS.lookupPath(path,{follow:true}).node)},statfsStream(stream){return FS.statfsNode(stream.node)},statfsNode(node){var rtn={bsize:4096,frsize:4096,blocks:1e6,bfree:5e5,bavail:5e5,files:FS.nextInode,ffree:FS.nextInode-1,fsid:42,flags:2,namelen:255};if(node.node_ops.statfs){Object.assign(rtn,node.node_ops.statfs(node.mount.opts.root))}return rtn},create(path,mode=438){mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode=511){mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\"/\");var d=\"\";for(var dir of dirs){if(!dir)continue;if(d||PATH.isAbs(path))d+=\"/\";d+=dir;try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\"undefined\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);old_node.parent=new_dir}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var readdir=FS.checkOpExists(node.node_ops.readdir,54);return readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return link.node_ops.readlink(link)},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;var getattr=FS.checkOpExists(node.node_ops.getattr,63);return getattr(node)},fstat(fd){var stream=FS.getStreamChecked(fd);var node=stream.node;var getattr=stream.stream_ops.getattr;var arg=getattr?stream:node;getattr??=node.node_ops.getattr;FS.checkOpExists(getattr,63);return getattr(arg)},lstat(path){return FS.stat(path,true)},doChmod(stream,node,mode,dontFollow){FS.doSetAttr(stream,node,{mode:mode&4095|node.mode&~4095,ctime:Date.now(),dontFollow})},chmod(path,mode,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChmod(null,node,mode,dontFollow)},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.doChmod(stream,stream.node,mode,false)},doChown(stream,node,dontFollow){FS.doSetAttr(stream,node,{timestamp:Date.now(),dontFollow})},chown(path,uid,gid,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChown(null,node,dontFollow)},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.doChown(stream,stream.node,false)},doTruncate(stream,node,len){if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}FS.doSetAttr(stream,node,{size:len,timestamp:Date.now()})},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}FS.doTruncate(null,node,len)},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if(len<0||(stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.doTruncate(stream,stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var setattr=FS.checkOpExists(node.node_ops.setattr,63);setattr(node,{atime,mtime})},open(path,flags,mode=438){if(path===\"\"){throw new FS.ErrnoError(44)}flags=typeof flags==\"string\"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;var isDirPath;if(typeof path==\"object\"){node=path}else{isDirPath=path.endsWith(\"/\");var lookup=FS.lookupPath(path,{follow:!(flags&131072),noent_okay:true});node=lookup.node;path=lookup.path}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else if(isDirPath){throw new FS.ErrnoError(31)}else{node=FS.mknod(path,mode|511,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node,path:FS.getPath(node),flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(created){FS.chmod(node,mode&511)}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}if(!length){throw new FS.ErrnoError(28)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\"binary\";if(opts.encoding!==\"utf8\"&&opts.encoding!==\"binary\"){abort(`Invalid encoding type \"${opts.encoding}\"`)}var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\"utf8\"){buf=UTF8ArrayToString(buf)}FS.close(stream);return buf},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\"string\"){data=new Uint8Array(intArrayFromString(data,true))}if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{abort(\"Unsupported data type\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\"x\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\"/tmp\");FS.mkdir(\"/home\");FS.mkdir(\"/home/web_user\")},createDefaultDevices(){FS.mkdir(\"/dev\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length,llseek:()=>0});FS.mkdev(\"/dev/null\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\"/dev/tty\",FS.makedev(5,0));FS.mkdev(\"/dev/tty1\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomFill(randomBuffer);randomLeft=randomBuffer.byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\"/dev\",\"random\",randomByte);FS.createDevice(\"/dev\",\"urandom\",randomByte);FS.mkdir(\"/dev/shm\");FS.mkdir(\"/dev/shm/tmp\")},createSpecialDirectories(){FS.mkdir(\"/proc\");var proc_self=FS.mkdir(\"/proc/self\");FS.mkdir(\"/proc/self/fd\");FS.mount({mount(){var node=FS.createNode(proc_self,\"fd\",16895,73);node.stream_ops={llseek:MEMFS.stream_ops.llseek};node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\"fake\"},node_ops:{readlink:()=>stream.path},id:fd+1};ret.parent=ret;return ret},readdir(){return Array.from(FS.streams.entries()).filter(([k,v])=>v).map(([k,v])=>k.toString())}};return node}},{},\"/proc/self/fd\")},createStandardStreams(input,output,error){if(input){FS.createDevice(\"/dev\",\"stdin\",input)}else{FS.symlink(\"/dev/tty\",\"/dev/stdin\")}if(output){FS.createDevice(\"/dev\",\"stdout\",null,output)}else{FS.symlink(\"/dev/tty\",\"/dev/stdout\")}if(error){FS.createDevice(\"/dev\",\"stderr\",null,error)}else{FS.symlink(\"/dev/tty1\",\"/dev/stderr\")}var stdin=FS.open(\"/dev/stdin\",0);var stdout=FS.open(\"/dev/stdout\",1);var stderr=FS.open(\"/dev/stderr\",1)},staticInit(){FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\"/\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={MEMFS}},init(input,output,error){FS.initialized=true;input??=Module[\"stdin\"];output??=Module[\"stdout\"];error??=Module[\"stderr\"];FS.createStandardStreams(input,output,error)},quit(){FS.initialized=false;for(var stream of FS.streams){if(stream){FS.close(stream)}}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\"/\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\"string\"?parent:FS.getPath(parent);var parts=path.split(\"/\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){if(e.errno!=20)throw e}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\"string\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\"string\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(globalThis.XMLHttpRequest){abort(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\")}else{try{obj.contents=readBinary(obj.url)}catch(e){throw new FS.ErrnoError(29)}}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{lengthKnown=false;chunks=[];get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\"HEAD\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);var datalength=Number(xhr.getResponseHeader(\"Content-length\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\"Accept-Ranges\"))&&header===\"bytes\";var usesGzip=(header=xhr.getResponseHeader(\"Content-Encoding\"))&&header===\"gzip\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)abort(\"invalid range (\"+from+\", \"+to+\") or no bytes requested!\");if(to>datalength-1)abort(\"only \"+datalength+\" bytes available! programmer error!\");var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\"Range\",\"bytes=\"+from+\"-\"+to);xhr.responseType=\"arraybuffer\";if(xhr.overrideMimeType){xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\"\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\"undefined\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\"undefined\")abort(\"doXHR failed!\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\"LazyFiles on gzip forces download of the whole file when length is accessed\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(globalThis.XMLHttpRequest){if(!ENVIRONMENT_IS_WORKER)abort(\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\");var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};for(const[key,fn]of Object.entries(node.stream_ops)){stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}}function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr,allocated:true}};node.stream_ops=stream_ops;return node}};var SYSCALLS={calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return dir+\"/\"+path},writeStat(buf,stat){HEAPU32[buf>>2]=stat.dev;HEAPU32[buf+4>>2]=stat.mode;HEAPU32[buf+8>>2]=stat.nlink;HEAPU32[buf+12>>2]=stat.uid;HEAPU32[buf+16>>2]=stat.gid;HEAPU32[buf+20>>2]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];HEAP32[buf+32>>2]=4096;HEAP32[buf+36>>2]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=atime%1e3*1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+56>>2]=tempI64[0],HEAP32[buf+60>>2]=tempI64[1];HEAPU32[buf+64>>2]=mtime%1e3*1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+72>>2]=tempI64[0],HEAP32[buf+76>>2]=tempI64[1];HEAPU32[buf+80>>2]=ctime%1e3*1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+88>>2]=tempI64[0],HEAP32[buf+92>>2]=tempI64[1];return 0},writeStatFs(buf,stats){HEAPU32[buf+4>>2]=stats.bsize;HEAPU32[buf+60>>2]=stats.bsize;tempI64=[stats.blocks>>>0,(tempDouble=stats.blocks,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+8>>2]=tempI64[0],HEAP32[buf+12>>2]=tempI64[1];tempI64=[stats.bfree>>>0,(tempDouble=stats.bfree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+16>>2]=tempI64[0],HEAP32[buf+20>>2]=tempI64[1];tempI64=[stats.bavail>>>0,(tempDouble=stats.bavail,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];tempI64=[stats.files>>>0,(tempDouble=stats.files,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+32>>2]=tempI64[0],HEAP32[buf+36>>2]=tempI64[1];tempI64=[stats.ffree>>>0,(tempDouble=stats.ffree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=stats.fsid;HEAPU32[buf+64>>2]=stats.flags;HEAPU32[buf+56>>2]=stats.namelen},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_chmod(path,mode){try{path=SYSCALLS.getStr(path);FS.chmod(path,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_faccessat(dirfd,path,amode,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(amode&~7){return-28}var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node){return-44}var perms=\"\";if(amode&4)perms+=\"r\";if(amode&2)perms+=\"w\";if(amode&1)perms+=\"x\";if(perms&&FS.nodePermissions(node,perms)){return-2}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchmod(fd,mode){try{FS.fchmod(fd,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchown32(fd,owner,group){try{FS.fchown(fd,owner,group);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var syscallGetVarargI=()=>{var ret=HEAP32[+SYSCALLS.varargs>>2];SYSCALLS.varargs+=4;return ret};var syscallGetVarargP=syscallGetVarargI;function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0}case 12:{var arg=syscallGetVarargP();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fstat64(fd,buf){try{return SYSCALLS.writeStat(buf,FS.fstat(fd))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;function ___syscall_ftruncate64(fd,length_low,length_high){var length=convertI32PairToI53Checked(length_low,length_high);try{if(isNaN(length))return-61;FS.ftruncate(fd,length);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);function ___syscall_getcwd(buf,size){try{if(size===0)return-28;var cwd=FS.cwd();var cwdLengthInBytes=lengthBytesUTF8(cwd)+1;if(size<cwdLengthInBytes)return-68;stringToUTF8(cwd,buf,size);return cwdLengthInBytes}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_lstat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.lstat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_mkdirat(dirfd,path,mode){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);FS.mkdir(path,mode,0);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_newfstatat(dirfd,path,buf,flags){try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~6400;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.writeStat(buf,nofollow?FS.lstat(path):FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_readlinkat(dirfd,path,buf,bufsize){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(bufsize<=0)return-28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_rmdir(path){try{path=SYSCALLS.getStr(path);FS.rmdir(path);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_unlinkat(dirfd,path,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(!flags){FS.unlink(path)}else if(flags===512){FS.rmdir(path)}else{return-28}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var readI53FromI64=ptr=>HEAPU32[ptr>>2]+HEAP32[ptr+4>>2]*4294967296;function ___syscall_utimensat(dirfd,path,times,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path,true);var now=Date.now(),atime,mtime;if(!times){atime=now;mtime=now}else{var seconds=readI53FromI64(times);var nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){atime=now}else if(nanoseconds==1073741822){atime=null}else{atime=seconds*1e3+nanoseconds/(1e3*1e3)}times+=16;seconds=readI53FromI64(times);nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){mtime=now}else if(nanoseconds==1073741822){mtime=null}else{mtime=seconds*1e3+nanoseconds/(1e3*1e3)}}if((mtime??atime)!==null){FS.utime(path,atime,mtime)}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var __abort_js=()=>abort(\"\");var runtimeKeepaliveCounter=0;var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);var MONTH_DAYS_LEAP_CUMULATIVE=[0,31,60,91,121,152,182,213,244,274,305,335];var MONTH_DAYS_REGULAR_CUMULATIVE=[0,31,59,90,120,151,181,212,243,273,304,334];var ydayFromDate=date=>{var leap=isLeapYear(date.getFullYear());var monthDaysCumulative=leap?MONTH_DAYS_LEAP_CUMULATIVE:MONTH_DAYS_REGULAR_CUMULATIVE;var yday=monthDaysCumulative[date.getMonth()]+date.getDate()-1;return yday};function __localtime_js(time_low,time_high,tmPtr){var time=convertI32PairToI53Checked(time_low,time_high);var date=new Date(time*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var yday=ydayFromDate(date)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst}function __mmap_js(len,prot,flags,fd,offset_low,offset_high,allocated,addr){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;HEAP32[allocated>>2]=res.allocated;HEAPU32[addr>>2]=ptr;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function __munmap_js(addr,len,prot,flags,fd,offset_low,offset_high){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var timers={};var handleException=e=>{if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)};var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module[\"onExit\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var _exit=exitJS;var maybeExit=()=>{if(!keepRuntimeAlive()){try{_exit(EXITSTATUS)}catch(e){handleException(e)}}};var callUserCallback=func=>{if(ABORT){return}try{return func()}catch(e){handleException(e)}finally{maybeExit()}};var _emscripten_get_now=()=>performance.now();var __setitimer_js=(which,timeout_ms)=>{if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0};var __tzset_js=(timezone,daylight,std_name,dst_name)=>{var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAPU32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{var sign=timezoneOffset>=0?\"-\":\"+\";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,\"0\");var minutes=String(absOffset%60).padStart(2,\"0\");return`UTC${sign}${hours}${minutes}`};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17)}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17)}};var _emscripten_date_now=()=>Date.now();var getHeapMax=()=>2147483648;var growMemory=size=>{var oldHeapSize=wasmMemory.buffer.byteLength;var pages=(size-oldHeapSize+65535)/65536|0;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var ENV={};var getExecutableName=()=>thisProgram||\"./this.program\";var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(globalThis.navigator?.language??\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:lang,_:getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};var _environ_get=(__environ,environ_buf)=>{var bufSize=0;var envp=0;for(var string of getEnvStrings()){var ptr=environ_buf+bufSize;HEAPU32[__environ+envp>>2]=ptr;bufSize+=stringToUTF8(string,ptr,Infinity)+1;envp+=4}return 0};var _environ_sizes_get=(penviron_count,penviron_buf_size)=>{var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;for(var string of strings){bufSize+=lengthBytesUTF8(string)+1}HEAPU32[penviron_buf_size>>2]=bufSize;return 0};function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_fdstat_get(fd,pbuf){try{var rightsBase=0;var rightsInheriting=0;var flags=0;{var stream=SYSCALLS.getStreamFromFD(fd);var type=stream.tty?2:FS.isDir(stream.mode)?3:FS.isLink(stream.mode)?7:4}HEAP8[pbuf]=type;HEAP16[pbuf+2>>1]=flags;tempI64=[rightsBase>>>0,(tempDouble=rightsBase,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+8>>2]=tempI64[0],HEAP32[pbuf+12>>2]=tempI64[1];tempI64=[rightsInheriting>>>0,(tempDouble=rightsInheriting,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+16>>2]=tempI64[0],HEAP32[pbuf+20>>2]=tempI64[1];return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var _fd_sync=function(fd){let innerFunc=()=>{try{var stream=SYSCALLS.getStreamFromFD(fd);var rtn=stream.stream_ops?.fsync?.(stream);return new Promise(resolve=>{var mount=stream.node.mount;if(mount?.type.syncfs){mount.type.syncfs(mount,false,err=>resolve(err?29:0))}else{resolve(rtn)}})}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}};return Asyncify.handleAsync(innerFunc)};_fd_sync.isAsync=true;var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){break}if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var adapters_support=function(){const handleAsync=typeof Asyncify===\"object\"?Asyncify.handleAsync.bind(Asyncify):null;Module[\"handleAsync\"]=handleAsync;const targets=new Map;Module[\"setCallback\"]=(key,target)=>targets.set(key,target);Module[\"getCallback\"]=key=>targets.get(key);Module[\"deleteCallback\"]=key=>targets.delete(key);adapters_support=function(isAsync,key,...args){const receiver=targets.get(key);let methodName=null;const f=typeof receiver===\"function\"?receiver:receiver[methodName=UTF8ToString(args.shift())];if(isAsync){if(handleAsync){return handleAsync(()=>f.apply(receiver,args))}throw new Error(\"Synchronous WebAssembly cannot call async function\")}const result=f.apply(receiver,args);if(typeof result?.then==\"function\"){console.error(\"unexpected Promise\",f);throw new Error(`${methodName} unexpectedly returned a Promise`)}return result}};function _ipp(...args){return adapters_support(false,...args)}function _ipp_async(...args){return adapters_support(true,...args)}_ipp_async.isAsync=true;function _ippipppp(...args){return adapters_support(false,...args)}function _ippipppp_async(...args){return adapters_support(true,...args)}_ippipppp_async.isAsync=true;function _ippp(...args){return adapters_support(false,...args)}function _ippp_async(...args){return adapters_support(true,...args)}_ippp_async.isAsync=true;function _ipppi(...args){return adapters_support(false,...args)}function _ipppi_async(...args){return adapters_support(true,...args)}_ipppi_async.isAsync=true;function _ipppiii(...args){return adapters_support(false,...args)}function _ipppiii_async(...args){return adapters_support(true,...args)}_ipppiii_async.isAsync=true;function _ipppiiip(...args){return adapters_support(false,...args)}function _ipppiiip_async(...args){return adapters_support(true,...args)}_ipppiiip_async.isAsync=true;function _ipppip(...args){return adapters_support(false,...args)}function _ipppip_async(...args){return adapters_support(true,...args)}_ipppip_async.isAsync=true;function _ipppj(...args){return adapters_support(false,...args)}function _ipppj_async(...args){return adapters_support(true,...args)}_ipppj_async.isAsync=true;function _ipppp(...args){return adapters_support(false,...args)}function _ipppp_async(...args){return adapters_support(true,...args)}_ipppp_async.isAsync=true;function _ippppi(...args){return adapters_support(false,...args)}function _ippppi_async(...args){return adapters_support(true,...args)}_ippppi_async.isAsync=true;function _ippppij(...args){return adapters_support(false,...args)}function _ippppij_async(...args){return adapters_support(true,...args)}_ippppij_async.isAsync=true;function _ippppip(...args){return adapters_support(false,...args)}function _ippppip_async(...args){return adapters_support(true,...args)}_ippppip_async.isAsync=true;function _ipppppip(...args){return adapters_support(false,...args)}function _ipppppip_async(...args){return adapters_support(true,...args)}_ipppppip_async.isAsync=true;function _vppippii(...args){return adapters_support(false,...args)}function _vppippii_async(...args){return adapters_support(true,...args)}_vppippii_async.isAsync=true;function _vppp(...args){return adapters_support(false,...args)}function _vppp_async(...args){return adapters_support(true,...args)}_vppp_async.isAsync=true;function _vpppip(...args){return adapters_support(false,...args)}function _vpppip_async(...args){return adapters_support(true,...args)}_vpppip_async.isAsync=true;var runAndAbortIfError=func=>{try{return func()}catch(e){abort(e)}};var runtimeKeepalivePush=()=>{runtimeKeepaliveCounter+=1};var runtimeKeepalivePop=()=>{runtimeKeepaliveCounter-=1};var Asyncify={instrumentWasmImports(imports){var importPattern=/^(ipp|ipp_async|ippp|ippp_async|vppp|vppp_async|ipppj|ipppj_async|ipppi|ipppi_async|ipppp|ipppp_async|ipppip|ipppip_async|vpppip|vpppip_async|ippppi|ippppi_async|ippppij|ippppij_async|ipppiii|ipppiii_async|ippppip|ippppip_async|ippipppp|ippipppp_async|ipppppip|ipppppip_async|ipppiiip|ipppiiip_async|vppippii|vppippii_async|invoke_.*|__asyncjs__.*)$/;for(let[x,original]of Object.entries(imports)){if(typeof original==\"function\"){let isAsyncifyImport=original.isAsync||importPattern.test(x)}}},instrumentFunction(original){var wrapper=(...args)=>{Asyncify.exportCallStack.push(original);try{return original(...args)}finally{if(!ABORT){var top=Asyncify.exportCallStack.pop();Asyncify.maybeStopUnwind()}}};Asyncify.funcWrappers.set(original,wrapper);return wrapper},instrumentWasmExports(exports){var ret={};for(let[x,original]of Object.entries(exports)){if(typeof original==\"function\"){var wrapper=Asyncify.instrumentFunction(original);ret[x]=wrapper}else{ret[x]=original}}return ret},State:{Normal:0,Unwinding:1,Rewinding:2,Disabled:3},state:0,StackSize:16384,currData:null,handleSleepReturnValue:0,exportCallStack:[],callstackFuncToId:new Map,callStackIdToFunc:new Map,funcWrappers:new Map,callStackId:0,asyncPromiseHandlers:null,sleepCallbacks:[],getCallStackId(func){if(!Asyncify.callstackFuncToId.has(func)){var id=Asyncify.callStackId++;Asyncify.callstackFuncToId.set(func,id);Asyncify.callStackIdToFunc.set(id,func)}return Asyncify.callstackFuncToId.get(func)},maybeStopUnwind(){if(Asyncify.currData&&Asyncify.state===Asyncify.State.Unwinding&&Asyncify.exportCallStack.length===0){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_unwind);if(typeof Fibers!=\"undefined\"){Fibers.trampoline()}}},whenDone(){return new Promise((resolve,reject)=>{Asyncify.asyncPromiseHandlers={resolve,reject}})},allocateData(){var ptr=_malloc(12+Asyncify.StackSize);Asyncify.setDataHeader(ptr,ptr+12,Asyncify.StackSize);Asyncify.setDataRewindFunc(ptr);return ptr},setDataHeader(ptr,stack,stackSize){HEAPU32[ptr>>2]=stack;HEAPU32[ptr+4>>2]=stack+stackSize},setDataRewindFunc(ptr){var bottomOfCallStack=Asyncify.exportCallStack[0];var rewindId=Asyncify.getCallStackId(bottomOfCallStack);HEAP32[ptr+8>>2]=rewindId},getDataRewindFunc(ptr){var id=HEAP32[ptr+8>>2];var func=Asyncify.callStackIdToFunc.get(id);return func},doRewind(ptr){var original=Asyncify.getDataRewindFunc(ptr);var func=Asyncify.funcWrappers.get(original);return callUserCallback(func)},handleSleep(startAsync){if(ABORT)return;if(Asyncify.state===Asyncify.State.Normal){var reachedCallback=false;var reachedAfterCallback=false;startAsync((handleSleepReturnValue=0)=>{if(ABORT)return;Asyncify.handleSleepReturnValue=handleSleepReturnValue;reachedCallback=true;if(!reachedAfterCallback){return}Asyncify.state=Asyncify.State.Rewinding;runAndAbortIfError(()=>_asyncify_start_rewind(Asyncify.currData));if(typeof MainLoop!=\"undefined\"&&MainLoop.func){MainLoop.resume()}var asyncWasmReturnValue,isError=false;try{asyncWasmReturnValue=Asyncify.doRewind(Asyncify.currData)}catch(err){asyncWasmReturnValue=err;isError=true}var handled=false;if(!Asyncify.currData){var asyncPromiseHandlers=Asyncify.asyncPromiseHandlers;if(asyncPromiseHandlers){Asyncify.asyncPromiseHandlers=null;(isError?asyncPromiseHandlers.reject:asyncPromiseHandlers.resolve)(asyncWasmReturnValue);handled=true}}if(isError&&!handled){throw asyncWasmReturnValue}});reachedAfterCallback=true;if(!reachedCallback){Asyncify.state=Asyncify.State.Unwinding;Asyncify.currData=Asyncify.allocateData();if(typeof MainLoop!=\"undefined\"&&MainLoop.func){MainLoop.pause()}runAndAbortIfError(()=>_asyncify_start_unwind(Asyncify.currData))}}else if(Asyncify.state===Asyncify.State.Rewinding){Asyncify.state=Asyncify.State.Normal;runAndAbortIfError(_asyncify_stop_rewind);_free(Asyncify.currData);Asyncify.currData=null;Asyncify.sleepCallbacks.forEach(callUserCallback)}else{abort(`invalid state: ${Asyncify.state}`)}return Asyncify.handleSleepReturnValue},handleAsync:startAsync=>Asyncify.handleSleep(async wakeUp=>{wakeUp(await startAsync())})};var getWasmTableEntry=funcPtr=>wasmTable.get(funcPtr);var updateTableMap=(offset,count)=>{if(functionsInTableMap){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i)}}}};var functionsInTableMap;var getFunctionAddress=func=>{if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length)}return functionsInTableMap.get(func)||0};var freeTableIndexes=[];var getEmptyTableSlot=()=>{if(freeTableIndexes.length){return freeTableIndexes.pop()}return wasmTable[\"grow\"](1)};var setWasmTableEntry=(idx,func)=>wasmTable.set(idx,func);var uleb128EncodeWithLen=arr=>{const n=arr.length;return[n%128|128,n>>7,...arr]};var wasmTypeCodes={i:127,p:127,j:126,f:125,d:124,e:111};var generateTypePack=types=>uleb128EncodeWithLen(Array.from(types,type=>{var code=wasmTypeCodes[type];return code}));var convertJsFunctionToWasm=(func,sig)=>{var bytes=Uint8Array.of(0,97,115,109,1,0,0,0,1,...uleb128EncodeWithLen([1,96,...generateTypePack(sig.slice(1)),...generateTypePack(sig[0]===\"v\"?\"\":sig[0])]),2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{e:{f:func}});var wrappedFunc=instance.exports[\"f\"];return wrappedFunc};var addFunction=(func,sig)=>{var rtn=getFunctionAddress(func);if(rtn){return rtn}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func)}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped)}functionsInTableMap.set(func,ret);return ret};var getCFunc=ident=>{var func=Module[\"_\"+ident];return func};var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer)};var stackAlloc=sz=>__emscripten_stack_alloc(sz);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={string:str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},array:arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\"string\"){return UTF8ToString(ret)}if(returnType===\"boolean\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var previousAsync=Asyncify.currData;var ret=func(...cArgs);function onDone(ret){runtimeKeepalivePop();if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}var asyncMode=opts?.async;runtimeKeepalivePush();if(Asyncify.currData!=previousAsync){return Asyncify.whenDone().then(onDone)}ret=onDone(ret);if(asyncMode)return Promise.resolve(ret);return ret};var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\"number\"||type===\"boolean\");var numericRet=returnType!==\"string\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};var getTempRet0=val=>__emscripten_tempret_get();var stringToUTF16=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr};var stringToUTF32=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codePoint=str.codePointAt(i);if(codePoint>65535){i++}HEAP32[outPtr>>2]=codePoint;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr};var AsciiToString=ptr=>{var str=\"\";while(1){var ch=HEAPU8[ptr++];if(!ch)return str;str+=String.fromCharCode(ch)}};var UTF16Decoder=new TextDecoder(\"utf-16le\");var UTF16ToString=(ptr,maxBytesToRead,ignoreNul)=>{var idx=ptr>>1;var endIdx=findStringEnd(HEAPU16,idx,maxBytesToRead/2,ignoreNul);return UTF16Decoder.decode(HEAPU16.subarray(idx,endIdx))};var UTF32ToString=(ptr,maxBytesToRead,ignoreNul)=>{var str=\"\";var startIdx=ptr>>2;for(var i=0;!(i>=maxBytesToRead/4);i++){var utf32=HEAPU32[startIdx+i];if(!utf32&&!ignoreNul)break;str+=String.fromCodePoint(utf32)}return str};var intArrayToString=array=>{var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join(\"\")};var _getTempRet0=getTempRet0;FS.createPreloadedFile=FS_createPreloadedFile;FS.preloadFile=FS_preloadFile;FS.staticInit();adapters_support();{if(Module[\"noExitRuntime\"])noExitRuntime=Module[\"noExitRuntime\"];if(Module[\"preloadPlugins\"])preloadPlugins=Module[\"preloadPlugins\"];if(Module[\"print\"])out=Module[\"print\"];if(Module[\"printErr\"])err=Module[\"printErr\"];if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].shift()()}}}Module[\"getTempRet0\"]=getTempRet0;Module[\"ccall\"]=ccall;Module[\"cwrap\"]=cwrap;Module[\"addFunction\"]=addFunction;Module[\"setValue\"]=setValue;Module[\"getValue\"]=getValue;Module[\"UTF8ToString\"]=UTF8ToString;Module[\"stringToUTF8\"]=stringToUTF8;Module[\"lengthBytesUTF8\"]=lengthBytesUTF8;Module[\"intArrayFromString\"]=intArrayFromString;Module[\"intArrayToString\"]=intArrayToString;Module[\"AsciiToString\"]=AsciiToString;Module[\"UTF16ToString\"]=UTF16ToString;Module[\"stringToUTF16\"]=stringToUTF16;Module[\"UTF32ToString\"]=UTF32ToString;Module[\"stringToUTF32\"]=stringToUTF32;Module[\"writeArrayToMemory\"]=writeArrayToMemory;Module[\"_getTempRet0\"]=_getTempRet0;var _powersync_init_static,_sqlite3_status64,_sqlite3_status,_sqlite3_msize,_sqlite3_db_status,_sqlite3_vfs_find,_sqlite3_vfs_register,_sqlite3_vfs_unregister,_sqlite3_release_memory,_sqlite3_soft_heap_limit64,_sqlite3_memory_used,_sqlite3_hard_heap_limit64,_sqlite3_memory_highwater,_sqlite3_malloc,_sqlite3_malloc64,_sqlite3_free,_sqlite3_realloc,_sqlite3_realloc64,_sqlite3_str_vappendf,_sqlite3_str_append,_sqlite3_str_appendchar,_sqlite3_str_appendall,_sqlite3_str_appendf,_sqlite3_str_finish,_sqlite3_str_errcode,_sqlite3_str_length,_sqlite3_str_value,_sqlite3_str_reset,_sqlite3_str_new,_sqlite3_vmprintf,_sqlite3_mprintf,_sqlite3_vsnprintf,_sqlite3_snprintf,_sqlite3_log,_sqlite3_randomness,_sqlite3_stricmp,_sqlite3_strnicmp,_sqlite3_os_init,_sqlite3_os_end,_sqlite3_serialize,_sqlite3_prepare_v2,_sqlite3_step,_sqlite3_column_int64,_sqlite3_reset,_sqlite3_exec,_sqlite3_column_int,_sqlite3_finalize,_sqlite3_deserialize,_sqlite3_database_file_object,_sqlite3_backup_init,_sqlite3_backup_step,_sqlite3_backup_finish,_sqlite3_backup_remaining,_sqlite3_backup_pagecount,_sqlite3_clear_bindings,_sqlite3_value_blob,_sqlite3_value_text,_sqlite3_value_bytes,_sqlite3_value_bytes16,_sqlite3_value_double,_sqlite3_value_int,_sqlite3_value_int64,_sqlite3_value_subtype,_sqlite3_value_pointer,_sqlite3_value_text16,_sqlite3_value_text16be,_sqlite3_value_text16le,_sqlite3_value_type,_sqlite3_value_encoding,_sqlite3_value_nochange,_sqlite3_value_frombind,_sqlite3_value_dup,_sqlite3_value_free,_sqlite3_result_blob,_sqlite3_result_blob64,_sqlite3_result_double,_sqlite3_result_error,_sqlite3_result_error16,_sqlite3_result_int,_sqlite3_result_int64,_sqlite3_result_null,_sqlite3_result_pointer,_sqlite3_result_subtype,_sqlite3_result_text,_sqlite3_result_text64,_sqlite3_result_text16,_sqlite3_result_text16be,_sqlite3_result_text16le,_sqlite3_result_value,_sqlite3_result_error_toobig,_sqlite3_result_zeroblob,_sqlite3_result_zeroblob64,_sqlite3_result_error_code,_sqlite3_result_error_nomem,_sqlite3_user_data,_sqlite3_context_db_handle,_sqlite3_vtab_nochange,_sqlite3_vtab_in_first,_sqlite3_vtab_in_next,_sqlite3_aggregate_context,_sqlite3_get_auxdata,_sqlite3_set_auxdata,_sqlite3_column_count,_sqlite3_data_count,_sqlite3_column_blob,_sqlite3_column_bytes,_sqlite3_column_bytes16,_sqlite3_column_double,_sqlite3_column_text,_sqlite3_column_value,_sqlite3_column_text16,_sqlite3_column_type,_sqlite3_column_name,_sqlite3_column_name16,_sqlite3_bind_blob,_sqlite3_bind_blob64,_sqlite3_bind_double,_sqlite3_bind_int,_sqlite3_bind_int64,_sqlite3_bind_null,_sqlite3_bind_pointer,_sqlite3_bind_text,_sqlite3_bind_text64,_sqlite3_bind_text16,_sqlite3_bind_value,_sqlite3_bind_zeroblob,_sqlite3_bind_zeroblob64,_sqlite3_bind_parameter_count,_sqlite3_bind_parameter_name,_sqlite3_bind_parameter_index,_sqlite3_db_handle,_sqlite3_stmt_readonly,_sqlite3_stmt_isexplain,_sqlite3_stmt_explain,_sqlite3_stmt_busy,_sqlite3_next_stmt,_sqlite3_stmt_status,_sqlite3_sql,_sqlite3_expanded_sql,_sqlite3_value_numeric_type,_sqlite3_blob_open,_sqlite3_blob_close,_sqlite3_blob_read,_sqlite3_blob_write,_sqlite3_blob_bytes,_sqlite3_blob_reopen,_sqlite3_set_authorizer,_sqlite3_strglob,_sqlite3_strlike,_sqlite3_errmsg,_sqlite3_load_extension,_sqlite3_enable_load_extension,_sqlite3_auto_extension,_sqlite3_cancel_auto_extension,_sqlite3_reset_auto_extension,_sqlite3_prepare,_sqlite3_prepare_v3,_sqlite3_prepare16,_sqlite3_prepare16_v2,_sqlite3_prepare16_v3,_sqlite3_get_table,_sqlite3_free_table,_sqlite3_create_module,_sqlite3_create_module_v2,_sqlite3_drop_modules,_sqlite3_declare_vtab,_sqlite3_vtab_on_conflict,_sqlite3_vtab_config,_sqlite3_vtab_collation,_sqlite3_vtab_in,_sqlite3_vtab_rhs_value,_sqlite3_vtab_distinct,_sqlite3_keyword_name,_sqlite3_keyword_count,_sqlite3_keyword_check,_sqlite3_complete,_sqlite3_complete16,_sqlite3_libversion,_sqlite3_libversion_number,_sqlite3_threadsafe,_sqlite3_initialize,_sqlite3_shutdown,_sqlite3_config,_sqlite3_db_mutex,_sqlite3_db_release_memory,_sqlite3_db_cacheflush,_sqlite3_db_config,_sqlite3_last_insert_rowid,_sqlite3_set_last_insert_rowid,_sqlite3_changes64,_sqlite3_changes,_sqlite3_total_changes64,_sqlite3_total_changes,_sqlite3_txn_state,_sqlite3_close,_sqlite3_close_v2,_sqlite3_busy_handler,_sqlite3_progress_handler,_sqlite3_busy_timeout,_sqlite3_interrupt,_sqlite3_is_interrupted,_sqlite3_create_function,_sqlite3_create_function_v2,_sqlite3_create_window_function,_sqlite3_create_function16,_sqlite3_overload_function,_sqlite3_trace_v2,_sqlite3_commit_hook,_sqlite3_update_hook,_sqlite3_rollback_hook,_sqlite3_autovacuum_pages,_sqlite3_wal_autocheckpoint,_sqlite3_wal_hook,_sqlite3_wal_checkpoint_v2,_sqlite3_wal_checkpoint,_sqlite3_error_offset,_sqlite3_errmsg16,_sqlite3_errcode,_sqlite3_extended_errcode,_sqlite3_system_errno,_sqlite3_errstr,_sqlite3_limit,_sqlite3_open,_sqlite3_open_v2,_sqlite3_open16,_sqlite3_create_collation,_sqlite3_create_collation_v2,_sqlite3_create_collation16,_sqlite3_collation_needed,_sqlite3_collation_needed16,_sqlite3_get_clientdata,_sqlite3_set_clientdata,_sqlite3_get_autocommit,_sqlite3_table_column_metadata,_sqlite3_sleep,_sqlite3_extended_result_codes,_sqlite3_file_control,_sqlite3_test_control,_sqlite3_create_filename,_sqlite3_free_filename,_sqlite3_uri_parameter,_sqlite3_uri_key,_sqlite3_uri_boolean,_sqlite3_uri_int64,_sqlite3_filename_database,_sqlite3_filename_journal,_sqlite3_filename_wal,_sqlite3_db_name,_sqlite3_db_filename,_sqlite3_db_readonly,_sqlite3_compileoption_used,_sqlite3_compileoption_get,_sqlite3_sourceid,_memcmp,_malloc,_free,_RegisterExtensionFunctions,_getSqliteFree,_main,_libauthorizer_set_authorizer,_libfunction_create_function,_libhook_commit_hook,_libhook_update_hook,_libprogress_progress_handler,_libvfs_vfs_register,_memcpy,_memset,_emscripten_builtin_memalign,__emscripten_timeout,__emscripten_tempret_get,__emscripten_stack_restore,__emscripten_stack_alloc,_emscripten_stack_get_current,dynCall_iii,dynCall_viiiij,dynCall_ii,dynCall_vi,dynCall_iiii,dynCall_viii,dynCall_iiiiiii,dynCall_iiiiii,dynCall_iiiii,dynCall_vii,dynCall_viiii,dynCall_iiiiiiiii,dynCall_vijii,dynCall_viiiii,dynCall_iiiij,dynCall_viji,dynCall_iij,dynCall_iidiiii,dynCall_iijii,dynCall_iiji,dynCall_i,dynCall_iiiiiij,dynCall_iiid,dynCall_iiij,dynCall_dii,dynCall_jii,dynCall_ji,dynCall_vid,dynCall_vij,dynCall_iiiiiiiiii,dynCall_di,dynCall_iiiiijii,dynCall_j,dynCall_jj,dynCall_jiij,dynCall_iiiiji,dynCall_iiiijii,dynCall_ij,dynCall_v,dynCall_viiji,dynCall_viijii,dynCall_iiiiiiiiiii,dynCall_iiiijji,dynCall_iiiiiiii,_asyncify_start_unwind,_asyncify_stop_unwind,_asyncify_start_rewind,_asyncify_stop_rewind,memory,_sqlite3_version,__indirect_function_table,wasmMemory,wasmTable;function assignWasmExports(wasmExports){_powersync_init_static=Module[\"_powersync_init_static\"]=wasmExports[\"ra\"];_sqlite3_status64=Module[\"_sqlite3_status64\"]=wasmExports[\"sa\"];_sqlite3_status=Module[\"_sqlite3_status\"]=wasmExports[\"ta\"];_sqlite3_msize=Module[\"_sqlite3_msize\"]=wasmExports[\"ua\"];_sqlite3_db_status=Module[\"_sqlite3_db_status\"]=wasmExports[\"va\"];_sqlite3_vfs_find=Module[\"_sqlite3_vfs_find\"]=wasmExports[\"wa\"];_sqlite3_vfs_register=Module[\"_sqlite3_vfs_register\"]=wasmExports[\"xa\"];_sqlite3_vfs_unregister=Module[\"_sqlite3_vfs_unregister\"]=wasmExports[\"ya\"];_sqlite3_release_memory=Module[\"_sqlite3_release_memory\"]=wasmExports[\"za\"];_sqlite3_soft_heap_limit64=Module[\"_sqlite3_soft_heap_limit64\"]=wasmExports[\"Aa\"];_sqlite3_memory_used=Module[\"_sqlite3_memory_used\"]=wasmExports[\"Ba\"];_sqlite3_hard_heap_limit64=Module[\"_sqlite3_hard_heap_limit64\"]=wasmExports[\"Ca\"];_sqlite3_memory_highwater=Module[\"_sqlite3_memory_highwater\"]=wasmExports[\"Da\"];_sqlite3_malloc=Module[\"_sqlite3_malloc\"]=wasmExports[\"Ea\"];_sqlite3_malloc64=Module[\"_sqlite3_malloc64\"]=wasmExports[\"Fa\"];_sqlite3_free=Module[\"_sqlite3_free\"]=wasmExports[\"Ga\"];_sqlite3_realloc=Module[\"_sqlite3_realloc\"]=wasmExports[\"Ha\"];_sqlite3_realloc64=Module[\"_sqlite3_realloc64\"]=wasmExports[\"Ia\"];_sqlite3_str_vappendf=Module[\"_sqlite3_str_vappendf\"]=wasmExports[\"Ja\"];_sqlite3_str_append=Module[\"_sqlite3_str_append\"]=wasmExports[\"Ka\"];_sqlite3_str_appendchar=Module[\"_sqlite3_str_appendchar\"]=wasmExports[\"La\"];_sqlite3_str_appendall=Module[\"_sqlite3_str_appendall\"]=wasmExports[\"Ma\"];_sqlite3_str_appendf=Module[\"_sqlite3_str_appendf\"]=wasmExports[\"Na\"];_sqlite3_str_finish=Module[\"_sqlite3_str_finish\"]=wasmExports[\"Oa\"];_sqlite3_str_errcode=Module[\"_sqlite3_str_errcode\"]=wasmExports[\"Pa\"];_sqlite3_str_length=Module[\"_sqlite3_str_length\"]=wasmExports[\"Qa\"];_sqlite3_str_value=Module[\"_sqlite3_str_value\"]=wasmExports[\"Ra\"];_sqlite3_str_reset=Module[\"_sqlite3_str_reset\"]=wasmExports[\"Sa\"];_sqlite3_str_new=Module[\"_sqlite3_str_new\"]=wasmExports[\"Ta\"];_sqlite3_vmprintf=Module[\"_sqlite3_vmprintf\"]=wasmExports[\"Ua\"];_sqlite3_mprintf=Module[\"_sqlite3_mprintf\"]=wasmExports[\"Va\"];_sqlite3_vsnprintf=Module[\"_sqlite3_vsnprintf\"]=wasmExports[\"Wa\"];_sqlite3_snprintf=Module[\"_sqlite3_snprintf\"]=wasmExports[\"Xa\"];_sqlite3_log=Module[\"_sqlite3_log\"]=wasmExports[\"Ya\"];_sqlite3_randomness=Module[\"_sqlite3_randomness\"]=wasmExports[\"Za\"];_sqlite3_stricmp=Module[\"_sqlite3_stricmp\"]=wasmExports[\"_a\"];_sqlite3_strnicmp=Module[\"_sqlite3_strnicmp\"]=wasmExports[\"$a\"];_sqlite3_os_init=Module[\"_sqlite3_os_init\"]=wasmExports[\"ab\"];_sqlite3_os_end=Module[\"_sqlite3_os_end\"]=wasmExports[\"bb\"];_sqlite3_serialize=Module[\"_sqlite3_serialize\"]=wasmExports[\"cb\"];_sqlite3_prepare_v2=Module[\"_sqlite3_prepare_v2\"]=wasmExports[\"db\"];_sqlite3_step=Module[\"_sqlite3_step\"]=wasmExports[\"eb\"];_sqlite3_column_int64=Module[\"_sqlite3_column_int64\"]=wasmExports[\"fb\"];_sqlite3_reset=Module[\"_sqlite3_reset\"]=wasmExports[\"gb\"];_sqlite3_exec=Module[\"_sqlite3_exec\"]=wasmExports[\"hb\"];_sqlite3_column_int=Module[\"_sqlite3_column_int\"]=wasmExports[\"ib\"];_sqlite3_finalize=Module[\"_sqlite3_finalize\"]=wasmExports[\"jb\"];_sqlite3_deserialize=Module[\"_sqlite3_deserialize\"]=wasmExports[\"kb\"];_sqlite3_database_file_object=Module[\"_sqlite3_database_file_object\"]=wasmExports[\"lb\"];_sqlite3_backup_init=Module[\"_sqlite3_backup_init\"]=wasmExports[\"mb\"];_sqlite3_backup_step=Module[\"_sqlite3_backup_step\"]=wasmExports[\"nb\"];_sqlite3_backup_finish=Module[\"_sqlite3_backup_finish\"]=wasmExports[\"ob\"];_sqlite3_backup_remaining=Module[\"_sqlite3_backup_remaining\"]=wasmExports[\"pb\"];_sqlite3_backup_pagecount=Module[\"_sqlite3_backup_pagecount\"]=wasmExports[\"qb\"];_sqlite3_clear_bindings=Module[\"_sqlite3_clear_bindings\"]=wasmExports[\"rb\"];_sqlite3_value_blob=Module[\"_sqlite3_value_blob\"]=wasmExports[\"sb\"];_sqlite3_value_text=Module[\"_sqlite3_value_text\"]=wasmExports[\"tb\"];_sqlite3_value_bytes=Module[\"_sqlite3_value_bytes\"]=wasmExports[\"ub\"];_sqlite3_value_bytes16=Module[\"_sqlite3_value_bytes16\"]=wasmExports[\"vb\"];_sqlite3_value_double=Module[\"_sqlite3_value_double\"]=wasmExports[\"wb\"];_sqlite3_value_int=Module[\"_sqlite3_value_int\"]=wasmExports[\"xb\"];_sqlite3_value_int64=Module[\"_sqlite3_value_int64\"]=wasmExports[\"yb\"];_sqlite3_value_subtype=Module[\"_sqlite3_value_subtype\"]=wasmExports[\"zb\"];_sqlite3_value_pointer=Module[\"_sqlite3_value_pointer\"]=wasmExports[\"Ab\"];_sqlite3_value_text16=Module[\"_sqlite3_value_text16\"]=wasmExports[\"Bb\"];_sqlite3_value_text16be=Module[\"_sqlite3_value_text16be\"]=wasmExports[\"Cb\"];_sqlite3_value_text16le=Module[\"_sqlite3_value_text16le\"]=wasmExports[\"Db\"];_sqlite3_value_type=Module[\"_sqlite3_value_type\"]=wasmExports[\"Eb\"];_sqlite3_value_encoding=Module[\"_sqlite3_value_encoding\"]=wasmExports[\"Fb\"];_sqlite3_value_nochange=Module[\"_sqlite3_value_nochange\"]=wasmExports[\"Gb\"];_sqlite3_value_frombind=Module[\"_sqlite3_value_frombind\"]=wasmExports[\"Hb\"];_sqlite3_value_dup=Module[\"_sqlite3_value_dup\"]=wasmExports[\"Ib\"];_sqlite3_value_free=Module[\"_sqlite3_value_free\"]=wasmExports[\"Jb\"];_sqlite3_result_blob=Module[\"_sqlite3_result_blob\"]=wasmExports[\"Kb\"];_sqlite3_result_blob64=Module[\"_sqlite3_result_blob64\"]=wasmExports[\"Lb\"];_sqlite3_result_double=Module[\"_sqlite3_result_double\"]=wasmExports[\"Mb\"];_sqlite3_result_error=Module[\"_sqlite3_result_error\"]=wasmExports[\"Nb\"];_sqlite3_result_error16=Module[\"_sqlite3_result_error16\"]=wasmExports[\"Ob\"];_sqlite3_result_int=Module[\"_sqlite3_result_int\"]=wasmExports[\"Pb\"];_sqlite3_result_int64=Module[\"_sqlite3_result_int64\"]=wasmExports[\"Qb\"];_sqlite3_result_null=Module[\"_sqlite3_result_null\"]=wasmExports[\"Rb\"];_sqlite3_result_pointer=Module[\"_sqlite3_result_pointer\"]=wasmExports[\"Sb\"];_sqlite3_result_subtype=Module[\"_sqlite3_result_subtype\"]=wasmExports[\"Tb\"];_sqlite3_result_text=Module[\"_sqlite3_result_text\"]=wasmExports[\"Ub\"];_sqlite3_result_text64=Module[\"_sqlite3_result_text64\"]=wasmExports[\"Vb\"];_sqlite3_result_text16=Module[\"_sqlite3_result_text16\"]=wasmExports[\"Wb\"];_sqlite3_result_text16be=Module[\"_sqlite3_result_text16be\"]=wasmExports[\"Xb\"];_sqlite3_result_text16le=Module[\"_sqlite3_result_text16le\"]=wasmExports[\"Yb\"];_sqlite3_result_value=Module[\"_sqlite3_result_value\"]=wasmExports[\"Zb\"];_sqlite3_result_error_toobig=Module[\"_sqlite3_result_error_toobig\"]=wasmExports[\"_b\"];_sqlite3_result_zeroblob=Module[\"_sqlite3_result_zeroblob\"]=wasmExports[\"$b\"];_sqlite3_result_zeroblob64=Module[\"_sqlite3_result_zeroblob64\"]=wasmExports[\"ac\"];_sqlite3_result_error_code=Module[\"_sqlite3_result_error_code\"]=wasmExports[\"bc\"];_sqlite3_result_error_nomem=Module[\"_sqlite3_result_error_nomem\"]=wasmExports[\"cc\"];_sqlite3_user_data=Module[\"_sqlite3_user_data\"]=wasmExports[\"dc\"];_sqlite3_context_db_handle=Module[\"_sqlite3_context_db_handle\"]=wasmExports[\"ec\"];_sqlite3_vtab_nochange=Module[\"_sqlite3_vtab_nochange\"]=wasmExports[\"fc\"];_sqlite3_vtab_in_first=Module[\"_sqlite3_vtab_in_first\"]=wasmExports[\"gc\"];_sqlite3_vtab_in_next=Module[\"_sqlite3_vtab_in_next\"]=wasmExports[\"hc\"];_sqlite3_aggregate_context=Module[\"_sqlite3_aggregate_context\"]=wasmExports[\"ic\"];_sqlite3_get_auxdata=Module[\"_sqlite3_get_auxdata\"]=wasmExports[\"jc\"];_sqlite3_set_auxdata=Module[\"_sqlite3_set_auxdata\"]=wasmExports[\"kc\"];_sqlite3_column_count=Module[\"_sqlite3_column_count\"]=wasmExports[\"lc\"];_sqlite3_data_count=Module[\"_sqlite3_data_count\"]=wasmExports[\"mc\"];_sqlite3_column_blob=Module[\"_sqlite3_column_blob\"]=wasmExports[\"nc\"];_sqlite3_column_bytes=Module[\"_sqlite3_column_bytes\"]=wasmExports[\"oc\"];_sqlite3_column_bytes16=Module[\"_sqlite3_column_bytes16\"]=wasmExports[\"pc\"];_sqlite3_column_double=Module[\"_sqlite3_column_double\"]=wasmExports[\"qc\"];_sqlite3_column_text=Module[\"_sqlite3_column_text\"]=wasmExports[\"rc\"];_sqlite3_column_value=Module[\"_sqlite3_column_value\"]=wasmExports[\"sc\"];_sqlite3_column_text16=Module[\"_sqlite3_column_text16\"]=wasmExports[\"tc\"];_sqlite3_column_type=Module[\"_sqlite3_column_type\"]=wasmExports[\"uc\"];_sqlite3_column_name=Module[\"_sqlite3_column_name\"]=wasmExports[\"vc\"];_sqlite3_column_name16=Module[\"_sqlite3_column_name16\"]=wasmExports[\"wc\"];_sqlite3_bind_blob=Module[\"_sqlite3_bind_blob\"]=wasmExports[\"xc\"];_sqlite3_bind_blob64=Module[\"_sqlite3_bind_blob64\"]=wasmExports[\"yc\"];_sqlite3_bind_double=Module[\"_sqlite3_bind_double\"]=wasmExports[\"zc\"];_sqlite3_bind_int=Module[\"_sqlite3_bind_int\"]=wasmExports[\"Ac\"];_sqlite3_bind_int64=Module[\"_sqlite3_bind_int64\"]=wasmExports[\"Bc\"];_sqlite3_bind_null=Module[\"_sqlite3_bind_null\"]=wasmExports[\"Cc\"];_sqlite3_bind_pointer=Module[\"_sqlite3_bind_pointer\"]=wasmExports[\"Dc\"];_sqlite3_bind_text=Module[\"_sqlite3_bind_text\"]=wasmExports[\"Ec\"];_sqlite3_bind_text64=Module[\"_sqlite3_bind_text64\"]=wasmExports[\"Fc\"];_sqlite3_bind_text16=Module[\"_sqlite3_bind_text16\"]=wasmExports[\"Gc\"];_sqlite3_bind_value=Module[\"_sqlite3_bind_value\"]=wasmExports[\"Hc\"];_sqlite3_bind_zeroblob=Module[\"_sqlite3_bind_zeroblob\"]=wasmExports[\"Ic\"];_sqlite3_bind_zeroblob64=Module[\"_sqlite3_bind_zeroblob64\"]=wasmExports[\"Jc\"];_sqlite3_bind_parameter_count=Module[\"_sqlite3_bind_parameter_count\"]=wasmExports[\"Kc\"];_sqlite3_bind_parameter_name=Module[\"_sqlite3_bind_parameter_name\"]=wasmExports[\"Lc\"];_sqlite3_bind_parameter_index=Module[\"_sqlite3_bind_parameter_index\"]=wasmExports[\"Mc\"];_sqlite3_db_handle=Module[\"_sqlite3_db_handle\"]=wasmExports[\"Nc\"];_sqlite3_stmt_readonly=Module[\"_sqlite3_stmt_readonly\"]=wasmExports[\"Oc\"];_sqlite3_stmt_isexplain=Module[\"_sqlite3_stmt_isexplain\"]=wasmExports[\"Pc\"];_sqlite3_stmt_explain=Module[\"_sqlite3_stmt_explain\"]=wasmExports[\"Qc\"];_sqlite3_stmt_busy=Module[\"_sqlite3_stmt_busy\"]=wasmExports[\"Rc\"];_sqlite3_next_stmt=Module[\"_sqlite3_next_stmt\"]=wasmExports[\"Sc\"];_sqlite3_stmt_status=Module[\"_sqlite3_stmt_status\"]=wasmExports[\"Tc\"];_sqlite3_sql=Module[\"_sqlite3_sql\"]=wasmExports[\"Uc\"];_sqlite3_expanded_sql=Module[\"_sqlite3_expanded_sql\"]=wasmExports[\"Vc\"];_sqlite3_value_numeric_type=Module[\"_sqlite3_value_numeric_type\"]=wasmExports[\"Wc\"];_sqlite3_blob_open=Module[\"_sqlite3_blob_open\"]=wasmExports[\"Xc\"];_sqlite3_blob_close=Module[\"_sqlite3_blob_close\"]=wasmExports[\"Yc\"];_sqlite3_blob_read=Module[\"_sqlite3_blob_read\"]=wasmExports[\"Zc\"];_sqlite3_blob_write=Module[\"_sqlite3_blob_write\"]=wasmExports[\"_c\"];_sqlite3_blob_bytes=Module[\"_sqlite3_blob_bytes\"]=wasmExports[\"$c\"];_sqlite3_blob_reopen=Module[\"_sqlite3_blob_reopen\"]=wasmExports[\"ad\"];_sqlite3_set_authorizer=Module[\"_sqlite3_set_authorizer\"]=wasmExports[\"bd\"];_sqlite3_strglob=Module[\"_sqlite3_strglob\"]=wasmExports[\"cd\"];_sqlite3_strlike=Module[\"_sqlite3_strlike\"]=wasmExports[\"dd\"];_sqlite3_errmsg=Module[\"_sqlite3_errmsg\"]=wasmExports[\"ed\"];_sqlite3_load_extension=Module[\"_sqlite3_load_extension\"]=wasmExports[\"fd\"];_sqlite3_enable_load_extension=Module[\"_sqlite3_enable_load_extension\"]=wasmExports[\"gd\"];_sqlite3_auto_extension=Module[\"_sqlite3_auto_extension\"]=wasmExports[\"hd\"];_sqlite3_cancel_auto_extension=Module[\"_sqlite3_cancel_auto_extension\"]=wasmExports[\"id\"];_sqlite3_reset_auto_extension=Module[\"_sqlite3_reset_auto_extension\"]=wasmExports[\"jd\"];_sqlite3_prepare=Module[\"_sqlite3_prepare\"]=wasmExports[\"kd\"];_sqlite3_prepare_v3=Module[\"_sqlite3_prepare_v3\"]=wasmExports[\"ld\"];_sqlite3_prepare16=Module[\"_sqlite3_prepare16\"]=wasmExports[\"md\"];_sqlite3_prepare16_v2=Module[\"_sqlite3_prepare16_v2\"]=wasmExports[\"nd\"];_sqlite3_prepare16_v3=Module[\"_sqlite3_prepare16_v3\"]=wasmExports[\"od\"];_sqlite3_get_table=Module[\"_sqlite3_get_table\"]=wasmExports[\"pd\"];_sqlite3_free_table=Module[\"_sqlite3_free_table\"]=wasmExports[\"qd\"];_sqlite3_create_module=Module[\"_sqlite3_create_module\"]=wasmExports[\"rd\"];_sqlite3_create_module_v2=Module[\"_sqlite3_create_module_v2\"]=wasmExports[\"sd\"];_sqlite3_drop_modules=Module[\"_sqlite3_drop_modules\"]=wasmExports[\"td\"];_sqlite3_declare_vtab=Module[\"_sqlite3_declare_vtab\"]=wasmExports[\"ud\"];_sqlite3_vtab_on_conflict=Module[\"_sqlite3_vtab_on_conflict\"]=wasmExports[\"vd\"];_sqlite3_vtab_config=Module[\"_sqlite3_vtab_config\"]=wasmExports[\"wd\"];_sqlite3_vtab_collation=Module[\"_sqlite3_vtab_collation\"]=wasmExports[\"xd\"];_sqlite3_vtab_in=Module[\"_sqlite3_vtab_in\"]=wasmExports[\"yd\"];_sqlite3_vtab_rhs_value=Module[\"_sqlite3_vtab_rhs_value\"]=wasmExports[\"zd\"];_sqlite3_vtab_distinct=Module[\"_sqlite3_vtab_distinct\"]=wasmExports[\"Ad\"];_sqlite3_keyword_name=Module[\"_sqlite3_keyword_name\"]=wasmExports[\"Bd\"];_sqlite3_keyword_count=Module[\"_sqlite3_keyword_count\"]=wasmExports[\"Cd\"];_sqlite3_keyword_check=Module[\"_sqlite3_keyword_check\"]=wasmExports[\"Dd\"];_sqlite3_complete=Module[\"_sqlite3_complete\"]=wasmExports[\"Ed\"];_sqlite3_complete16=Module[\"_sqlite3_complete16\"]=wasmExports[\"Fd\"];_sqlite3_libversion=Module[\"_sqlite3_libversion\"]=wasmExports[\"Gd\"];_sqlite3_libversion_number=Module[\"_sqlite3_libversion_number\"]=wasmExports[\"Hd\"];_sqlite3_threadsafe=Module[\"_sqlite3_threadsafe\"]=wasmExports[\"Id\"];_sqlite3_initialize=Module[\"_sqlite3_initialize\"]=wasmExports[\"Jd\"];_sqlite3_shutdown=Module[\"_sqlite3_shutdown\"]=wasmExports[\"Kd\"];_sqlite3_config=Module[\"_sqlite3_config\"]=wasmExports[\"Ld\"];_sqlite3_db_mutex=Module[\"_sqlite3_db_mutex\"]=wasmExports[\"Md\"];_sqlite3_db_release_memory=Module[\"_sqlite3_db_release_memory\"]=wasmExports[\"Nd\"];_sqlite3_db_cacheflush=Module[\"_sqlite3_db_cacheflush\"]=wasmExports[\"Od\"];_sqlite3_db_config=Module[\"_sqlite3_db_config\"]=wasmExports[\"Pd\"];_sqlite3_last_insert_rowid=Module[\"_sqlite3_last_insert_rowid\"]=wasmExports[\"Qd\"];_sqlite3_set_last_insert_rowid=Module[\"_sqlite3_set_last_insert_rowid\"]=wasmExports[\"Rd\"];_sqlite3_changes64=Module[\"_sqlite3_changes64\"]=wasmExports[\"Sd\"];_sqlite3_changes=Module[\"_sqlite3_changes\"]=wasmExports[\"Td\"];_sqlite3_total_changes64=Module[\"_sqlite3_total_changes64\"]=wasmExports[\"Ud\"];_sqlite3_total_changes=Module[\"_sqlite3_total_changes\"]=wasmExports[\"Vd\"];_sqlite3_txn_state=Module[\"_sqlite3_txn_state\"]=wasmExports[\"Wd\"];_sqlite3_close=Module[\"_sqlite3_close\"]=wasmExports[\"Xd\"];_sqlite3_close_v2=Module[\"_sqlite3_close_v2\"]=wasmExports[\"Yd\"];_sqlite3_busy_handler=Module[\"_sqlite3_busy_handler\"]=wasmExports[\"Zd\"];_sqlite3_progress_handler=Module[\"_sqlite3_progress_handler\"]=wasmExports[\"_d\"];_sqlite3_busy_timeout=Module[\"_sqlite3_busy_timeout\"]=wasmExports[\"$d\"];_sqlite3_interrupt=Module[\"_sqlite3_interrupt\"]=wasmExports[\"ae\"];_sqlite3_is_interrupted=Module[\"_sqlite3_is_interrupted\"]=wasmExports[\"be\"];_sqlite3_create_function=Module[\"_sqlite3_create_function\"]=wasmExports[\"ce\"];_sqlite3_create_function_v2=Module[\"_sqlite3_create_function_v2\"]=wasmExports[\"de\"];_sqlite3_create_window_function=Module[\"_sqlite3_create_window_function\"]=wasmExports[\"ee\"];_sqlite3_create_function16=Module[\"_sqlite3_create_function16\"]=wasmExports[\"fe\"];_sqlite3_overload_function=Module[\"_sqlite3_overload_function\"]=wasmExports[\"ge\"];_sqlite3_trace_v2=Module[\"_sqlite3_trace_v2\"]=wasmExports[\"he\"];_sqlite3_commit_hook=Module[\"_sqlite3_commit_hook\"]=wasmExports[\"ie\"];_sqlite3_update_hook=Module[\"_sqlite3_update_hook\"]=wasmExports[\"je\"];_sqlite3_rollback_hook=Module[\"_sqlite3_rollback_hook\"]=wasmExports[\"ke\"];_sqlite3_autovacuum_pages=Module[\"_sqlite3_autovacuum_pages\"]=wasmExports[\"le\"];_sqlite3_wal_autocheckpoint=Module[\"_sqlite3_wal_autocheckpoint\"]=wasmExports[\"me\"];_sqlite3_wal_hook=Module[\"_sqlite3_wal_hook\"]=wasmExports[\"ne\"];_sqlite3_wal_checkpoint_v2=Module[\"_sqlite3_wal_checkpoint_v2\"]=wasmExports[\"oe\"];_sqlite3_wal_checkpoint=Module[\"_sqlite3_wal_checkpoint\"]=wasmExports[\"pe\"];_sqlite3_error_offset=Module[\"_sqlite3_error_offset\"]=wasmExports[\"qe\"];_sqlite3_errmsg16=Module[\"_sqlite3_errmsg16\"]=wasmExports[\"re\"];_sqlite3_errcode=Module[\"_sqlite3_errcode\"]=wasmExports[\"se\"];_sqlite3_extended_errcode=Module[\"_sqlite3_extended_errcode\"]=wasmExports[\"te\"];_sqlite3_system_errno=Module[\"_sqlite3_system_errno\"]=wasmExports[\"ue\"];_sqlite3_errstr=Module[\"_sqlite3_errstr\"]=wasmExports[\"ve\"];_sqlite3_limit=Module[\"_sqlite3_limit\"]=wasmExports[\"we\"];_sqlite3_open=Module[\"_sqlite3_open\"]=wasmExports[\"xe\"];_sqlite3_open_v2=Module[\"_sqlite3_open_v2\"]=wasmExports[\"ye\"];_sqlite3_open16=Module[\"_sqlite3_open16\"]=wasmExports[\"ze\"];_sqlite3_create_collation=Module[\"_sqlite3_create_collation\"]=wasmExports[\"Ae\"];_sqlite3_create_collation_v2=Module[\"_sqlite3_create_collation_v2\"]=wasmExports[\"Be\"];_sqlite3_create_collation16=Module[\"_sqlite3_create_collation16\"]=wasmExports[\"Ce\"];_sqlite3_collation_needed=Module[\"_sqlite3_collation_needed\"]=wasmExports[\"De\"];_sqlite3_collation_needed16=Module[\"_sqlite3_collation_needed16\"]=wasmExports[\"Ee\"];_sqlite3_get_clientdata=Module[\"_sqlite3_get_clientdata\"]=wasmExports[\"Fe\"];_sqlite3_set_clientdata=Module[\"_sqlite3_set_clientdata\"]=wasmExports[\"Ge\"];_sqlite3_get_autocommit=Module[\"_sqlite3_get_autocommit\"]=wasmExports[\"He\"];_sqlite3_table_column_metadata=Module[\"_sqlite3_table_column_metadata\"]=wasmExports[\"Ie\"];_sqlite3_sleep=Module[\"_sqlite3_sleep\"]=wasmExports[\"Je\"];_sqlite3_extended_result_codes=Module[\"_sqlite3_extended_result_codes\"]=wasmExports[\"Ke\"];_sqlite3_file_control=Module[\"_sqlite3_file_control\"]=wasmExports[\"Le\"];_sqlite3_test_control=Module[\"_sqlite3_test_control\"]=wasmExports[\"Me\"];_sqlite3_create_filename=Module[\"_sqlite3_create_filename\"]=wasmExports[\"Ne\"];_sqlite3_free_filename=Module[\"_sqlite3_free_filename\"]=wasmExports[\"Oe\"];_sqlite3_uri_parameter=Module[\"_sqlite3_uri_parameter\"]=wasmExports[\"Pe\"];_sqlite3_uri_key=Module[\"_sqlite3_uri_key\"]=wasmExports[\"Qe\"];_sqlite3_uri_boolean=Module[\"_sqlite3_uri_boolean\"]=wasmExports[\"Re\"];_sqlite3_uri_int64=Module[\"_sqlite3_uri_int64\"]=wasmExports[\"Se\"];_sqlite3_filename_database=Module[\"_sqlite3_filename_database\"]=wasmExports[\"Te\"];_sqlite3_filename_journal=Module[\"_sqlite3_filename_journal\"]=wasmExports[\"Ue\"];_sqlite3_filename_wal=Module[\"_sqlite3_filename_wal\"]=wasmExports[\"Ve\"];_sqlite3_db_name=Module[\"_sqlite3_db_name\"]=wasmExports[\"We\"];_sqlite3_db_filename=Module[\"_sqlite3_db_filename\"]=wasmExports[\"Xe\"];_sqlite3_db_readonly=Module[\"_sqlite3_db_readonly\"]=wasmExports[\"Ye\"];_sqlite3_compileoption_used=Module[\"_sqlite3_compileoption_used\"]=wasmExports[\"Ze\"];_sqlite3_compileoption_get=Module[\"_sqlite3_compileoption_get\"]=wasmExports[\"_e\"];_sqlite3_sourceid=Module[\"_sqlite3_sourceid\"]=wasmExports[\"$e\"];_memcmp=Module[\"_memcmp\"]=wasmExports[\"af\"];_malloc=Module[\"_malloc\"]=wasmExports[\"bf\"];_free=Module[\"_free\"]=wasmExports[\"cf\"];_RegisterExtensionFunctions=Module[\"_RegisterExtensionFunctions\"]=wasmExports[\"ef\"];_getSqliteFree=Module[\"_getSqliteFree\"]=wasmExports[\"ff\"];_main=Module[\"_main\"]=wasmExports[\"gf\"];_libauthorizer_set_authorizer=Module[\"_libauthorizer_set_authorizer\"]=wasmExports[\"hf\"];_libfunction_create_function=Module[\"_libfunction_create_function\"]=wasmExports[\"jf\"];_libhook_commit_hook=Module[\"_libhook_commit_hook\"]=wasmExports[\"kf\"];_libhook_update_hook=Module[\"_libhook_update_hook\"]=wasmExports[\"lf\"];_libprogress_progress_handler=Module[\"_libprogress_progress_handler\"]=wasmExports[\"mf\"];_libvfs_vfs_register=Module[\"_libvfs_vfs_register\"]=wasmExports[\"nf\"];_memcpy=Module[\"_memcpy\"]=wasmExports[\"of\"];_memset=Module[\"_memset\"]=wasmExports[\"pf\"];_emscripten_builtin_memalign=wasmExports[\"rf\"];__emscripten_timeout=wasmExports[\"sf\"];__emscripten_tempret_get=wasmExports[\"tf\"];__emscripten_stack_restore=wasmExports[\"uf\"];__emscripten_stack_alloc=wasmExports[\"vf\"];_emscripten_stack_get_current=wasmExports[\"wf\"];dynCall_iii=dynCalls[\"iii\"]=wasmExports[\"xf\"];dynCall_viiiij=dynCalls[\"viiiij\"]=wasmExports[\"yf\"];dynCall_ii=dynCalls[\"ii\"]=wasmExports[\"zf\"];dynCall_vi=dynCalls[\"vi\"]=wasmExports[\"Af\"];dynCall_iiii=dynCalls[\"iiii\"]=wasmExports[\"Bf\"];dynCall_viii=dynCalls[\"viii\"]=wasmExports[\"Cf\"];dynCall_iiiiiii=dynCalls[\"iiiiiii\"]=wasmExports[\"Df\"];dynCall_iiiiii=dynCalls[\"iiiiii\"]=wasmExports[\"Ef\"];dynCall_iiiii=dynCalls[\"iiiii\"]=wasmExports[\"Ff\"];dynCall_vii=dynCalls[\"vii\"]=wasmExports[\"Gf\"];dynCall_viiii=dynCalls[\"viiii\"]=wasmExports[\"Hf\"];dynCall_iiiiiiiii=dynCalls[\"iiiiiiiii\"]=wasmExports[\"If\"];dynCall_vijii=dynCalls[\"vijii\"]=wasmExports[\"Jf\"];dynCall_viiiii=dynCalls[\"viiiii\"]=wasmExports[\"Kf\"];dynCall_iiiij=dynCalls[\"iiiij\"]=wasmExports[\"Lf\"];dynCall_viji=dynCalls[\"viji\"]=wasmExports[\"Mf\"];dynCall_iij=dynCalls[\"iij\"]=wasmExports[\"Nf\"];dynCall_iidiiii=dynCalls[\"iidiiii\"]=wasmExports[\"Of\"];dynCall_iijii=dynCalls[\"iijii\"]=wasmExports[\"Pf\"];dynCall_iiji=dynCalls[\"iiji\"]=wasmExports[\"Qf\"];dynCall_i=dynCalls[\"i\"]=wasmExports[\"Rf\"];dynCall_iiiiiij=dynCalls[\"iiiiiij\"]=wasmExports[\"Sf\"];dynCall_iiid=dynCalls[\"iiid\"]=wasmExports[\"Tf\"];dynCall_iiij=dynCalls[\"iiij\"]=wasmExports[\"Uf\"];dynCall_dii=dynCalls[\"dii\"]=wasmExports[\"Vf\"];dynCall_jii=dynCalls[\"jii\"]=wasmExports[\"Wf\"];dynCall_ji=dynCalls[\"ji\"]=wasmExports[\"Xf\"];dynCall_vid=dynCalls[\"vid\"]=wasmExports[\"Yf\"];dynCall_vij=dynCalls[\"vij\"]=wasmExports[\"Zf\"];dynCall_iiiiiiiiii=dynCalls[\"iiiiiiiiii\"]=wasmExports[\"_f\"];dynCall_di=dynCalls[\"di\"]=wasmExports[\"$f\"];dynCall_iiiiijii=dynCalls[\"iiiiijii\"]=wasmExports[\"ag\"];dynCall_j=dynCalls[\"j\"]=wasmExports[\"bg\"];dynCall_jj=dynCalls[\"jj\"]=wasmExports[\"cg\"];dynCall_jiij=dynCalls[\"jiij\"]=wasmExports[\"dg\"];dynCall_iiiiji=dynCalls[\"iiiiji\"]=wasmExports[\"eg\"];dynCall_iiiijii=dynCalls[\"iiiijii\"]=wasmExports[\"fg\"];dynCall_ij=dynCalls[\"ij\"]=wasmExports[\"gg\"];dynCall_v=dynCalls[\"v\"]=wasmExports[\"hg\"];dynCall_viiji=dynCalls[\"viiji\"]=wasmExports[\"ig\"];dynCall_viijii=dynCalls[\"viijii\"]=wasmExports[\"jg\"];dynCall_iiiiiiiiiii=dynCalls[\"iiiiiiiiiii\"]=wasmExports[\"kg\"];dynCall_iiiijji=dynCalls[\"iiiijji\"]=wasmExports[\"lg\"];dynCall_iiiiiiii=dynCalls[\"iiiiiiii\"]=wasmExports[\"mg\"];_asyncify_start_unwind=wasmExports[\"ng\"];_asyncify_stop_unwind=wasmExports[\"og\"];_asyncify_start_rewind=wasmExports[\"pg\"];_asyncify_stop_rewind=wasmExports[\"qg\"];memory=wasmMemory=wasmExports[\"pa\"];_sqlite3_version=Module[\"_sqlite3_version\"]=wasmExports[\"df\"].value;__indirect_function_table=wasmTable=wasmExports[\"qf\"]}var wasmImports={a:___assert_fail,aa:___syscall_chmod,da:___syscall_faccessat,ba:___syscall_fchmod,$:___syscall_fchown32,b:___syscall_fcntl64,_:___syscall_fstat64,y:___syscall_ftruncate64,U:___syscall_getcwd,Y:___syscall_lstat64,R:___syscall_mkdirat,X:___syscall_newfstatat,P:___syscall_openat,N:___syscall_readlinkat,M:___syscall_rmdir,Z:___syscall_stat64,K:___syscall_unlinkat,J:___syscall_utimensat,F:__abort_js,E:__emscripten_runtime_keepalive_clear,w:__localtime_js,u:__mmap_js,v:__munmap_js,G:__setitimer_js,Q:__tzset_js,n:_emscripten_date_now,g:_emscripten_get_now,H:_emscripten_resize_heap,S:_environ_get,T:_environ_sizes_get,o:_fd_close,I:_fd_fdstat_get,O:_fd_read,x:_fd_seek,V:_fd_sync,L:_fd_write,s:_ipp,t:_ipp_async,ka:_ippipppp,oa:_ippipppp_async,j:_ippp,k:_ippp_async,c:_ipppi,d:_ipppi_async,ga:_ipppiii,ha:_ipppiii_async,ia:_ipppiiip,ja:_ipppiiip_async,h:_ipppip,i:_ipppip_async,z:_ipppj,A:_ipppj_async,e:_ipppp,f:_ipppp_async,ea:_ippppi,fa:_ippppi_async,B:_ippppij,C:_ippppij_async,p:_ippppip,q:_ippppip_async,la:_ipppppip,ma:_ipppppip_async,D:_proc_exit,na:_vppippii,r:_vppippii_async,l:_vppp,m:_vppp_async,W:_vpppip,ca:_vpppip_async};function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){dependenciesFulfilled=run;return}preRun();if(runDependencies>0){dependenciesFulfilled=run;return}function doRun(){Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve?.(Module);Module[\"onRuntimeInitialized\"]?.();var noInitialRun=Module[\"noInitialRun\"]||false;if(!noInitialRun)callMain();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(()=>{setTimeout(()=>Module[\"setStatus\"](\"\"),1);doRun()},1)}else{doRun()}}var wasmExports;wasmExports=await (createWasm());run();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"set_authorizer\"]=function(db,xAuthorizer,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xAuthorizer instanceof AsyncFunction?1:0,\"i32\");const result=ccall(\"libauthorizer_set_authorizer\",\"number\",[\"number\",\"number\",\"number\"],[db,xAuthorizer?1:0,pAsyncFlags]);if(!result&&xAuthorizer){Module[\"setCallback\"](pAsyncFlags,(_,iAction,p3,p4,p5,p6)=>xAuthorizer(pApp,iAction,p3,p4,p5,p6))}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;const FUNC_METHODS=[\"xFunc\",\"xStep\",\"xFinal\"];const mapFunctionNameToKey=new Map;Module[\"create_function\"]=function(db,zFunctionName,nArg,eTextRep,pApp,xFunc,xStep,xFinal){const pAsyncFlags=Module[\"_sqlite3_malloc\"](4);const target={xFunc,xStep,xFinal};setValue(pAsyncFlags,FUNC_METHODS.reduce((mask,method,i)=>{if(target[method]instanceof AsyncFunction){return mask|1<<i}return mask},0),\"i32\");const result=ccall(\"libfunction_create_function\",\"number\",[\"number\",\"string\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"],[db,zFunctionName,nArg,eTextRep,pAsyncFlags,xFunc?1:0,xStep?1:0,xFinal?1:0]);if(!result){if(mapFunctionNameToKey.has(zFunctionName)){const oldKey=mapFunctionNameToKey.get(zFunctionName);Module[\"deleteCallback\"](oldKey)}mapFunctionNameToKey.set(zFunctionName,pAsyncFlags);Module[\"setCallback\"](pAsyncFlags,{xFunc,xStep,xFinal})}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"update_hook\"]=function(db,xUpdateHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xUpdateHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_update_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xUpdateHook?1:0,pAsyncFlags]);if(xUpdateHook){Module[\"setCallback\"](pAsyncFlags,(_,iUpdateType,dbName,tblName,lo32,hi32)=>xUpdateHook(iUpdateType,dbName,tblName,lo32,hi32))}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"commit_hook\"]=function(db,xCommitHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xCommitHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_commit_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xCommitHook?1:0,pAsyncFlags]);if(xCommitHook){Module[\"setCallback\"](pAsyncFlags,_=>xCommitHook())}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"progress_handler\"]=function(db,nOps,xProgress,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xProgress instanceof AsyncFunction?1:0,\"i32\");ccall(\"libprogress_progress_handler\",\"number\",[\"number\",\"number\",\"number\",\"number\"],[db,nOps,xProgress?1:0,pAsyncFlags]);if(xProgress){Module[\"setCallback\"](pAsyncFlags,_=>xProgress(pApp))}}})();(function(){const VFS_METHODS=[\"xOpen\",\"xDelete\",\"xAccess\",\"xFullPathname\",\"xRandomness\",\"xSleep\",\"xCurrentTime\",\"xGetLastError\",\"xCurrentTimeInt64\",\"xClose\",\"xRead\",\"xWrite\",\"xTruncate\",\"xSync\",\"xFileSize\",\"xLock\",\"xUnlock\",\"xCheckReservedLock\",\"xFileControl\",\"xSectorSize\",\"xDeviceCharacteristics\",\"xShmMap\",\"xShmLock\",\"xShmBarrier\",\"xShmUnmap\"];const mapVFSNameToKey=new Map;Module[\"vfs_register\"]=function(vfs,makeDefault){let methodMask=0;let asyncMask=0;VFS_METHODS.forEach((method,i)=>{if(vfs[method]){methodMask|=1<<i;if(vfs[\"hasAsyncMethod\"](method)){asyncMask|=1<<i}}});const vfsReturn=Module[\"_sqlite3_malloc\"](4);try{const result=ccall(\"libvfs_vfs_register\",\"number\",[\"string\",\"number\",\"number\",\"number\",\"number\",\"number\"],[vfs.name,vfs.mxPathname,methodMask,asyncMask,makeDefault?1:0,vfsReturn]);if(!result){if(mapVFSNameToKey.has(vfs.name)){const oldKey=mapVFSNameToKey.get(vfs.name);Module[\"deleteCallback\"](oldKey)}const key=getValue(vfsReturn,\"*\");mapVFSNameToKey.set(vfs.name,key);Module[\"setCallback\"](key,vfs)}return result}finally{Module[\"_sqlite3_free\"](vfsReturn)}}})();if(runtimeInitialized){moduleRtn=Module}else{moduleRtn=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject})}\n;return moduleRtn}export default Module;\n","async function Module(moduleArg={}){var moduleRtn;var Module=moduleArg;var ENVIRONMENT_IS_WEB=!!globalThis.window;var ENVIRONMENT_IS_WORKER=!!globalThis.WorkerGlobalScope;var ENVIRONMENT_IS_NODE=globalThis.process?.versions?.node&&globalThis.process?.type!=\"renderer\";var arguments_=[];var thisProgram=\"./this.program\";var quit_=(status,toThrow)=>{throw toThrow};var _scriptName=import.meta.url;var scriptDirectory=\"\";function locateFile(path){if(Module[\"locateFile\"]){return Module[\"locateFile\"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){try{scriptDirectory=new URL(\".\",_scriptName).href}catch{}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);xhr.responseType=\"arraybuffer\";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=async url=>{var response=await fetch(url,{credentials:\"same-origin\"});if(response.ok){return response.arrayBuffer()}throw new Error(response.status+\" : \"+response.url)}}}else{}var out=console.log.bind(console);var err=console.error.bind(console);var wasmBinary;var ABORT=false;var EXITSTATUS;var readyPromiseResolve,readyPromiseReject;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var runtimeInitialized=false;function updateMemoryViews(){var b=wasmMemory.buffer;HEAP8=new Int8Array(b);HEAP16=new Int16Array(b);Module[\"HEAPU8\"]=HEAPU8=new Uint8Array(b);HEAPU16=new Uint16Array(b);Module[\"HEAP32\"]=HEAP32=new Int32Array(b);HEAPU32=new Uint32Array(b);HEAPF32=new Float32Array(b);HEAPF64=new Float64Array(b)}function preRun(){if(Module[\"preRun\"]){if(typeof Module[\"preRun\"]==\"function\")Module[\"preRun\"]=[Module[\"preRun\"]];while(Module[\"preRun\"].length){addOnPreRun(Module[\"preRun\"].shift())}}callRuntimeCallbacks(onPreRuns)}function initRuntime(){runtimeInitialized=true;if(!Module[\"noFSInit\"]&&!FS.initialized)FS.init();TTY.init();wasmExports[\"qa\"]();FS.ignorePermissions=false}function preMain(){}function postRun(){if(Module[\"postRun\"]){if(typeof Module[\"postRun\"]==\"function\")Module[\"postRun\"]=[Module[\"postRun\"]];while(Module[\"postRun\"].length){addOnPostRun(Module[\"postRun\"].shift())}}callRuntimeCallbacks(onPostRuns)}function abort(what){Module[\"onAbort\"]?.(what);what=\"Aborted(\"+what+\")\";err(what);ABORT=true;what+=\". Build with -sASSERTIONS for more info.\";var e=new WebAssembly.RuntimeError(what);readyPromiseReject?.(e);throw e}var wasmBinaryFile;function findWasmBinary(){if(Module[\"locateFile\"]){return locateFile(\"wa-sqlite.wasm\")}return new URL(\"wa-sqlite.wasm\",import.meta.url).href}function getBinarySync(file){if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw\"both async and sync fetching of the wasm failed\"}async function getWasmBinary(binaryFile){if(!wasmBinary){try{var response=await readAsync(binaryFile);return new Uint8Array(response)}catch{}}return getBinarySync(binaryFile)}async function instantiateArrayBuffer(binaryFile,imports){try{var binary=await getWasmBinary(binaryFile);var instance=await WebAssembly.instantiate(binary,imports);return instance}catch(reason){err(`failed to asynchronously prepare wasm: ${reason}`);abort(reason)}}async function instantiateAsync(binary,binaryFile,imports){if(!binary){try{var response=fetch(binaryFile,{credentials:\"same-origin\"});var instantiationResult=await WebAssembly.instantiateStreaming(response,imports);return instantiationResult}catch(reason){err(`wasm streaming compile failed: ${reason}`);err(\"falling back to ArrayBuffer instantiation\")}}return instantiateArrayBuffer(binaryFile,imports)}function getWasmImports(){var imports={a:wasmImports};return imports}async function createWasm(){function receiveInstance(instance,module){wasmExports=instance.exports;assignWasmExports(wasmExports);updateMemoryViews();return wasmExports}function receiveInstantiationResult(result){return receiveInstance(result[\"instance\"])}var info=getWasmImports();if(Module[\"instantiateWasm\"]){return new Promise((resolve,reject)=>{Module[\"instantiateWasm\"](info,(inst,mod)=>{resolve(receiveInstance(inst,mod))})})}wasmBinaryFile??=findWasmBinary();var result=await instantiateAsync(wasmBinary,wasmBinaryFile,info);var exports=receiveInstantiationResult(result);return exports}var tempDouble;var tempI64;class ExitStatus{name=\"ExitStatus\";constructor(status){this.message=`Program terminated with exit(${status})`;this.status=status}}var callRuntimeCallbacks=callbacks=>{while(callbacks.length>0){callbacks.shift()(Module)}};var onPostRuns=[];var addOnPostRun=cb=>onPostRuns.push(cb);var onPreRuns=[];var addOnPreRun=cb=>onPreRuns.push(cb);function getValue(ptr,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":return HEAP8[ptr];case\"i8\":return HEAP8[ptr];case\"i16\":return HEAP16[ptr>>1];case\"i32\":return HEAP32[ptr>>2];case\"i64\":abort(\"to do getValue(i64) use WASM_BIGINT\");case\"float\":return HEAPF32[ptr>>2];case\"double\":return HEAPF64[ptr>>3];case\"*\":return HEAPU32[ptr>>2];default:abort(`invalid type for getValue: ${type}`)}}var noExitRuntime=true;function setValue(ptr,value,type=\"i8\"){if(type.endsWith(\"*\"))type=\"*\";switch(type){case\"i1\":HEAP8[ptr]=value;break;case\"i8\":HEAP8[ptr]=value;break;case\"i16\":HEAP16[ptr>>1]=value;break;case\"i32\":HEAP32[ptr>>2]=value;break;case\"i64\":abort(\"to do setValue(i64) use WASM_BIGINT\");case\"float\":HEAPF32[ptr>>2]=value;break;case\"double\":HEAPF64[ptr>>3]=value;break;case\"*\":HEAPU32[ptr>>2]=value;break;default:abort(`invalid type for setValue: ${type}`)}}var stackRestore=val=>__emscripten_stack_restore(val);var stackSave=()=>_emscripten_stack_get_current();var UTF8Decoder=new TextDecoder;var findStringEnd=(heapOrArray,idx,maxBytesToRead,ignoreNul)=>{var maxIdx=idx+maxBytesToRead;if(ignoreNul)return maxIdx;while(heapOrArray[idx]&&!(idx>=maxIdx))++idx;return idx};var UTF8ToString=(ptr,maxBytesToRead,ignoreNul)=>{if(!ptr)return\"\";var end=findStringEnd(HEAPU8,ptr,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(HEAPU8.subarray(ptr,end))};var ___assert_fail=(condition,filename,line,func)=>abort(`Assertion failed: ${UTF8ToString(condition)}, at: `+[filename?UTF8ToString(filename):\"unknown filename\",line,func?UTF8ToString(func):\"unknown function\"]);var PATH={isAbs:path=>path.charAt(0)===\"/\",splitPath:filename=>{var splitPathRe=/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===\".\"){parts.splice(i,1)}else if(last===\"..\"){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift(\"..\")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.slice(-1)===\"/\";path=PATH.normalizeArray(path.split(\"/\").filter(p=>!!p),!isAbsolute).join(\"/\");if(!path&&!isAbsolute){path=\".\"}if(path&&trailingSlash){path+=\"/\"}return(isAbsolute?\"/\":\"\")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return\".\"}if(dir){dir=dir.slice(0,-1)}return root+dir},basename:path=>path&&path.match(/([^\\/]+|\\/)\\/*$/)[1],join:(...paths)=>PATH.normalize(paths.join(\"/\")),join2:(l,r)=>PATH.normalize(l+\"/\"+r)};var initRandomFill=()=>view=>crypto.getRandomValues(view);var randomFill=view=>{(randomFill=initRandomFill())(view)};var PATH_FS={resolve:(...args)=>{var resolvedPath=\"\",resolvedAbsolute=false;for(var i=args.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?args[i]:FS.cwd();if(typeof path!=\"string\"){throw new TypeError(\"Arguments to path.resolve must be strings\")}else if(!path){return\"\"}resolvedPath=path+\"/\"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split(\"/\").filter(p=>!!p),!resolvedAbsolute).join(\"/\");return(resolvedAbsolute?\"/\":\"\")+resolvedPath||\".\"},relative:(from,to)=>{from=PATH_FS.resolve(from).slice(1);to=PATH_FS.resolve(to).slice(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!==\"\")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!==\"\")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split(\"/\"));var toParts=trim(to.split(\"/\"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push(\"..\")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join(\"/\")}};var UTF8ArrayToString=(heapOrArray,idx=0,maxBytesToRead,ignoreNul)=>{var endPtr=findStringEnd(heapOrArray,idx,maxBytesToRead,ignoreNul);return UTF8Decoder.decode(heapOrArray.buffer?heapOrArray.subarray(idx,endPtr):new Uint8Array(heapOrArray.slice(idx,endPtr)))};var FS_stdin_getChar_buffer=[];var lengthBytesUTF8=str=>{var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len};var stringToUTF8Array=(str,heap,outIdx,maxBytesToWrite)=>{if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.codePointAt(i);if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;i++}}heap[outIdx]=0;return outIdx-startIdx};var intArrayFromString=(stringy,dontAddNull,length)=>{var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array};var FS_stdin_getChar=()=>{if(!FS_stdin_getChar_buffer.length){var result=null;if(globalThis.window?.prompt){result=window.prompt(\"Input: \");if(result!==null){result+=\"\\n\"}}else{}if(!result){return null}FS_stdin_getChar_buffer=intArrayFromString(result,true)}return FS_stdin_getChar_buffer.shift()};var TTY={ttys:[],init(){},shutdown(){},register(dev,ops){TTY.ttys[dev]={input:[],output:[],ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close(stream){stream.tty.ops.fsync(stream.tty)},fsync(stream){stream.tty.ops.fsync(stream.tty)},read(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}},default_tty_ops:{get_char(tty){return FS_stdin_getChar()},put_char(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){out(UTF8ArrayToString(tty.output));tty.output=[]}},ioctl_tcgets(tty){return{c_iflag:25856,c_oflag:5,c_cflag:191,c_lflag:35387,c_cc:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},ioctl_tcsets(tty,optional_actions,data){return 0},ioctl_tiocgwinsz(tty){return[24,80]}},default_tty1_ops:{put_char(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync(tty){if(tty.output?.length>0){err(UTF8ArrayToString(tty.output));tty.output=[]}}}};var zeroMemory=(ptr,size)=>HEAPU8.fill(0,ptr,ptr+size);var alignMemory=(size,alignment)=>Math.ceil(size/alignment)*alignment;var mmapAlloc=size=>{size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(ptr)zeroMemory(ptr,size);return ptr};var MEMFS={ops_table:null,mount(mount){return MEMFS.createNode(null,\"/\",16895,0)},createNode(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}MEMFS.ops_table||={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.atime=node.mtime=node.ctime=Date.now();if(parent){parent.contents[name]=node;parent.atime=parent.mtime=parent.ctime=node.atime}return node},getFileDataAsTypedArray(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.atime);attr.mtime=new Date(node.mtime);attr.ctime=new Date(node.ctime);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr(node,attr){for(const key of[\"mode\",\"atime\",\"mtime\",\"ctime\"]){if(attr[key]!=null){node[key]=attr[key]}}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup(parent,name){if(!MEMFS.doesNotExistError){MEMFS.doesNotExistError=new FS.ErrnoError(44);MEMFS.doesNotExistError.stack=\"<generic error, no stack>\"}throw MEMFS.doesNotExistError},mknod(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename(old_node,new_dir,new_name){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){if(FS.isDir(old_node.mode)){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}FS.hashRemoveNode(new_node)}delete old_node.parent.contents[old_node.name];new_dir.contents[new_name]=old_node;old_node.name=new_name;new_dir.ctime=new_dir.mtime=old_node.parent.ctime=old_node.parent.mtime=Date.now()},unlink(parent,name){delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},rmdir(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.ctime=parent.mtime=Date.now()},readdir(node){return[\".\",\"..\",...Object.keys(node.contents)]},symlink(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.mtime=node.ctime=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},mmap(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents&&contents.buffer===HEAP8.buffer){allocated=false;ptr=contents.byteOffset}else{allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}if(contents){if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}HEAP8.set(contents,ptr)}}return{ptr,allocated}},msync(stream,buffer,offset,length,mmapFlags){MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var FS_modeStringToFlags=str=>{var flagModes={r:0,\"r+\":2,w:512|64|1,\"w+\":512|64|2,a:1024|64|1,\"a+\":1024|64|2};var flags=flagModes[str];if(typeof flags==\"undefined\"){throw new Error(`Unknown file open mode: ${str}`)}return flags};var FS_getMode=(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode};var asyncLoad=async url=>{var arrayBuffer=await readAsync(url);return new Uint8Array(arrayBuffer)};var FS_createDataFile=(...args)=>FS.createDataFile(...args);var getUniqueRunDependency=id=>id;var runDependencies=0;var dependenciesFulfilled=null;var removeRunDependency=id=>{runDependencies--;Module[\"monitorRunDependencies\"]?.(runDependencies);if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}};var addRunDependency=id=>{runDependencies++;Module[\"monitorRunDependencies\"]?.(runDependencies)};var preloadPlugins=[];var FS_handledByPreloadPlugin=async(byteArray,fullname)=>{if(typeof Browser!=\"undefined\")Browser.init();for(var plugin of preloadPlugins){if(plugin[\"canHandle\"](fullname)){return plugin[\"handle\"](byteArray,fullname)}}return byteArray};var FS_preloadFile=async(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency(`cp ${fullname}`);addRunDependency(dep);try{var byteArray=url;if(typeof url==\"string\"){byteArray=await asyncLoad(url)}byteArray=await FS_handledByPreloadPlugin(byteArray,fullname);preFinish?.();if(!dontCreateFile){FS_createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}}finally{removeRunDependency(dep)}};var FS_createPreloadedFile=(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{FS_preloadFile(parent,name,url,canRead,canWrite,dontCreateFile,canOwn,preFinish).then(onload).catch(onerror)};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:\"/\",initialized:false,ignorePermissions:true,filesystems:null,syncFSRequests:0,ErrnoError:class{name=\"ErrnoError\";constructor(errno){this.errno=errno}},FSStream:class{shared={};get object(){return this.node}set object(val){this.node=val}get isRead(){return(this.flags&2097155)!==1}get isWrite(){return(this.flags&2097155)!==0}get isAppend(){return this.flags&1024}get flags(){return this.shared.flags}set flags(val){this.shared.flags=val}get position(){return this.shared.position}set position(val){this.shared.position=val}},FSNode:class{node_ops={};stream_ops={};readMode=292|73;writeMode=146;mounted=null;constructor(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.rdev=rdev;this.atime=this.mtime=this.ctime=Date.now()}get read(){return(this.mode&this.readMode)===this.readMode}set read(val){val?this.mode|=this.readMode:this.mode&=~this.readMode}get write(){return(this.mode&this.writeMode)===this.writeMode}set write(val){val?this.mode|=this.writeMode:this.mode&=~this.writeMode}get isFolder(){return FS.isDir(this.mode)}get isDevice(){return FS.isChrdev(this.mode)}},lookupPath(path,opts={}){if(!path){throw new FS.ErrnoError(44)}opts.follow_mount??=true;if(!PATH.isAbs(path)){path=FS.cwd()+\"/\"+path}linkloop:for(var nlinks=0;nlinks<40;nlinks++){var parts=path.split(\"/\").filter(p=>!!p);var current=FS.root;var current_path=\"/\";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}if(parts[i]===\".\"){continue}if(parts[i]===\"..\"){current_path=PATH.dirname(current_path);if(FS.isRoot(current)){path=current_path+\"/\"+parts.slice(i+1).join(\"/\");nlinks--;continue linkloop}else{current=current.parent}continue}current_path=PATH.join2(current_path,parts[i]);try{current=FS.lookupNode(current,parts[i])}catch(e){if(e?.errno===44&&islast&&opts.noent_okay){return{path:current_path}}throw e}if(FS.isMountpoint(current)&&(!islast||opts.follow_mount)){current=current.mounted.root}if(FS.isLink(current.mode)&&(!islast||opts.follow)){if(!current.node_ops.readlink){throw new FS.ErrnoError(52)}var link=current.node_ops.readlink(current);if(!PATH.isAbs(link)){link=PATH.dirname(current_path)+\"/\"+link}path=link+\"/\"+parts.slice(i+1).join(\"/\");continue linkloop}}return{path:current_path,node:current}}throw new FS.ErrnoError(32)},getPath(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!==\"/\"?`${mount}/${path}`:mount+path}path=path?`${node.name}/${path}`:node.name;node=node.parent}},hashName(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode(parent,name){var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode(parent,name,mode,rdev){var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode(node){FS.hashRemoveNode(node)},isRoot(node){return node===node.parent},isMountpoint(node){return!!node.mounted},isFile(mode){return(mode&61440)===32768},isDir(mode){return(mode&61440)===16384},isLink(mode){return(mode&61440)===40960},isChrdev(mode){return(mode&61440)===8192},isBlkdev(mode){return(mode&61440)===24576},isFIFO(mode){return(mode&61440)===4096},isSocket(mode){return(mode&49152)===49152},flagsToPermissionString(flag){var perms=[\"r\",\"w\",\"rw\"][flag&3];if(flag&512){perms+=\"w\"}return perms},nodePermissions(node,perms){if(FS.ignorePermissions){return 0}if(perms.includes(\"r\")&&!(node.mode&292)){return 2}if(perms.includes(\"w\")&&!(node.mode&146)){return 2}if(perms.includes(\"x\")&&!(node.mode&73)){return 2}return 0},mayLookup(dir){if(!FS.isDir(dir.mode))return 54;var errCode=FS.nodePermissions(dir,\"x\");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate(dir,name){if(!FS.isDir(dir.mode)){return 54}try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,\"wx\")},mayDelete(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,\"wx\");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else if(FS.isDir(node.mode)){return 31}return 0},mayOpen(node,flags){if(!node){return 44}if(FS.isLink(node.mode)){return 32}var mode=FS.flagsToPermissionString(flags);if(FS.isDir(node.mode)){if(mode!==\"r\"||flags&(512|64)){return 31}}return FS.nodePermissions(node,mode)},checkOpExists(op,err){if(!op){throw new FS.ErrnoError(err)}return op},MAX_OPEN_FDS:4096,nextfd(){for(var fd=0;fd<=FS.MAX_OPEN_FDS;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStreamChecked(fd){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}return stream},getStream:fd=>FS.streams[fd],createStream(stream,fd=-1){stream=Object.assign(new FS.FSStream,stream);if(fd==-1){fd=FS.nextfd()}stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream(fd){FS.streams[fd]=null},dupStream(origStream,fd=-1){var stream=FS.createStream(origStream,fd);stream.stream_ops?.dup?.(stream);return stream},doSetAttr(stream,node,attr){var setattr=stream?.stream_ops.setattr;var arg=setattr?stream:node;setattr??=node.node_ops.setattr;FS.checkOpExists(setattr,63);setattr(arg,attr)},chrdev_stream_ops:{open(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;stream.stream_ops.open?.(stream)},llseek(){throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push(...m.mounts)}return mounts},syncfs(populate,callback){if(typeof populate==\"function\"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`)}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}for(var mount of mounts){if(mount.type.syncfs){mount.type.syncfs(mount,populate,done)}else{done(null)}}},mount(type,opts,mountpoint){var root=mountpoint===\"/\";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type,opts,mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);for(var[hash,current]of Object.entries(FS.nameTable)){while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}}node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup(parent,name){return parent.node_ops.lookup(parent,name)},mknod(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name){throw new FS.ErrnoError(28)}if(name===\".\"||name===\"..\"){throw new FS.ErrnoError(20)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},statfs(path){return FS.statfsNode(FS.lookupPath(path,{follow:true}).node)},statfsStream(stream){return FS.statfsNode(stream.node)},statfsNode(node){var rtn={bsize:4096,frsize:4096,blocks:1e6,bfree:5e5,bavail:5e5,files:FS.nextInode,ffree:FS.nextInode-1,fsid:42,flags:2,namelen:255};if(node.node_ops.statfs){Object.assign(rtn,node.node_ops.statfs(node.mount.opts.root))}return rtn},create(path,mode=438){mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir(path,mode=511){mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree(path,mode){var dirs=path.split(\"/\");var d=\"\";for(var dir of dirs){if(!dir)continue;if(d||PATH.isAbs(path))d+=\"/\";d+=dir;try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev(path,mode,dev){if(typeof dev==\"undefined\"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink(oldpath,newpath){if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!==\".\"){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name);old_node.parent=new_dir}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var readdir=FS.checkOpExists(node.node_ops.readdir,54);return readdir(node)},unlink(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return link.node_ops.readlink(link)},stat(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;var getattr=FS.checkOpExists(node.node_ops.getattr,63);return getattr(node)},fstat(fd){var stream=FS.getStreamChecked(fd);var node=stream.node;var getattr=stream.stream_ops.getattr;var arg=getattr?stream:node;getattr??=node.node_ops.getattr;FS.checkOpExists(getattr,63);return getattr(arg)},lstat(path){return FS.stat(path,true)},doChmod(stream,node,mode,dontFollow){FS.doSetAttr(stream,node,{mode:mode&4095|node.mode&~4095,ctime:Date.now(),dontFollow})},chmod(path,mode,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChmod(null,node,mode,dontFollow)},lchmod(path,mode){FS.chmod(path,mode,true)},fchmod(fd,mode){var stream=FS.getStreamChecked(fd);FS.doChmod(stream,stream.node,mode,false)},doChown(stream,node,dontFollow){FS.doSetAttr(stream,node,{timestamp:Date.now(),dontFollow})},chown(path,uid,gid,dontFollow){var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}FS.doChown(null,node,dontFollow)},lchown(path,uid,gid){FS.chown(path,uid,gid,true)},fchown(fd,uid,gid){var stream=FS.getStreamChecked(fd);FS.doChown(stream,stream.node,false)},doTruncate(stream,node,len){if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,\"w\");if(errCode){throw new FS.ErrnoError(errCode)}FS.doSetAttr(stream,node,{size:len,timestamp:Date.now()})},truncate(path,len){if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path==\"string\"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}FS.doTruncate(null,node,len)},ftruncate(fd,len){var stream=FS.getStreamChecked(fd);if(len<0||(stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.doTruncate(stream,stream.node,len)},utime(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;var setattr=FS.checkOpExists(node.node_ops.setattr,63);setattr(node,{atime,mtime})},open(path,flags,mode=438){if(path===\"\"){throw new FS.ErrnoError(44)}flags=typeof flags==\"string\"?FS_modeStringToFlags(flags):flags;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;var isDirPath;if(typeof path==\"object\"){node=path}else{isDirPath=path.endsWith(\"/\");var lookup=FS.lookupPath(path,{follow:!(flags&131072),noent_okay:true});node=lookup.node;path=lookup.path}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else if(isDirPath){throw new FS.ErrnoError(31)}else{node=FS.mknod(path,mode|511,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node,path:FS.getPath(node),flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(created){FS.chmod(node,mode&511)}return stream},close(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed(stream){return stream.fd===null},llseek(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=\"undefined\";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},mmap(stream,length,position,prot,flags){if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}if(!length){throw new FS.ErrnoError(28)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync(stream,buffer,offset,length,mmapFlags){if(!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},ioctl(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile(path,opts={}){opts.flags=opts.flags||0;opts.encoding=opts.encoding||\"binary\";if(opts.encoding!==\"utf8\"&&opts.encoding!==\"binary\"){abort(`Invalid encoding type \"${opts.encoding}\"`)}var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding===\"utf8\"){buf=UTF8ArrayToString(buf)}FS.close(stream);return buf},writeFile(path,data,opts={}){opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==\"string\"){data=new Uint8Array(intArrayFromString(data,true))}if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{abort(\"Unsupported data type\")}FS.close(stream)},cwd:()=>FS.currentPath,chdir(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,\"x\");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories(){FS.mkdir(\"/tmp\");FS.mkdir(\"/home\");FS.mkdir(\"/home/web_user\")},createDefaultDevices(){FS.mkdir(\"/dev\");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length,llseek:()=>0});FS.mkdev(\"/dev/null\",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev(\"/dev/tty\",FS.makedev(5,0));FS.mkdev(\"/dev/tty1\",FS.makedev(6,0));var randomBuffer=new Uint8Array(1024),randomLeft=0;var randomByte=()=>{if(randomLeft===0){randomFill(randomBuffer);randomLeft=randomBuffer.byteLength}return randomBuffer[--randomLeft]};FS.createDevice(\"/dev\",\"random\",randomByte);FS.createDevice(\"/dev\",\"urandom\",randomByte);FS.mkdir(\"/dev/shm\");FS.mkdir(\"/dev/shm/tmp\")},createSpecialDirectories(){FS.mkdir(\"/proc\");var proc_self=FS.mkdir(\"/proc/self\");FS.mkdir(\"/proc/self/fd\");FS.mount({mount(){var node=FS.createNode(proc_self,\"fd\",16895,73);node.stream_ops={llseek:MEMFS.stream_ops.llseek};node.node_ops={lookup(parent,name){var fd=+name;var stream=FS.getStreamChecked(fd);var ret={parent:null,mount:{mountpoint:\"fake\"},node_ops:{readlink:()=>stream.path},id:fd+1};ret.parent=ret;return ret},readdir(){return Array.from(FS.streams.entries()).filter(([k,v])=>v).map(([k,v])=>k.toString())}};return node}},{},\"/proc/self/fd\")},createStandardStreams(input,output,error){if(input){FS.createDevice(\"/dev\",\"stdin\",input)}else{FS.symlink(\"/dev/tty\",\"/dev/stdin\")}if(output){FS.createDevice(\"/dev\",\"stdout\",null,output)}else{FS.symlink(\"/dev/tty\",\"/dev/stdout\")}if(error){FS.createDevice(\"/dev\",\"stderr\",null,error)}else{FS.symlink(\"/dev/tty1\",\"/dev/stderr\")}var stdin=FS.open(\"/dev/stdin\",0);var stdout=FS.open(\"/dev/stdout\",1);var stderr=FS.open(\"/dev/stderr\",1)},staticInit(){FS.nameTable=new Array(4096);FS.mount(MEMFS,{},\"/\");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={MEMFS}},init(input,output,error){FS.initialized=true;input??=Module[\"stdin\"];output??=Module[\"stdout\"];error??=Module[\"stderr\"];FS.createStandardStreams(input,output,error)},quit(){FS.initialized=false;for(var stream of FS.streams){if(stream){FS.close(stream)}}},findObject(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path===\"/\"}catch(e){ret.error=e.errno}return ret},createPath(parent,path,canRead,canWrite){parent=typeof parent==\"string\"?parent:FS.getPath(parent);var parts=path.split(\"/\").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){if(e.errno!=20)throw e}parent=current}return current},createFile(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile(parent,name,data,canRead,canWrite,canOwn){var path=name;if(parent){parent=typeof parent==\"string\"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS_getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==\"string\"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}},createDevice(parent,name,input,output){var path=PATH.join2(typeof parent==\"string\"?parent:FS.getPath(parent),name);var mode=FS_getMode(!!input,!!output);FS.createDevice.major??=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open(stream){stream.seekable=false},close(stream){if(output?.buffer?.length){output(10)}},read(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.atime=Date.now()}return bytesRead},write(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.mtime=stream.node.ctime=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(globalThis.XMLHttpRequest){abort(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\")}else{try{obj.contents=readBinary(obj.url)}catch(e){throw new FS.ErrnoError(29)}}},createLazyFile(parent,name,url,canRead,canWrite){class LazyUint8Array{lengthKnown=false;chunks=[];get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]}setDataGetter(getter){this.getter=getter}cacheLength(){var xhr=new XMLHttpRequest;xhr.open(\"HEAD\",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);var datalength=Number(xhr.getResponseHeader(\"Content-length\"));var header;var hasByteServing=(header=xhr.getResponseHeader(\"Accept-Ranges\"))&&header===\"bytes\";var usesGzip=(header=xhr.getResponseHeader(\"Content-Encoding\"))&&header===\"gzip\";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)abort(\"invalid range (\"+from+\", \"+to+\") or no bytes requested!\");if(to>datalength-1)abort(\"only \"+datalength+\" bytes available! programmer error!\");var xhr=new XMLHttpRequest;xhr.open(\"GET\",url,false);if(datalength!==chunkSize)xhr.setRequestHeader(\"Range\",\"bytes=\"+from+\"-\"+to);xhr.responseType=\"arraybuffer\";if(xhr.overrideMimeType){xhr.overrideMimeType(\"text/plain; charset=x-user-defined\")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))abort(\"Couldn't load \"+url+\". Status: \"+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||\"\",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==\"undefined\"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==\"undefined\")abort(\"doXHR failed!\");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out(\"LazyFiles on gzip forces download of the whole file when length is accessed\")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true}get length(){if(!this.lengthKnown){this.cacheLength()}return this._length}get chunkSize(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}if(globalThis.XMLHttpRequest){if(!ENVIRONMENT_IS_WORKER)abort(\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\");var lazyArray=new LazyUint8Array;var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};for(const[key,fn]of Object.entries(node.stream_ops)){stream_ops[key]=(...args)=>{FS.forceLoadFile(node);return fn(...args)}}function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr,allocated:true}};node.stream_ops=stream_ops;return node}};var SYSCALLS={calculateAt(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=SYSCALLS.getStreamFromFD(dirfd);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return dir+\"/\"+path},writeStat(buf,stat){HEAPU32[buf>>2]=stat.dev;HEAPU32[buf+4>>2]=stat.mode;HEAPU32[buf+8>>2]=stat.nlink;HEAPU32[buf+12>>2]=stat.uid;HEAPU32[buf+16>>2]=stat.gid;HEAPU32[buf+20>>2]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];HEAP32[buf+32>>2]=4096;HEAP32[buf+36>>2]=stat.blocks;var atime=stat.atime.getTime();var mtime=stat.mtime.getTime();var ctime=stat.ctime.getTime();tempI64=[Math.floor(atime/1e3)>>>0,(tempDouble=Math.floor(atime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=atime%1e3*1e3*1e3;tempI64=[Math.floor(mtime/1e3)>>>0,(tempDouble=Math.floor(mtime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+56>>2]=tempI64[0],HEAP32[buf+60>>2]=tempI64[1];HEAPU32[buf+64>>2]=mtime%1e3*1e3*1e3;tempI64=[Math.floor(ctime/1e3)>>>0,(tempDouble=Math.floor(ctime/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+72>>2]=tempI64[0],HEAP32[buf+76>>2]=tempI64[1];HEAPU32[buf+80>>2]=ctime%1e3*1e3*1e3;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+88>>2]=tempI64[0],HEAP32[buf+92>>2]=tempI64[1];return 0},writeStatFs(buf,stats){HEAPU32[buf+4>>2]=stats.bsize;HEAPU32[buf+60>>2]=stats.bsize;tempI64=[stats.blocks>>>0,(tempDouble=stats.blocks,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+8>>2]=tempI64[0],HEAP32[buf+12>>2]=tempI64[1];tempI64=[stats.bfree>>>0,(tempDouble=stats.bfree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+16>>2]=tempI64[0],HEAP32[buf+20>>2]=tempI64[1];tempI64=[stats.bavail>>>0,(tempDouble=stats.bavail,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+24>>2]=tempI64[0],HEAP32[buf+28>>2]=tempI64[1];tempI64=[stats.files>>>0,(tempDouble=stats.files,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+32>>2]=tempI64[0],HEAP32[buf+36>>2]=tempI64[1];tempI64=[stats.ffree>>>0,(tempDouble=stats.ffree,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAPU32[buf+48>>2]=stats.fsid;HEAPU32[buf+64>>2]=stats.flags;HEAPU32[buf+56>>2]=stats.namelen},doMsync(addr,stream,len,flags,offset){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(flags&2){return 0}var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},getStreamFromFD(fd){var stream=FS.getStreamChecked(fd);return stream},varargs:undefined,getStr(ptr){var ret=UTF8ToString(ptr);return ret}};function ___syscall_chmod(path,mode){try{path=SYSCALLS.getStr(path);FS.chmod(path,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_faccessat(dirfd,path,amode,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(amode&~7){return-28}var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node){return-44}var perms=\"\";if(amode&4)perms+=\"r\";if(amode&2)perms+=\"w\";if(amode&1)perms+=\"x\";if(perms&&FS.nodePermissions(node,perms)){return-2}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchmod(fd,mode){try{FS.fchmod(fd,mode);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fchown32(fd,owner,group){try{FS.fchown(fd,owner,group);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var syscallGetVarargI=()=>{var ret=HEAP32[+SYSCALLS.varargs>>2];SYSCALLS.varargs+=4;return ret};var syscallGetVarargP=syscallGetVarargI;function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=syscallGetVarargI();if(arg<0){return-28}while(FS.streams[arg]){arg++}var newStream;newStream=FS.dupStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=syscallGetVarargI();stream.flags|=arg;return 0}case 12:{var arg=syscallGetVarargP();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 13:case 14:return 0}return-28}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_fstat64(fd,buf){try{return SYSCALLS.writeStat(buf,FS.fstat(fd))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var convertI32PairToI53Checked=(lo,hi)=>hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN;function ___syscall_ftruncate64(fd,length_low,length_high){var length=convertI32PairToI53Checked(length_low,length_high);try{if(isNaN(length))return-61;FS.ftruncate(fd,length);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var stringToUTF8=(str,outPtr,maxBytesToWrite)=>stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite);function ___syscall_getcwd(buf,size){try{if(size===0)return-28;var cwd=FS.cwd();var cwdLengthInBytes=lengthBytesUTF8(cwd)+1;if(size<cwdLengthInBytes)return-68;stringToUTF8(cwd,buf,size);return cwdLengthInBytes}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_lstat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.lstat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_mkdirat(dirfd,path,mode){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);FS.mkdir(path,mode,0);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_newfstatat(dirfd,path,buf,flags){try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~6400;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.writeStat(buf,nofollow?FS.lstat(path):FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?syscallGetVarargI():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_readlinkat(dirfd,path,buf,bufsize){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(bufsize<=0)return-28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_rmdir(path){try{path=SYSCALLS.getStr(path);FS.rmdir(path);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.writeStat(buf,FS.stat(path))}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function ___syscall_unlinkat(dirfd,path,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(!flags){FS.unlink(path)}else if(flags===512){FS.rmdir(path)}else{return-28}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var readI53FromI64=ptr=>HEAPU32[ptr>>2]+HEAP32[ptr+4>>2]*4294967296;function ___syscall_utimensat(dirfd,path,times,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path,true);var now=Date.now(),atime,mtime;if(!times){atime=now;mtime=now}else{var seconds=readI53FromI64(times);var nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){atime=now}else if(nanoseconds==1073741822){atime=null}else{atime=seconds*1e3+nanoseconds/(1e3*1e3)}times+=16;seconds=readI53FromI64(times);nanoseconds=HEAP32[times+8>>2];if(nanoseconds==1073741823){mtime=now}else if(nanoseconds==1073741822){mtime=null}else{mtime=seconds*1e3+nanoseconds/(1e3*1e3)}}if((mtime??atime)!==null){FS.utime(path,atime,mtime)}return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var __abort_js=()=>abort(\"\");var runtimeKeepaliveCounter=0;var __emscripten_runtime_keepalive_clear=()=>{noExitRuntime=false;runtimeKeepaliveCounter=0};var isLeapYear=year=>year%4===0&&(year%100!==0||year%400===0);var MONTH_DAYS_LEAP_CUMULATIVE=[0,31,60,91,121,152,182,213,244,274,305,335];var MONTH_DAYS_REGULAR_CUMULATIVE=[0,31,59,90,120,151,181,212,243,273,304,334];var ydayFromDate=date=>{var leap=isLeapYear(date.getFullYear());var monthDaysCumulative=leap?MONTH_DAYS_LEAP_CUMULATIVE:MONTH_DAYS_REGULAR_CUMULATIVE;var yday=monthDaysCumulative[date.getMonth()]+date.getDate()-1;return yday};function __localtime_js(time_low,time_high,tmPtr){var time=convertI32PairToI53Checked(time_low,time_high);var date=new Date(time*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var yday=ydayFromDate(date)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst}function __mmap_js(len,prot,flags,fd,offset_low,offset_high,allocated,addr){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);var res=FS.mmap(stream,len,offset,prot,flags);var ptr=res.ptr;HEAP32[allocated>>2]=res.allocated;HEAPU32[addr>>2]=ptr;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}function __munmap_js(addr,len,prot,flags,fd,offset_low,offset_high){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{var stream=SYSCALLS.getStreamFromFD(fd);if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return-e.errno}}var timers={};var handleException=e=>{if(e instanceof ExitStatus||e==\"unwind\"){return EXITSTATUS}quit_(1,e)};var keepRuntimeAlive=()=>noExitRuntime||runtimeKeepaliveCounter>0;var _proc_exit=code=>{EXITSTATUS=code;if(!keepRuntimeAlive()){Module[\"onExit\"]?.(code);ABORT=true}quit_(code,new ExitStatus(code))};var exitJS=(status,implicit)=>{EXITSTATUS=status;_proc_exit(status)};var _exit=exitJS;var maybeExit=()=>{if(!keepRuntimeAlive()){try{_exit(EXITSTATUS)}catch(e){handleException(e)}}};var callUserCallback=func=>{if(ABORT){return}try{return func()}catch(e){handleException(e)}finally{maybeExit()}};var _emscripten_get_now=()=>performance.now();var __setitimer_js=(which,timeout_ms)=>{if(timers[which]){clearTimeout(timers[which].id);delete timers[which]}if(!timeout_ms)return 0;var id=setTimeout(()=>{delete timers[which];callUserCallback(()=>__emscripten_timeout(which,_emscripten_get_now()))},timeout_ms);timers[which]={id,timeout_ms};return 0};var __tzset_js=(timezone,daylight,std_name,dst_name)=>{var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAPU32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);var extractZone=timezoneOffset=>{var sign=timezoneOffset>=0?\"-\":\"+\";var absOffset=Math.abs(timezoneOffset);var hours=String(Math.floor(absOffset/60)).padStart(2,\"0\");var minutes=String(absOffset%60).padStart(2,\"0\");return`UTC${sign}${hours}${minutes}`};var winterName=extractZone(winterOffset);var summerName=extractZone(summerOffset);if(summerOffset<winterOffset){stringToUTF8(winterName,std_name,17);stringToUTF8(summerName,dst_name,17)}else{stringToUTF8(winterName,dst_name,17);stringToUTF8(summerName,std_name,17)}};var _emscripten_date_now=()=>Date.now();var getHeapMax=()=>2147483648;var growMemory=size=>{var oldHeapSize=wasmMemory.buffer.byteLength;var pages=(size-oldHeapSize+65535)/65536|0;try{wasmMemory.grow(pages);updateMemoryViews();return 1}catch(e){}};var _emscripten_resize_heap=requestedSize=>{var oldSize=HEAPU8.length;requestedSize>>>=0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignMemory(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=growMemory(newSize);if(replacement){return true}}return false};var ENV={};var getExecutableName=()=>thisProgram||\"./this.program\";var getEnvStrings=()=>{if(!getEnvStrings.strings){var lang=(globalThis.navigator?.language??\"C\").replace(\"-\",\"_\")+\".UTF-8\";var env={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:lang,_:getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(`${x}=${env[x]}`)}getEnvStrings.strings=strings}return getEnvStrings.strings};var _environ_get=(__environ,environ_buf)=>{var bufSize=0;var envp=0;for(var string of getEnvStrings()){var ptr=environ_buf+bufSize;HEAPU32[__environ+envp>>2]=ptr;bufSize+=stringToUTF8(string,ptr,Infinity)+1;envp+=4}return 0};var _environ_sizes_get=(penviron_count,penviron_buf_size)=>{var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;for(var string of strings){bufSize+=lengthBytesUTF8(string)+1}HEAPU32[penviron_buf_size>>2]=bufSize;return 0};function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_fdstat_get(fd,pbuf){try{var rightsBase=0;var rightsInheriting=0;var flags=0;{var stream=SYSCALLS.getStreamFromFD(fd);var type=stream.tty?2:FS.isDir(stream.mode)?3:FS.isLink(stream.mode)?7:4}HEAP8[pbuf]=type;HEAP16[pbuf+2>>1]=flags;tempI64=[rightsBase>>>0,(tempDouble=rightsBase,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+8>>2]=tempI64[0],HEAP32[pbuf+12>>2]=tempI64[1];tempI64=[rightsInheriting>>>0,(tempDouble=rightsInheriting,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[pbuf+16>>2]=tempI64[0],HEAP32[pbuf+20>>2]=tempI64[1];return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doReadv=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break;if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){var offset=convertI32PairToI53Checked(offset_low,offset_high);try{if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?+Math.floor(tempDouble/4294967296)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}function _fd_sync(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);var rtn=stream.stream_ops?.fsync?.(stream);return rtn}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var doWritev=(stream,iov,iovcnt,offset)=>{var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len){break}if(typeof offset!=\"undefined\"){offset+=curr}}return ret};function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS==\"undefined\"||!(e.name===\"ErrnoError\"))throw e;return e.errno}}var adapters_support=function(){const handleAsync=typeof Asyncify===\"object\"?Asyncify.handleAsync.bind(Asyncify):null;Module[\"handleAsync\"]=handleAsync;const targets=new Map;Module[\"setCallback\"]=(key,target)=>targets.set(key,target);Module[\"getCallback\"]=key=>targets.get(key);Module[\"deleteCallback\"]=key=>targets.delete(key);adapters_support=function(isAsync,key,...args){const receiver=targets.get(key);let methodName=null;const f=typeof receiver===\"function\"?receiver:receiver[methodName=UTF8ToString(args.shift())];if(isAsync){if(handleAsync){return handleAsync(()=>f.apply(receiver,args))}throw new Error(\"Synchronous WebAssembly cannot call async function\")}const result=f.apply(receiver,args);if(typeof result?.then==\"function\"){console.error(\"unexpected Promise\",f);throw new Error(`${methodName} unexpectedly returned a Promise`)}return result}};function _ipp(...args){return adapters_support(false,...args)}function _ipp_async(...args){return adapters_support(true,...args)}function _ippipppp(...args){return adapters_support(false,...args)}function _ippipppp_async(...args){return adapters_support(true,...args)}function _ippp(...args){return adapters_support(false,...args)}function _ippp_async(...args){return adapters_support(true,...args)}function _ipppi(...args){return adapters_support(false,...args)}function _ipppi_async(...args){return adapters_support(true,...args)}function _ipppiii(...args){return adapters_support(false,...args)}function _ipppiii_async(...args){return adapters_support(true,...args)}function _ipppiiip(...args){return adapters_support(false,...args)}function _ipppiiip_async(...args){return adapters_support(true,...args)}function _ipppip(...args){return adapters_support(false,...args)}function _ipppip_async(...args){return adapters_support(true,...args)}function _ipppj(...args){return adapters_support(false,...args)}function _ipppj_async(...args){return adapters_support(true,...args)}function _ipppp(...args){return adapters_support(false,...args)}function _ipppp_async(...args){return adapters_support(true,...args)}function _ippppi(...args){return adapters_support(false,...args)}function _ippppi_async(...args){return adapters_support(true,...args)}function _ippppij(...args){return adapters_support(false,...args)}function _ippppij_async(...args){return adapters_support(true,...args)}function _ippppip(...args){return adapters_support(false,...args)}function _ippppip_async(...args){return adapters_support(true,...args)}function _ipppppip(...args){return adapters_support(false,...args)}function _ipppppip_async(...args){return adapters_support(true,...args)}function _vppippii(...args){return adapters_support(false,...args)}function _vppippii_async(...args){return adapters_support(true,...args)}function _vppp(...args){return adapters_support(false,...args)}function _vppp_async(...args){return adapters_support(true,...args)}function _vpppip(...args){return adapters_support(false,...args)}function _vpppip_async(...args){return adapters_support(true,...args)}var getWasmTableEntry=funcPtr=>wasmTable.get(funcPtr);var updateTableMap=(offset,count)=>{if(functionsInTableMap){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i)}}}};var functionsInTableMap;var getFunctionAddress=func=>{if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length)}return functionsInTableMap.get(func)||0};var freeTableIndexes=[];var getEmptyTableSlot=()=>{if(freeTableIndexes.length){return freeTableIndexes.pop()}return wasmTable[\"grow\"](1)};var setWasmTableEntry=(idx,func)=>wasmTable.set(idx,func);var uleb128EncodeWithLen=arr=>{const n=arr.length;return[n%128|128,n>>7,...arr]};var wasmTypeCodes={i:127,p:127,j:126,f:125,d:124,e:111};var generateTypePack=types=>uleb128EncodeWithLen(Array.from(types,type=>{var code=wasmTypeCodes[type];return code}));var convertJsFunctionToWasm=(func,sig)=>{var bytes=Uint8Array.of(0,97,115,109,1,0,0,0,1,...uleb128EncodeWithLen([1,96,...generateTypePack(sig.slice(1)),...generateTypePack(sig[0]===\"v\"?\"\":sig[0])]),2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{e:{f:func}});var wrappedFunc=instance.exports[\"f\"];return wrappedFunc};var addFunction=(func,sig)=>{var rtn=getFunctionAddress(func);if(rtn){return rtn}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func)}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped)}functionsInTableMap.set(func,ret);return ret};var getCFunc=ident=>{var func=Module[\"_\"+ident];return func};var writeArrayToMemory=(array,buffer)=>{HEAP8.set(array,buffer)};var stackAlloc=sz=>__emscripten_stack_alloc(sz);var stringToUTF8OnStack=str=>{var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8(str,ret,size);return ret};var ccall=(ident,returnType,argTypes,args,opts)=>{var toC={string:str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=stringToUTF8OnStack(str)}return ret},array:arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType===\"string\"){return UTF8ToString(ret)}if(returnType===\"boolean\")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func(...cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret};var cwrap=(ident,returnType,argTypes,opts)=>{var numericArgs=!argTypes||argTypes.every(type=>type===\"number\"||type===\"boolean\");var numericRet=returnType!==\"string\";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return(...args)=>ccall(ident,returnType,argTypes,args,opts)};var getTempRet0=val=>__emscripten_tempret_get();var stringToUTF16=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<2)return 0;maxBytesToWrite-=2;var startPtr=outPtr;var numCharsToWrite=maxBytesToWrite<str.length*2?maxBytesToWrite/2:str.length;for(var i=0;i<numCharsToWrite;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr>>1]=codeUnit;outPtr+=2}HEAP16[outPtr>>1]=0;return outPtr-startPtr};var stringToUTF32=(str,outPtr,maxBytesToWrite)=>{maxBytesToWrite??=2147483647;if(maxBytesToWrite<4)return 0;var startPtr=outPtr;var endPtr=startPtr+maxBytesToWrite-4;for(var i=0;i<str.length;++i){var codePoint=str.codePointAt(i);if(codePoint>65535){i++}HEAP32[outPtr>>2]=codePoint;outPtr+=4;if(outPtr+4>endPtr)break}HEAP32[outPtr>>2]=0;return outPtr-startPtr};var AsciiToString=ptr=>{var str=\"\";while(1){var ch=HEAPU8[ptr++];if(!ch)return str;str+=String.fromCharCode(ch)}};var UTF16Decoder=new TextDecoder(\"utf-16le\");var UTF16ToString=(ptr,maxBytesToRead,ignoreNul)=>{var idx=ptr>>1;var endIdx=findStringEnd(HEAPU16,idx,maxBytesToRead/2,ignoreNul);return UTF16Decoder.decode(HEAPU16.subarray(idx,endIdx))};var UTF32ToString=(ptr,maxBytesToRead,ignoreNul)=>{var str=\"\";var startIdx=ptr>>2;for(var i=0;!(i>=maxBytesToRead/4);i++){var utf32=HEAPU32[startIdx+i];if(!utf32&&!ignoreNul)break;str+=String.fromCodePoint(utf32)}return str};var intArrayToString=array=>{var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){chr&=255}ret.push(String.fromCharCode(chr))}return ret.join(\"\")};var _getTempRet0=getTempRet0;FS.createPreloadedFile=FS_createPreloadedFile;FS.preloadFile=FS_preloadFile;FS.staticInit();adapters_support();{if(Module[\"noExitRuntime\"])noExitRuntime=Module[\"noExitRuntime\"];if(Module[\"preloadPlugins\"])preloadPlugins=Module[\"preloadPlugins\"];if(Module[\"print\"])out=Module[\"print\"];if(Module[\"printErr\"])err=Module[\"printErr\"];if(Module[\"wasmBinary\"])wasmBinary=Module[\"wasmBinary\"];if(Module[\"arguments\"])arguments_=Module[\"arguments\"];if(Module[\"thisProgram\"])thisProgram=Module[\"thisProgram\"];if(Module[\"preInit\"]){if(typeof Module[\"preInit\"]==\"function\")Module[\"preInit\"]=[Module[\"preInit\"]];while(Module[\"preInit\"].length>0){Module[\"preInit\"].shift()()}}}Module[\"getTempRet0\"]=getTempRet0;Module[\"ccall\"]=ccall;Module[\"cwrap\"]=cwrap;Module[\"addFunction\"]=addFunction;Module[\"setValue\"]=setValue;Module[\"getValue\"]=getValue;Module[\"UTF8ToString\"]=UTF8ToString;Module[\"stringToUTF8\"]=stringToUTF8;Module[\"lengthBytesUTF8\"]=lengthBytesUTF8;Module[\"intArrayFromString\"]=intArrayFromString;Module[\"intArrayToString\"]=intArrayToString;Module[\"AsciiToString\"]=AsciiToString;Module[\"UTF16ToString\"]=UTF16ToString;Module[\"stringToUTF16\"]=stringToUTF16;Module[\"UTF32ToString\"]=UTF32ToString;Module[\"stringToUTF32\"]=stringToUTF32;Module[\"writeArrayToMemory\"]=writeArrayToMemory;Module[\"_getTempRet0\"]=_getTempRet0;var _powersync_init_static,_sqlite3_status64,_sqlite3_status,_sqlite3_msize,_sqlite3_db_status,_sqlite3_vfs_find,_sqlite3_vfs_register,_sqlite3_vfs_unregister,_sqlite3_release_memory,_sqlite3_soft_heap_limit64,_sqlite3_memory_used,_sqlite3_hard_heap_limit64,_sqlite3_memory_highwater,_sqlite3_malloc,_sqlite3_malloc64,_sqlite3_free,_sqlite3_realloc,_sqlite3_realloc64,_sqlite3_str_vappendf,_sqlite3_str_append,_sqlite3_str_appendchar,_sqlite3_str_appendall,_sqlite3_str_appendf,_sqlite3_str_finish,_sqlite3_str_errcode,_sqlite3_str_length,_sqlite3_str_value,_sqlite3_str_reset,_sqlite3_str_new,_sqlite3_vmprintf,_sqlite3_mprintf,_sqlite3_vsnprintf,_sqlite3_snprintf,_sqlite3_log,_sqlite3_randomness,_sqlite3_stricmp,_sqlite3_strnicmp,_sqlite3_os_init,_sqlite3_os_end,_sqlite3_serialize,_sqlite3_prepare_v2,_sqlite3_step,_sqlite3_column_int64,_sqlite3_reset,_sqlite3_exec,_sqlite3_column_int,_sqlite3_finalize,_sqlite3_deserialize,_sqlite3_database_file_object,_sqlite3_backup_init,_sqlite3_backup_step,_sqlite3_backup_finish,_sqlite3_backup_remaining,_sqlite3_backup_pagecount,_sqlite3_clear_bindings,_sqlite3_value_blob,_sqlite3_value_text,_sqlite3_value_bytes,_sqlite3_value_bytes16,_sqlite3_value_double,_sqlite3_value_int,_sqlite3_value_int64,_sqlite3_value_subtype,_sqlite3_value_pointer,_sqlite3_value_text16,_sqlite3_value_text16be,_sqlite3_value_text16le,_sqlite3_value_type,_sqlite3_value_encoding,_sqlite3_value_nochange,_sqlite3_value_frombind,_sqlite3_value_dup,_sqlite3_value_free,_sqlite3_result_blob,_sqlite3_result_blob64,_sqlite3_result_double,_sqlite3_result_error,_sqlite3_result_error16,_sqlite3_result_int,_sqlite3_result_int64,_sqlite3_result_null,_sqlite3_result_pointer,_sqlite3_result_subtype,_sqlite3_result_text,_sqlite3_result_text64,_sqlite3_result_text16,_sqlite3_result_text16be,_sqlite3_result_text16le,_sqlite3_result_value,_sqlite3_result_error_toobig,_sqlite3_result_zeroblob,_sqlite3_result_zeroblob64,_sqlite3_result_error_code,_sqlite3_result_error_nomem,_sqlite3_user_data,_sqlite3_context_db_handle,_sqlite3_vtab_nochange,_sqlite3_vtab_in_first,_sqlite3_vtab_in_next,_sqlite3_aggregate_context,_sqlite3_get_auxdata,_sqlite3_set_auxdata,_sqlite3_column_count,_sqlite3_data_count,_sqlite3_column_blob,_sqlite3_column_bytes,_sqlite3_column_bytes16,_sqlite3_column_double,_sqlite3_column_text,_sqlite3_column_value,_sqlite3_column_text16,_sqlite3_column_type,_sqlite3_column_name,_sqlite3_column_name16,_sqlite3_bind_blob,_sqlite3_bind_blob64,_sqlite3_bind_double,_sqlite3_bind_int,_sqlite3_bind_int64,_sqlite3_bind_null,_sqlite3_bind_pointer,_sqlite3_bind_text,_sqlite3_bind_text64,_sqlite3_bind_text16,_sqlite3_bind_value,_sqlite3_bind_zeroblob,_sqlite3_bind_zeroblob64,_sqlite3_bind_parameter_count,_sqlite3_bind_parameter_name,_sqlite3_bind_parameter_index,_sqlite3_db_handle,_sqlite3_stmt_readonly,_sqlite3_stmt_isexplain,_sqlite3_stmt_explain,_sqlite3_stmt_busy,_sqlite3_next_stmt,_sqlite3_stmt_status,_sqlite3_sql,_sqlite3_expanded_sql,_sqlite3_value_numeric_type,_sqlite3_blob_open,_sqlite3_blob_close,_sqlite3_blob_read,_sqlite3_blob_write,_sqlite3_blob_bytes,_sqlite3_blob_reopen,_sqlite3_set_authorizer,_sqlite3_strglob,_sqlite3_strlike,_sqlite3_errmsg,_sqlite3_load_extension,_sqlite3_enable_load_extension,_sqlite3_auto_extension,_sqlite3_cancel_auto_extension,_sqlite3_reset_auto_extension,_sqlite3_prepare,_sqlite3_prepare_v3,_sqlite3_prepare16,_sqlite3_prepare16_v2,_sqlite3_prepare16_v3,_sqlite3_get_table,_sqlite3_free_table,_sqlite3_create_module,_sqlite3_create_module_v2,_sqlite3_drop_modules,_sqlite3_declare_vtab,_sqlite3_vtab_on_conflict,_sqlite3_vtab_config,_sqlite3_vtab_collation,_sqlite3_vtab_in,_sqlite3_vtab_rhs_value,_sqlite3_vtab_distinct,_sqlite3_keyword_name,_sqlite3_keyword_count,_sqlite3_keyword_check,_sqlite3_complete,_sqlite3_complete16,_sqlite3_libversion,_sqlite3_libversion_number,_sqlite3_threadsafe,_sqlite3_initialize,_sqlite3_shutdown,_sqlite3_config,_sqlite3_db_mutex,_sqlite3_db_release_memory,_sqlite3_db_cacheflush,_sqlite3_db_config,_sqlite3_last_insert_rowid,_sqlite3_set_last_insert_rowid,_sqlite3_changes64,_sqlite3_changes,_sqlite3_total_changes64,_sqlite3_total_changes,_sqlite3_txn_state,_sqlite3_close,_sqlite3_close_v2,_sqlite3_busy_handler,_sqlite3_progress_handler,_sqlite3_busy_timeout,_sqlite3_interrupt,_sqlite3_is_interrupted,_sqlite3_create_function,_sqlite3_create_function_v2,_sqlite3_create_window_function,_sqlite3_create_function16,_sqlite3_overload_function,_sqlite3_trace_v2,_sqlite3_commit_hook,_sqlite3_update_hook,_sqlite3_rollback_hook,_sqlite3_autovacuum_pages,_sqlite3_wal_autocheckpoint,_sqlite3_wal_hook,_sqlite3_wal_checkpoint_v2,_sqlite3_wal_checkpoint,_sqlite3_error_offset,_sqlite3_errmsg16,_sqlite3_errcode,_sqlite3_extended_errcode,_sqlite3_system_errno,_sqlite3_errstr,_sqlite3_limit,_sqlite3_open,_sqlite3_open_v2,_sqlite3_open16,_sqlite3_create_collation,_sqlite3_create_collation_v2,_sqlite3_create_collation16,_sqlite3_collation_needed,_sqlite3_collation_needed16,_sqlite3_get_clientdata,_sqlite3_set_clientdata,_sqlite3_get_autocommit,_sqlite3_table_column_metadata,_sqlite3_sleep,_sqlite3_extended_result_codes,_sqlite3_file_control,_sqlite3_test_control,_sqlite3_create_filename,_sqlite3_free_filename,_sqlite3_uri_parameter,_sqlite3_uri_key,_sqlite3_uri_boolean,_sqlite3_uri_int64,_sqlite3_filename_database,_sqlite3_filename_journal,_sqlite3_filename_wal,_sqlite3_db_name,_sqlite3_db_filename,_sqlite3_db_readonly,_sqlite3_compileoption_used,_sqlite3_compileoption_get,_sqlite3_sourceid,_memcmp,_malloc,_free,_RegisterExtensionFunctions,_getSqliteFree,_main,_libauthorizer_set_authorizer,_libfunction_create_function,_libhook_commit_hook,_libhook_update_hook,_libprogress_progress_handler,_libvfs_vfs_register,_memcpy,_memset,_emscripten_builtin_memalign,__emscripten_timeout,__emscripten_tempret_get,__emscripten_stack_restore,__emscripten_stack_alloc,_emscripten_stack_get_current,dynCall_viiiij,dynCall_vijii,dynCall_iiiij,dynCall_viji,dynCall_iij,dynCall_iijii,dynCall_iiji,dynCall_iiiiiij,dynCall_iiij,dynCall_jii,dynCall_ji,dynCall_vij,dynCall_iiiiijii,dynCall_j,dynCall_jj,dynCall_jiij,dynCall_iiiiji,dynCall_iiiijii,dynCall_ij,dynCall_viiji,dynCall_viijii,dynCall_iiiijji,memory,_sqlite3_version,__indirect_function_table,wasmMemory,wasmTable;function assignWasmExports(wasmExports){_powersync_init_static=Module[\"_powersync_init_static\"]=wasmExports[\"ra\"];_sqlite3_status64=Module[\"_sqlite3_status64\"]=wasmExports[\"sa\"];_sqlite3_status=Module[\"_sqlite3_status\"]=wasmExports[\"ta\"];_sqlite3_msize=Module[\"_sqlite3_msize\"]=wasmExports[\"ua\"];_sqlite3_db_status=Module[\"_sqlite3_db_status\"]=wasmExports[\"va\"];_sqlite3_vfs_find=Module[\"_sqlite3_vfs_find\"]=wasmExports[\"wa\"];_sqlite3_vfs_register=Module[\"_sqlite3_vfs_register\"]=wasmExports[\"xa\"];_sqlite3_vfs_unregister=Module[\"_sqlite3_vfs_unregister\"]=wasmExports[\"ya\"];_sqlite3_release_memory=Module[\"_sqlite3_release_memory\"]=wasmExports[\"za\"];_sqlite3_soft_heap_limit64=Module[\"_sqlite3_soft_heap_limit64\"]=wasmExports[\"Aa\"];_sqlite3_memory_used=Module[\"_sqlite3_memory_used\"]=wasmExports[\"Ba\"];_sqlite3_hard_heap_limit64=Module[\"_sqlite3_hard_heap_limit64\"]=wasmExports[\"Ca\"];_sqlite3_memory_highwater=Module[\"_sqlite3_memory_highwater\"]=wasmExports[\"Da\"];_sqlite3_malloc=Module[\"_sqlite3_malloc\"]=wasmExports[\"Ea\"];_sqlite3_malloc64=Module[\"_sqlite3_malloc64\"]=wasmExports[\"Fa\"];_sqlite3_free=Module[\"_sqlite3_free\"]=wasmExports[\"Ga\"];_sqlite3_realloc=Module[\"_sqlite3_realloc\"]=wasmExports[\"Ha\"];_sqlite3_realloc64=Module[\"_sqlite3_realloc64\"]=wasmExports[\"Ia\"];_sqlite3_str_vappendf=Module[\"_sqlite3_str_vappendf\"]=wasmExports[\"Ja\"];_sqlite3_str_append=Module[\"_sqlite3_str_append\"]=wasmExports[\"Ka\"];_sqlite3_str_appendchar=Module[\"_sqlite3_str_appendchar\"]=wasmExports[\"La\"];_sqlite3_str_appendall=Module[\"_sqlite3_str_appendall\"]=wasmExports[\"Ma\"];_sqlite3_str_appendf=Module[\"_sqlite3_str_appendf\"]=wasmExports[\"Na\"];_sqlite3_str_finish=Module[\"_sqlite3_str_finish\"]=wasmExports[\"Oa\"];_sqlite3_str_errcode=Module[\"_sqlite3_str_errcode\"]=wasmExports[\"Pa\"];_sqlite3_str_length=Module[\"_sqlite3_str_length\"]=wasmExports[\"Qa\"];_sqlite3_str_value=Module[\"_sqlite3_str_value\"]=wasmExports[\"Ra\"];_sqlite3_str_reset=Module[\"_sqlite3_str_reset\"]=wasmExports[\"Sa\"];_sqlite3_str_new=Module[\"_sqlite3_str_new\"]=wasmExports[\"Ta\"];_sqlite3_vmprintf=Module[\"_sqlite3_vmprintf\"]=wasmExports[\"Ua\"];_sqlite3_mprintf=Module[\"_sqlite3_mprintf\"]=wasmExports[\"Va\"];_sqlite3_vsnprintf=Module[\"_sqlite3_vsnprintf\"]=wasmExports[\"Wa\"];_sqlite3_snprintf=Module[\"_sqlite3_snprintf\"]=wasmExports[\"Xa\"];_sqlite3_log=Module[\"_sqlite3_log\"]=wasmExports[\"Ya\"];_sqlite3_randomness=Module[\"_sqlite3_randomness\"]=wasmExports[\"Za\"];_sqlite3_stricmp=Module[\"_sqlite3_stricmp\"]=wasmExports[\"_a\"];_sqlite3_strnicmp=Module[\"_sqlite3_strnicmp\"]=wasmExports[\"$a\"];_sqlite3_os_init=Module[\"_sqlite3_os_init\"]=wasmExports[\"ab\"];_sqlite3_os_end=Module[\"_sqlite3_os_end\"]=wasmExports[\"bb\"];_sqlite3_serialize=Module[\"_sqlite3_serialize\"]=wasmExports[\"cb\"];_sqlite3_prepare_v2=Module[\"_sqlite3_prepare_v2\"]=wasmExports[\"db\"];_sqlite3_step=Module[\"_sqlite3_step\"]=wasmExports[\"eb\"];_sqlite3_column_int64=Module[\"_sqlite3_column_int64\"]=wasmExports[\"fb\"];_sqlite3_reset=Module[\"_sqlite3_reset\"]=wasmExports[\"gb\"];_sqlite3_exec=Module[\"_sqlite3_exec\"]=wasmExports[\"hb\"];_sqlite3_column_int=Module[\"_sqlite3_column_int\"]=wasmExports[\"ib\"];_sqlite3_finalize=Module[\"_sqlite3_finalize\"]=wasmExports[\"jb\"];_sqlite3_deserialize=Module[\"_sqlite3_deserialize\"]=wasmExports[\"kb\"];_sqlite3_database_file_object=Module[\"_sqlite3_database_file_object\"]=wasmExports[\"lb\"];_sqlite3_backup_init=Module[\"_sqlite3_backup_init\"]=wasmExports[\"mb\"];_sqlite3_backup_step=Module[\"_sqlite3_backup_step\"]=wasmExports[\"nb\"];_sqlite3_backup_finish=Module[\"_sqlite3_backup_finish\"]=wasmExports[\"ob\"];_sqlite3_backup_remaining=Module[\"_sqlite3_backup_remaining\"]=wasmExports[\"pb\"];_sqlite3_backup_pagecount=Module[\"_sqlite3_backup_pagecount\"]=wasmExports[\"qb\"];_sqlite3_clear_bindings=Module[\"_sqlite3_clear_bindings\"]=wasmExports[\"rb\"];_sqlite3_value_blob=Module[\"_sqlite3_value_blob\"]=wasmExports[\"sb\"];_sqlite3_value_text=Module[\"_sqlite3_value_text\"]=wasmExports[\"tb\"];_sqlite3_value_bytes=Module[\"_sqlite3_value_bytes\"]=wasmExports[\"ub\"];_sqlite3_value_bytes16=Module[\"_sqlite3_value_bytes16\"]=wasmExports[\"vb\"];_sqlite3_value_double=Module[\"_sqlite3_value_double\"]=wasmExports[\"wb\"];_sqlite3_value_int=Module[\"_sqlite3_value_int\"]=wasmExports[\"xb\"];_sqlite3_value_int64=Module[\"_sqlite3_value_int64\"]=wasmExports[\"yb\"];_sqlite3_value_subtype=Module[\"_sqlite3_value_subtype\"]=wasmExports[\"zb\"];_sqlite3_value_pointer=Module[\"_sqlite3_value_pointer\"]=wasmExports[\"Ab\"];_sqlite3_value_text16=Module[\"_sqlite3_value_text16\"]=wasmExports[\"Bb\"];_sqlite3_value_text16be=Module[\"_sqlite3_value_text16be\"]=wasmExports[\"Cb\"];_sqlite3_value_text16le=Module[\"_sqlite3_value_text16le\"]=wasmExports[\"Db\"];_sqlite3_value_type=Module[\"_sqlite3_value_type\"]=wasmExports[\"Eb\"];_sqlite3_value_encoding=Module[\"_sqlite3_value_encoding\"]=wasmExports[\"Fb\"];_sqlite3_value_nochange=Module[\"_sqlite3_value_nochange\"]=wasmExports[\"Gb\"];_sqlite3_value_frombind=Module[\"_sqlite3_value_frombind\"]=wasmExports[\"Hb\"];_sqlite3_value_dup=Module[\"_sqlite3_value_dup\"]=wasmExports[\"Ib\"];_sqlite3_value_free=Module[\"_sqlite3_value_free\"]=wasmExports[\"Jb\"];_sqlite3_result_blob=Module[\"_sqlite3_result_blob\"]=wasmExports[\"Kb\"];_sqlite3_result_blob64=Module[\"_sqlite3_result_blob64\"]=wasmExports[\"Lb\"];_sqlite3_result_double=Module[\"_sqlite3_result_double\"]=wasmExports[\"Mb\"];_sqlite3_result_error=Module[\"_sqlite3_result_error\"]=wasmExports[\"Nb\"];_sqlite3_result_error16=Module[\"_sqlite3_result_error16\"]=wasmExports[\"Ob\"];_sqlite3_result_int=Module[\"_sqlite3_result_int\"]=wasmExports[\"Pb\"];_sqlite3_result_int64=Module[\"_sqlite3_result_int64\"]=wasmExports[\"Qb\"];_sqlite3_result_null=Module[\"_sqlite3_result_null\"]=wasmExports[\"Rb\"];_sqlite3_result_pointer=Module[\"_sqlite3_result_pointer\"]=wasmExports[\"Sb\"];_sqlite3_result_subtype=Module[\"_sqlite3_result_subtype\"]=wasmExports[\"Tb\"];_sqlite3_result_text=Module[\"_sqlite3_result_text\"]=wasmExports[\"Ub\"];_sqlite3_result_text64=Module[\"_sqlite3_result_text64\"]=wasmExports[\"Vb\"];_sqlite3_result_text16=Module[\"_sqlite3_result_text16\"]=wasmExports[\"Wb\"];_sqlite3_result_text16be=Module[\"_sqlite3_result_text16be\"]=wasmExports[\"Xb\"];_sqlite3_result_text16le=Module[\"_sqlite3_result_text16le\"]=wasmExports[\"Yb\"];_sqlite3_result_value=Module[\"_sqlite3_result_value\"]=wasmExports[\"Zb\"];_sqlite3_result_error_toobig=Module[\"_sqlite3_result_error_toobig\"]=wasmExports[\"_b\"];_sqlite3_result_zeroblob=Module[\"_sqlite3_result_zeroblob\"]=wasmExports[\"$b\"];_sqlite3_result_zeroblob64=Module[\"_sqlite3_result_zeroblob64\"]=wasmExports[\"ac\"];_sqlite3_result_error_code=Module[\"_sqlite3_result_error_code\"]=wasmExports[\"bc\"];_sqlite3_result_error_nomem=Module[\"_sqlite3_result_error_nomem\"]=wasmExports[\"cc\"];_sqlite3_user_data=Module[\"_sqlite3_user_data\"]=wasmExports[\"dc\"];_sqlite3_context_db_handle=Module[\"_sqlite3_context_db_handle\"]=wasmExports[\"ec\"];_sqlite3_vtab_nochange=Module[\"_sqlite3_vtab_nochange\"]=wasmExports[\"fc\"];_sqlite3_vtab_in_first=Module[\"_sqlite3_vtab_in_first\"]=wasmExports[\"gc\"];_sqlite3_vtab_in_next=Module[\"_sqlite3_vtab_in_next\"]=wasmExports[\"hc\"];_sqlite3_aggregate_context=Module[\"_sqlite3_aggregate_context\"]=wasmExports[\"ic\"];_sqlite3_get_auxdata=Module[\"_sqlite3_get_auxdata\"]=wasmExports[\"jc\"];_sqlite3_set_auxdata=Module[\"_sqlite3_set_auxdata\"]=wasmExports[\"kc\"];_sqlite3_column_count=Module[\"_sqlite3_column_count\"]=wasmExports[\"lc\"];_sqlite3_data_count=Module[\"_sqlite3_data_count\"]=wasmExports[\"mc\"];_sqlite3_column_blob=Module[\"_sqlite3_column_blob\"]=wasmExports[\"nc\"];_sqlite3_column_bytes=Module[\"_sqlite3_column_bytes\"]=wasmExports[\"oc\"];_sqlite3_column_bytes16=Module[\"_sqlite3_column_bytes16\"]=wasmExports[\"pc\"];_sqlite3_column_double=Module[\"_sqlite3_column_double\"]=wasmExports[\"qc\"];_sqlite3_column_text=Module[\"_sqlite3_column_text\"]=wasmExports[\"rc\"];_sqlite3_column_value=Module[\"_sqlite3_column_value\"]=wasmExports[\"sc\"];_sqlite3_column_text16=Module[\"_sqlite3_column_text16\"]=wasmExports[\"tc\"];_sqlite3_column_type=Module[\"_sqlite3_column_type\"]=wasmExports[\"uc\"];_sqlite3_column_name=Module[\"_sqlite3_column_name\"]=wasmExports[\"vc\"];_sqlite3_column_name16=Module[\"_sqlite3_column_name16\"]=wasmExports[\"wc\"];_sqlite3_bind_blob=Module[\"_sqlite3_bind_blob\"]=wasmExports[\"xc\"];_sqlite3_bind_blob64=Module[\"_sqlite3_bind_blob64\"]=wasmExports[\"yc\"];_sqlite3_bind_double=Module[\"_sqlite3_bind_double\"]=wasmExports[\"zc\"];_sqlite3_bind_int=Module[\"_sqlite3_bind_int\"]=wasmExports[\"Ac\"];_sqlite3_bind_int64=Module[\"_sqlite3_bind_int64\"]=wasmExports[\"Bc\"];_sqlite3_bind_null=Module[\"_sqlite3_bind_null\"]=wasmExports[\"Cc\"];_sqlite3_bind_pointer=Module[\"_sqlite3_bind_pointer\"]=wasmExports[\"Dc\"];_sqlite3_bind_text=Module[\"_sqlite3_bind_text\"]=wasmExports[\"Ec\"];_sqlite3_bind_text64=Module[\"_sqlite3_bind_text64\"]=wasmExports[\"Fc\"];_sqlite3_bind_text16=Module[\"_sqlite3_bind_text16\"]=wasmExports[\"Gc\"];_sqlite3_bind_value=Module[\"_sqlite3_bind_value\"]=wasmExports[\"Hc\"];_sqlite3_bind_zeroblob=Module[\"_sqlite3_bind_zeroblob\"]=wasmExports[\"Ic\"];_sqlite3_bind_zeroblob64=Module[\"_sqlite3_bind_zeroblob64\"]=wasmExports[\"Jc\"];_sqlite3_bind_parameter_count=Module[\"_sqlite3_bind_parameter_count\"]=wasmExports[\"Kc\"];_sqlite3_bind_parameter_name=Module[\"_sqlite3_bind_parameter_name\"]=wasmExports[\"Lc\"];_sqlite3_bind_parameter_index=Module[\"_sqlite3_bind_parameter_index\"]=wasmExports[\"Mc\"];_sqlite3_db_handle=Module[\"_sqlite3_db_handle\"]=wasmExports[\"Nc\"];_sqlite3_stmt_readonly=Module[\"_sqlite3_stmt_readonly\"]=wasmExports[\"Oc\"];_sqlite3_stmt_isexplain=Module[\"_sqlite3_stmt_isexplain\"]=wasmExports[\"Pc\"];_sqlite3_stmt_explain=Module[\"_sqlite3_stmt_explain\"]=wasmExports[\"Qc\"];_sqlite3_stmt_busy=Module[\"_sqlite3_stmt_busy\"]=wasmExports[\"Rc\"];_sqlite3_next_stmt=Module[\"_sqlite3_next_stmt\"]=wasmExports[\"Sc\"];_sqlite3_stmt_status=Module[\"_sqlite3_stmt_status\"]=wasmExports[\"Tc\"];_sqlite3_sql=Module[\"_sqlite3_sql\"]=wasmExports[\"Uc\"];_sqlite3_expanded_sql=Module[\"_sqlite3_expanded_sql\"]=wasmExports[\"Vc\"];_sqlite3_value_numeric_type=Module[\"_sqlite3_value_numeric_type\"]=wasmExports[\"Wc\"];_sqlite3_blob_open=Module[\"_sqlite3_blob_open\"]=wasmExports[\"Xc\"];_sqlite3_blob_close=Module[\"_sqlite3_blob_close\"]=wasmExports[\"Yc\"];_sqlite3_blob_read=Module[\"_sqlite3_blob_read\"]=wasmExports[\"Zc\"];_sqlite3_blob_write=Module[\"_sqlite3_blob_write\"]=wasmExports[\"_c\"];_sqlite3_blob_bytes=Module[\"_sqlite3_blob_bytes\"]=wasmExports[\"$c\"];_sqlite3_blob_reopen=Module[\"_sqlite3_blob_reopen\"]=wasmExports[\"ad\"];_sqlite3_set_authorizer=Module[\"_sqlite3_set_authorizer\"]=wasmExports[\"bd\"];_sqlite3_strglob=Module[\"_sqlite3_strglob\"]=wasmExports[\"cd\"];_sqlite3_strlike=Module[\"_sqlite3_strlike\"]=wasmExports[\"dd\"];_sqlite3_errmsg=Module[\"_sqlite3_errmsg\"]=wasmExports[\"ed\"];_sqlite3_load_extension=Module[\"_sqlite3_load_extension\"]=wasmExports[\"fd\"];_sqlite3_enable_load_extension=Module[\"_sqlite3_enable_load_extension\"]=wasmExports[\"gd\"];_sqlite3_auto_extension=Module[\"_sqlite3_auto_extension\"]=wasmExports[\"hd\"];_sqlite3_cancel_auto_extension=Module[\"_sqlite3_cancel_auto_extension\"]=wasmExports[\"id\"];_sqlite3_reset_auto_extension=Module[\"_sqlite3_reset_auto_extension\"]=wasmExports[\"jd\"];_sqlite3_prepare=Module[\"_sqlite3_prepare\"]=wasmExports[\"kd\"];_sqlite3_prepare_v3=Module[\"_sqlite3_prepare_v3\"]=wasmExports[\"ld\"];_sqlite3_prepare16=Module[\"_sqlite3_prepare16\"]=wasmExports[\"md\"];_sqlite3_prepare16_v2=Module[\"_sqlite3_prepare16_v2\"]=wasmExports[\"nd\"];_sqlite3_prepare16_v3=Module[\"_sqlite3_prepare16_v3\"]=wasmExports[\"od\"];_sqlite3_get_table=Module[\"_sqlite3_get_table\"]=wasmExports[\"pd\"];_sqlite3_free_table=Module[\"_sqlite3_free_table\"]=wasmExports[\"qd\"];_sqlite3_create_module=Module[\"_sqlite3_create_module\"]=wasmExports[\"rd\"];_sqlite3_create_module_v2=Module[\"_sqlite3_create_module_v2\"]=wasmExports[\"sd\"];_sqlite3_drop_modules=Module[\"_sqlite3_drop_modules\"]=wasmExports[\"td\"];_sqlite3_declare_vtab=Module[\"_sqlite3_declare_vtab\"]=wasmExports[\"ud\"];_sqlite3_vtab_on_conflict=Module[\"_sqlite3_vtab_on_conflict\"]=wasmExports[\"vd\"];_sqlite3_vtab_config=Module[\"_sqlite3_vtab_config\"]=wasmExports[\"wd\"];_sqlite3_vtab_collation=Module[\"_sqlite3_vtab_collation\"]=wasmExports[\"xd\"];_sqlite3_vtab_in=Module[\"_sqlite3_vtab_in\"]=wasmExports[\"yd\"];_sqlite3_vtab_rhs_value=Module[\"_sqlite3_vtab_rhs_value\"]=wasmExports[\"zd\"];_sqlite3_vtab_distinct=Module[\"_sqlite3_vtab_distinct\"]=wasmExports[\"Ad\"];_sqlite3_keyword_name=Module[\"_sqlite3_keyword_name\"]=wasmExports[\"Bd\"];_sqlite3_keyword_count=Module[\"_sqlite3_keyword_count\"]=wasmExports[\"Cd\"];_sqlite3_keyword_check=Module[\"_sqlite3_keyword_check\"]=wasmExports[\"Dd\"];_sqlite3_complete=Module[\"_sqlite3_complete\"]=wasmExports[\"Ed\"];_sqlite3_complete16=Module[\"_sqlite3_complete16\"]=wasmExports[\"Fd\"];_sqlite3_libversion=Module[\"_sqlite3_libversion\"]=wasmExports[\"Gd\"];_sqlite3_libversion_number=Module[\"_sqlite3_libversion_number\"]=wasmExports[\"Hd\"];_sqlite3_threadsafe=Module[\"_sqlite3_threadsafe\"]=wasmExports[\"Id\"];_sqlite3_initialize=Module[\"_sqlite3_initialize\"]=wasmExports[\"Jd\"];_sqlite3_shutdown=Module[\"_sqlite3_shutdown\"]=wasmExports[\"Kd\"];_sqlite3_config=Module[\"_sqlite3_config\"]=wasmExports[\"Ld\"];_sqlite3_db_mutex=Module[\"_sqlite3_db_mutex\"]=wasmExports[\"Md\"];_sqlite3_db_release_memory=Module[\"_sqlite3_db_release_memory\"]=wasmExports[\"Nd\"];_sqlite3_db_cacheflush=Module[\"_sqlite3_db_cacheflush\"]=wasmExports[\"Od\"];_sqlite3_db_config=Module[\"_sqlite3_db_config\"]=wasmExports[\"Pd\"];_sqlite3_last_insert_rowid=Module[\"_sqlite3_last_insert_rowid\"]=wasmExports[\"Qd\"];_sqlite3_set_last_insert_rowid=Module[\"_sqlite3_set_last_insert_rowid\"]=wasmExports[\"Rd\"];_sqlite3_changes64=Module[\"_sqlite3_changes64\"]=wasmExports[\"Sd\"];_sqlite3_changes=Module[\"_sqlite3_changes\"]=wasmExports[\"Td\"];_sqlite3_total_changes64=Module[\"_sqlite3_total_changes64\"]=wasmExports[\"Ud\"];_sqlite3_total_changes=Module[\"_sqlite3_total_changes\"]=wasmExports[\"Vd\"];_sqlite3_txn_state=Module[\"_sqlite3_txn_state\"]=wasmExports[\"Wd\"];_sqlite3_close=Module[\"_sqlite3_close\"]=wasmExports[\"Xd\"];_sqlite3_close_v2=Module[\"_sqlite3_close_v2\"]=wasmExports[\"Yd\"];_sqlite3_busy_handler=Module[\"_sqlite3_busy_handler\"]=wasmExports[\"Zd\"];_sqlite3_progress_handler=Module[\"_sqlite3_progress_handler\"]=wasmExports[\"_d\"];_sqlite3_busy_timeout=Module[\"_sqlite3_busy_timeout\"]=wasmExports[\"$d\"];_sqlite3_interrupt=Module[\"_sqlite3_interrupt\"]=wasmExports[\"ae\"];_sqlite3_is_interrupted=Module[\"_sqlite3_is_interrupted\"]=wasmExports[\"be\"];_sqlite3_create_function=Module[\"_sqlite3_create_function\"]=wasmExports[\"ce\"];_sqlite3_create_function_v2=Module[\"_sqlite3_create_function_v2\"]=wasmExports[\"de\"];_sqlite3_create_window_function=Module[\"_sqlite3_create_window_function\"]=wasmExports[\"ee\"];_sqlite3_create_function16=Module[\"_sqlite3_create_function16\"]=wasmExports[\"fe\"];_sqlite3_overload_function=Module[\"_sqlite3_overload_function\"]=wasmExports[\"ge\"];_sqlite3_trace_v2=Module[\"_sqlite3_trace_v2\"]=wasmExports[\"he\"];_sqlite3_commit_hook=Module[\"_sqlite3_commit_hook\"]=wasmExports[\"ie\"];_sqlite3_update_hook=Module[\"_sqlite3_update_hook\"]=wasmExports[\"je\"];_sqlite3_rollback_hook=Module[\"_sqlite3_rollback_hook\"]=wasmExports[\"ke\"];_sqlite3_autovacuum_pages=Module[\"_sqlite3_autovacuum_pages\"]=wasmExports[\"le\"];_sqlite3_wal_autocheckpoint=Module[\"_sqlite3_wal_autocheckpoint\"]=wasmExports[\"me\"];_sqlite3_wal_hook=Module[\"_sqlite3_wal_hook\"]=wasmExports[\"ne\"];_sqlite3_wal_checkpoint_v2=Module[\"_sqlite3_wal_checkpoint_v2\"]=wasmExports[\"oe\"];_sqlite3_wal_checkpoint=Module[\"_sqlite3_wal_checkpoint\"]=wasmExports[\"pe\"];_sqlite3_error_offset=Module[\"_sqlite3_error_offset\"]=wasmExports[\"qe\"];_sqlite3_errmsg16=Module[\"_sqlite3_errmsg16\"]=wasmExports[\"re\"];_sqlite3_errcode=Module[\"_sqlite3_errcode\"]=wasmExports[\"se\"];_sqlite3_extended_errcode=Module[\"_sqlite3_extended_errcode\"]=wasmExports[\"te\"];_sqlite3_system_errno=Module[\"_sqlite3_system_errno\"]=wasmExports[\"ue\"];_sqlite3_errstr=Module[\"_sqlite3_errstr\"]=wasmExports[\"ve\"];_sqlite3_limit=Module[\"_sqlite3_limit\"]=wasmExports[\"we\"];_sqlite3_open=Module[\"_sqlite3_open\"]=wasmExports[\"xe\"];_sqlite3_open_v2=Module[\"_sqlite3_open_v2\"]=wasmExports[\"ye\"];_sqlite3_open16=Module[\"_sqlite3_open16\"]=wasmExports[\"ze\"];_sqlite3_create_collation=Module[\"_sqlite3_create_collation\"]=wasmExports[\"Ae\"];_sqlite3_create_collation_v2=Module[\"_sqlite3_create_collation_v2\"]=wasmExports[\"Be\"];_sqlite3_create_collation16=Module[\"_sqlite3_create_collation16\"]=wasmExports[\"Ce\"];_sqlite3_collation_needed=Module[\"_sqlite3_collation_needed\"]=wasmExports[\"De\"];_sqlite3_collation_needed16=Module[\"_sqlite3_collation_needed16\"]=wasmExports[\"Ee\"];_sqlite3_get_clientdata=Module[\"_sqlite3_get_clientdata\"]=wasmExports[\"Fe\"];_sqlite3_set_clientdata=Module[\"_sqlite3_set_clientdata\"]=wasmExports[\"Ge\"];_sqlite3_get_autocommit=Module[\"_sqlite3_get_autocommit\"]=wasmExports[\"He\"];_sqlite3_table_column_metadata=Module[\"_sqlite3_table_column_metadata\"]=wasmExports[\"Ie\"];_sqlite3_sleep=Module[\"_sqlite3_sleep\"]=wasmExports[\"Je\"];_sqlite3_extended_result_codes=Module[\"_sqlite3_extended_result_codes\"]=wasmExports[\"Ke\"];_sqlite3_file_control=Module[\"_sqlite3_file_control\"]=wasmExports[\"Le\"];_sqlite3_test_control=Module[\"_sqlite3_test_control\"]=wasmExports[\"Me\"];_sqlite3_create_filename=Module[\"_sqlite3_create_filename\"]=wasmExports[\"Ne\"];_sqlite3_free_filename=Module[\"_sqlite3_free_filename\"]=wasmExports[\"Oe\"];_sqlite3_uri_parameter=Module[\"_sqlite3_uri_parameter\"]=wasmExports[\"Pe\"];_sqlite3_uri_key=Module[\"_sqlite3_uri_key\"]=wasmExports[\"Qe\"];_sqlite3_uri_boolean=Module[\"_sqlite3_uri_boolean\"]=wasmExports[\"Re\"];_sqlite3_uri_int64=Module[\"_sqlite3_uri_int64\"]=wasmExports[\"Se\"];_sqlite3_filename_database=Module[\"_sqlite3_filename_database\"]=wasmExports[\"Te\"];_sqlite3_filename_journal=Module[\"_sqlite3_filename_journal\"]=wasmExports[\"Ue\"];_sqlite3_filename_wal=Module[\"_sqlite3_filename_wal\"]=wasmExports[\"Ve\"];_sqlite3_db_name=Module[\"_sqlite3_db_name\"]=wasmExports[\"We\"];_sqlite3_db_filename=Module[\"_sqlite3_db_filename\"]=wasmExports[\"Xe\"];_sqlite3_db_readonly=Module[\"_sqlite3_db_readonly\"]=wasmExports[\"Ye\"];_sqlite3_compileoption_used=Module[\"_sqlite3_compileoption_used\"]=wasmExports[\"Ze\"];_sqlite3_compileoption_get=Module[\"_sqlite3_compileoption_get\"]=wasmExports[\"_e\"];_sqlite3_sourceid=Module[\"_sqlite3_sourceid\"]=wasmExports[\"$e\"];_memcmp=Module[\"_memcmp\"]=wasmExports[\"af\"];_malloc=Module[\"_malloc\"]=wasmExports[\"bf\"];_free=Module[\"_free\"]=wasmExports[\"cf\"];_RegisterExtensionFunctions=Module[\"_RegisterExtensionFunctions\"]=wasmExports[\"ef\"];_getSqliteFree=Module[\"_getSqliteFree\"]=wasmExports[\"ff\"];_main=Module[\"_main\"]=wasmExports[\"gf\"];_libauthorizer_set_authorizer=Module[\"_libauthorizer_set_authorizer\"]=wasmExports[\"hf\"];_libfunction_create_function=Module[\"_libfunction_create_function\"]=wasmExports[\"jf\"];_libhook_commit_hook=Module[\"_libhook_commit_hook\"]=wasmExports[\"kf\"];_libhook_update_hook=Module[\"_libhook_update_hook\"]=wasmExports[\"lf\"];_libprogress_progress_handler=Module[\"_libprogress_progress_handler\"]=wasmExports[\"mf\"];_libvfs_vfs_register=Module[\"_libvfs_vfs_register\"]=wasmExports[\"nf\"];_memcpy=Module[\"_memcpy\"]=wasmExports[\"of\"];_memset=Module[\"_memset\"]=wasmExports[\"pf\"];_emscripten_builtin_memalign=wasmExports[\"rf\"];__emscripten_timeout=wasmExports[\"sf\"];__emscripten_tempret_get=wasmExports[\"tf\"];__emscripten_stack_restore=wasmExports[\"uf\"];__emscripten_stack_alloc=wasmExports[\"vf\"];_emscripten_stack_get_current=wasmExports[\"wf\"];dynCall_viiiij=wasmExports[\"dynCall_viiiij\"];dynCall_vijii=wasmExports[\"dynCall_vijii\"];dynCall_iiiij=wasmExports[\"dynCall_iiiij\"];dynCall_viji=wasmExports[\"dynCall_viji\"];dynCall_iij=wasmExports[\"dynCall_iij\"];dynCall_iijii=wasmExports[\"dynCall_iijii\"];dynCall_iiji=wasmExports[\"dynCall_iiji\"];dynCall_iiiiiij=wasmExports[\"dynCall_iiiiiij\"];dynCall_iiij=wasmExports[\"dynCall_iiij\"];dynCall_jii=wasmExports[\"dynCall_jii\"];dynCall_ji=wasmExports[\"dynCall_ji\"];dynCall_vij=wasmExports[\"dynCall_vij\"];dynCall_iiiiijii=wasmExports[\"dynCall_iiiiijii\"];dynCall_j=wasmExports[\"dynCall_j\"];dynCall_jj=wasmExports[\"dynCall_jj\"];dynCall_jiij=wasmExports[\"dynCall_jiij\"];dynCall_iiiiji=wasmExports[\"dynCall_iiiiji\"];dynCall_iiiijii=wasmExports[\"dynCall_iiiijii\"];dynCall_ij=wasmExports[\"dynCall_ij\"];dynCall_viiji=wasmExports[\"dynCall_viiji\"];dynCall_viijii=wasmExports[\"dynCall_viijii\"];dynCall_iiiijji=wasmExports[\"dynCall_iiiijji\"];memory=wasmMemory=wasmExports[\"pa\"];_sqlite3_version=Module[\"_sqlite3_version\"]=wasmExports[\"df\"].value;__indirect_function_table=wasmTable=wasmExports[\"qf\"]}var wasmImports={a:___assert_fail,aa:___syscall_chmod,da:___syscall_faccessat,ba:___syscall_fchmod,$:___syscall_fchown32,b:___syscall_fcntl64,_:___syscall_fstat64,y:___syscall_ftruncate64,U:___syscall_getcwd,Y:___syscall_lstat64,R:___syscall_mkdirat,X:___syscall_newfstatat,P:___syscall_openat,N:___syscall_readlinkat,M:___syscall_rmdir,Z:___syscall_stat64,K:___syscall_unlinkat,J:___syscall_utimensat,F:__abort_js,E:__emscripten_runtime_keepalive_clear,w:__localtime_js,u:__mmap_js,v:__munmap_js,G:__setitimer_js,Q:__tzset_js,n:_emscripten_date_now,g:_emscripten_get_now,H:_emscripten_resize_heap,S:_environ_get,T:_environ_sizes_get,o:_fd_close,I:_fd_fdstat_get,O:_fd_read,x:_fd_seek,V:_fd_sync,L:_fd_write,s:_ipp,t:_ipp_async,ka:_ippipppp,oa:_ippipppp_async,j:_ippp,k:_ippp_async,c:_ipppi,d:_ipppi_async,ga:_ipppiii,ha:_ipppiii_async,ia:_ipppiiip,ja:_ipppiiip_async,h:_ipppip,i:_ipppip_async,z:_ipppj,A:_ipppj_async,e:_ipppp,f:_ipppp_async,ea:_ippppi,fa:_ippppi_async,B:_ippppij,C:_ippppij_async,p:_ippppip,q:_ippppip_async,la:_ipppppip,ma:_ipppppip_async,D:_proc_exit,na:_vppippii,r:_vppippii_async,l:_vppp,m:_vppp_async,W:_vpppip,ca:_vpppip_async};function callMain(){var entryFunction=_main;var argc=0;var argv=0;try{var ret=entryFunction(argc,argv);exitJS(ret,true);return ret}catch(e){return handleException(e)}}function run(){if(runDependencies>0){dependenciesFulfilled=run;return}preRun();if(runDependencies>0){dependenciesFulfilled=run;return}function doRun(){Module[\"calledRun\"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve?.(Module);Module[\"onRuntimeInitialized\"]?.();var noInitialRun=Module[\"noInitialRun\"]||false;if(!noInitialRun)callMain();postRun()}if(Module[\"setStatus\"]){Module[\"setStatus\"](\"Running...\");setTimeout(()=>{setTimeout(()=>Module[\"setStatus\"](\"\"),1);doRun()},1)}else{doRun()}}var wasmExports;wasmExports=await (createWasm());run();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"set_authorizer\"]=function(db,xAuthorizer,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xAuthorizer instanceof AsyncFunction?1:0,\"i32\");const result=ccall(\"libauthorizer_set_authorizer\",\"number\",[\"number\",\"number\",\"number\"],[db,xAuthorizer?1:0,pAsyncFlags]);if(!result&&xAuthorizer){Module[\"setCallback\"](pAsyncFlags,(_,iAction,p3,p4,p5,p6)=>xAuthorizer(pApp,iAction,p3,p4,p5,p6))}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;const FUNC_METHODS=[\"xFunc\",\"xStep\",\"xFinal\"];const mapFunctionNameToKey=new Map;Module[\"create_function\"]=function(db,zFunctionName,nArg,eTextRep,pApp,xFunc,xStep,xFinal){const pAsyncFlags=Module[\"_sqlite3_malloc\"](4);const target={xFunc,xStep,xFinal};setValue(pAsyncFlags,FUNC_METHODS.reduce((mask,method,i)=>{if(target[method]instanceof AsyncFunction){return mask|1<<i}return mask},0),\"i32\");const result=ccall(\"libfunction_create_function\",\"number\",[\"number\",\"string\",\"number\",\"number\",\"number\",\"number\",\"number\",\"number\"],[db,zFunctionName,nArg,eTextRep,pAsyncFlags,xFunc?1:0,xStep?1:0,xFinal?1:0]);if(!result){if(mapFunctionNameToKey.has(zFunctionName)){const oldKey=mapFunctionNameToKey.get(zFunctionName);Module[\"deleteCallback\"](oldKey)}mapFunctionNameToKey.set(zFunctionName,pAsyncFlags);Module[\"setCallback\"](pAsyncFlags,{xFunc,xStep,xFinal})}return result}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"update_hook\"]=function(db,xUpdateHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xUpdateHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_update_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xUpdateHook?1:0,pAsyncFlags]);if(xUpdateHook){Module[\"setCallback\"](pAsyncFlags,(_,iUpdateType,dbName,tblName,lo32,hi32)=>xUpdateHook(iUpdateType,dbName,tblName,lo32,hi32))}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"commit_hook\"]=function(db,xCommitHook){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xCommitHook instanceof AsyncFunction?1:0,\"i32\");ccall(\"libhook_commit_hook\",\"void\",[\"number\",\"number\",\"number\"],[db,xCommitHook?1:0,pAsyncFlags]);if(xCommitHook){Module[\"setCallback\"](pAsyncFlags,_=>xCommitHook())}}})();(function(){const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;let pAsyncFlags=0;Module[\"progress_handler\"]=function(db,nOps,xProgress,pApp){if(pAsyncFlags){Module[\"deleteCallback\"](pAsyncFlags);Module[\"_sqlite3_free\"](pAsyncFlags);pAsyncFlags=0}pAsyncFlags=Module[\"_sqlite3_malloc\"](4);setValue(pAsyncFlags,xProgress instanceof AsyncFunction?1:0,\"i32\");ccall(\"libprogress_progress_handler\",\"number\",[\"number\",\"number\",\"number\",\"number\"],[db,nOps,xProgress?1:0,pAsyncFlags]);if(xProgress){Module[\"setCallback\"](pAsyncFlags,_=>xProgress(pApp))}}})();(function(){const VFS_METHODS=[\"xOpen\",\"xDelete\",\"xAccess\",\"xFullPathname\",\"xRandomness\",\"xSleep\",\"xCurrentTime\",\"xGetLastError\",\"xCurrentTimeInt64\",\"xClose\",\"xRead\",\"xWrite\",\"xTruncate\",\"xSync\",\"xFileSize\",\"xLock\",\"xUnlock\",\"xCheckReservedLock\",\"xFileControl\",\"xSectorSize\",\"xDeviceCharacteristics\",\"xShmMap\",\"xShmLock\",\"xShmBarrier\",\"xShmUnmap\"];const mapVFSNameToKey=new Map;Module[\"vfs_register\"]=function(vfs,makeDefault){let methodMask=0;let asyncMask=0;VFS_METHODS.forEach((method,i)=>{if(vfs[method]){methodMask|=1<<i;if(vfs[\"hasAsyncMethod\"](method)){asyncMask|=1<<i}}});const vfsReturn=Module[\"_sqlite3_malloc\"](4);try{const result=ccall(\"libvfs_vfs_register\",\"number\",[\"string\",\"number\",\"number\",\"number\",\"number\",\"number\"],[vfs.name,vfs.mxPathname,methodMask,asyncMask,makeDefault?1:0,vfsReturn]);if(!result){if(mapVFSNameToKey.has(vfs.name)){const oldKey=mapVFSNameToKey.get(vfs.name);Module[\"deleteCallback\"](oldKey)}const key=getValue(vfsReturn,\"*\");mapVFSNameToKey.set(vfs.name,key);Module[\"setCallback\"](key,vfs)}return result}finally{Module[\"_sqlite3_free\"](vfsReturn)}}})();if(runtimeInitialized){moduleRtn=Module}else{moduleRtn=new Promise((resolve,reject)=>{readyPromiseResolve=resolve;readyPromiseReject=reject})}\n;return moduleRtn}export default Module;\n","const TypedArrayPrototypeGetSymbolToStringTag = (() => {\n    const g = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array.prototype), Symbol.toStringTag).get;\n    return (value) => g.call(value);\n})();\nfunction isUint8Array(value) {\n    return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\nfunction isAnyArrayBuffer(value) {\n    return (typeof value === 'object' &&\n        value != null &&\n        Symbol.toStringTag in value &&\n        (value[Symbol.toStringTag] === 'ArrayBuffer' ||\n            value[Symbol.toStringTag] === 'SharedArrayBuffer'));\n}\nfunction isRegExp(regexp) {\n    return regexp instanceof RegExp || Object.prototype.toString.call(regexp) === '[object RegExp]';\n}\nfunction isMap(value) {\n    return (typeof value === 'object' &&\n        value != null &&\n        Symbol.toStringTag in value &&\n        value[Symbol.toStringTag] === 'Map');\n}\nfunction isDate(date) {\n    return date instanceof Date || Object.prototype.toString.call(date) === '[object Date]';\n}\nfunction defaultInspect(x, _options) {\n    return JSON.stringify(x, (k, v) => {\n        if (typeof v === 'bigint') {\n            return { $numberLong: `${v}` };\n        }\n        else if (isMap(v)) {\n            return Object.fromEntries(v);\n        }\n        return v;\n    });\n}\nfunction getStylizeFunction(options) {\n    const stylizeExists = options != null &&\n        typeof options === 'object' &&\n        'stylize' in options &&\n        typeof options.stylize === 'function';\n    if (stylizeExists) {\n        return options.stylize;\n    }\n}\n\nconst BSON_MAJOR_VERSION = 6;\nconst BSON_VERSION_SYMBOL = Symbol.for('@@mdb.bson.version');\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -2147483648;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\n\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return 'BSONError';\n    }\n    constructor(message, options) {\n        super(message, options);\n    }\n    static isBSONError(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            'bsonError' in value &&\n            value.bsonError === true &&\n            'name' in value &&\n            'message' in value &&\n            'stack' in value);\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return 'BSONVersionError';\n    }\n    constructor() {\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return 'BSONRuntimeError';\n    }\n    constructor(message) {\n        super(message);\n    }\n}\nclass BSONOffsetError extends BSONError {\n    get name() {\n        return 'BSONOffsetError';\n    }\n    constructor(message, offset, options) {\n        super(`${message}. offset: ${offset}`, options);\n        this.offset = offset;\n    }\n}\n\nlet TextDecoderFatal;\nlet TextDecoderNonFatal;\nfunction parseUtf8(buffer, start, end, fatal) {\n    if (fatal) {\n        TextDecoderFatal ??= new TextDecoder('utf8', { fatal: true });\n        try {\n            return TextDecoderFatal.decode(buffer.subarray(start, end));\n        }\n        catch (cause) {\n            throw new BSONError('Invalid UTF-8 string in BSON document', { cause });\n        }\n    }\n    TextDecoderNonFatal ??= new TextDecoder('utf8', { fatal: false });\n    return TextDecoderNonFatal.decode(buffer.subarray(start, end));\n}\n\nfunction tryReadBasicLatin(uint8array, start, end) {\n    if (uint8array.length === 0) {\n        return '';\n    }\n    const stringByteLength = end - start;\n    if (stringByteLength === 0) {\n        return '';\n    }\n    if (stringByteLength > 20) {\n        return null;\n    }\n    if (stringByteLength === 1 && uint8array[start] < 128) {\n        return String.fromCharCode(uint8array[start]);\n    }\n    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {\n        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);\n    }\n    if (stringByteLength === 3 &&\n        uint8array[start] < 128 &&\n        uint8array[start + 1] < 128 &&\n        uint8array[start + 2] < 128) {\n        return (String.fromCharCode(uint8array[start]) +\n            String.fromCharCode(uint8array[start + 1]) +\n            String.fromCharCode(uint8array[start + 2]));\n    }\n    const latinBytes = [];\n    for (let i = start; i < end; i++) {\n        const byte = uint8array[i];\n        if (byte > 127) {\n            return null;\n        }\n        latinBytes.push(byte);\n    }\n    return String.fromCharCode(...latinBytes);\n}\nfunction tryWriteBasicLatin(destination, source, offset) {\n    if (source.length === 0)\n        return 0;\n    if (source.length > 25)\n        return null;\n    if (destination.length - offset < source.length)\n        return null;\n    for (let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++) {\n        const char = source.charCodeAt(charOffset);\n        if (char > 127)\n            return null;\n        destination[destinationOffset] = char;\n    }\n    return source.length;\n}\n\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = nodejsMathRandomBytes;\nconst nodeJsByteUtils = {\n    toLocalBufferType(potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from the passed potentialBuffer.`);\n    },\n    allocate(size) {\n        return Buffer.alloc(size);\n    },\n    allocateUnsafe(size) {\n        return Buffer.allocUnsafe(size);\n    },\n    equals(a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray(array) {\n        return Buffer.from(array);\n    },\n    fromBase64(base64) {\n        return Buffer.from(base64, 'base64');\n    },\n    toBase64(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');\n    },\n    fromISO88591(codePoints) {\n        return Buffer.from(codePoints, 'binary');\n    },\n    toISO88591(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');\n    },\n    fromHex(hex) {\n        return Buffer.from(hex, 'hex');\n    },\n    toHex(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');\n    },\n    toUTF8(buffer, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        const string = nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8', start, end);\n        if (fatal) {\n            for (let i = 0; i < string.length; i++) {\n                if (string.charCodeAt(i) === 0xfffd) {\n                    parseUtf8(buffer, start, end, true);\n                    break;\n                }\n            }\n        }\n        return string;\n    },\n    utf8ByteLength(input) {\n        return Buffer.byteLength(input, 'utf8');\n    },\n    encodeUTF8Into(buffer, source, byteOffset) {\n        const latinBytesWritten = tryWriteBasicLatin(buffer, source, byteOffset);\n        if (latinBytesWritten != null) {\n            return latinBytesWritten;\n        }\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');\n    },\n    randomBytes: nodejsRandomBytes,\n    swap32(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).swap32();\n    }\n};\n\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === 'object' && navigator.product === 'ReactNative';\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (() => {\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === 'function') {\n        return (byteLength) => {\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    }\n    else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.('BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType(potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ??\n            Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === 'Uint8Array') {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from passed potentialBuffer.`);\n    },\n    allocate(size) {\n        if (typeof size !== 'number') {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    allocateUnsafe(size) {\n        return webByteUtils.allocate(size);\n    },\n    equals(a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < a.byteLength; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray(array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64(base64) {\n        return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n    },\n    toBase64(uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591(codePoints) {\n        return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff);\n    },\n    toISO88591(uint8array) {\n        return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join('');\n    },\n    fromHex(hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for (let i = 0; i < evenLengthHex.length; i += 2) {\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex(uint8array) {\n        return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join('');\n    },\n    toUTF8(uint8array, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        return parseUtf8(uint8array, start, end, fatal);\n    },\n    utf8ByteLength(input) {\n        return new TextEncoder().encode(input).byteLength;\n    },\n    encodeUTF8Into(uint8array, source, byteOffset) {\n        const bytes = new TextEncoder().encode(source);\n        uint8array.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes,\n    swap32(buffer) {\n        if (buffer.length % 4 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 32-bits');\n        }\n        for (let i = 0; i < buffer.length; i += 4) {\n            const byte0 = buffer[i];\n            const byte1 = buffer[i + 1];\n            const byte2 = buffer[i + 2];\n            const byte3 = buffer[i + 3];\n            buffer[i] = byte3;\n            buffer[i + 1] = byte2;\n            buffer[i + 2] = byte1;\n            buffer[i + 3] = byte0;\n        }\n        return buffer;\n    }\n};\n\nconst hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\n\nclass BSONValue {\n    get [BSON_VERSION_SYMBOL]() {\n        return BSON_MAJOR_VERSION;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')](depth, options, inspect) {\n        return this.inspect(depth, options, inspect);\n    }\n}\n\nconst FLOAT = new Float64Array(1);\nconst FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);\nFLOAT[0] = -1;\nconst isBigEndian = FLOAT_BYTES[7] === 0;\nconst NumberUtils = {\n    isBigEndian,\n    getNonnegativeInt32LE(source, offset) {\n        if (source[offset + 3] > 127) {\n            throw new RangeError(`Size cannot be negative at offset: ${offset}`);\n        }\n        return (source[offset] |\n            (source[offset + 1] << 8) |\n            (source[offset + 2] << 16) |\n            (source[offset + 3] << 24));\n    },\n    getInt32LE(source, offset) {\n        return (source[offset] |\n            (source[offset + 1] << 8) |\n            (source[offset + 2] << 16) |\n            (source[offset + 3] << 24));\n    },\n    getUint32LE(source, offset) {\n        return (source[offset] +\n            source[offset + 1] * 256 +\n            source[offset + 2] * 65536 +\n            source[offset + 3] * 16777216);\n    },\n    getUint32BE(source, offset) {\n        return (source[offset + 3] +\n            source[offset + 2] * 256 +\n            source[offset + 1] * 65536 +\n            source[offset] * 16777216);\n    },\n    getBigInt64LE(source, offset) {\n        const hi = BigInt(source[offset + 4] +\n            source[offset + 5] * 256 +\n            source[offset + 6] * 65536 +\n            (source[offset + 7] << 24));\n        const lo = BigInt(source[offset] +\n            source[offset + 1] * 256 +\n            source[offset + 2] * 65536 +\n            source[offset + 3] * 16777216);\n        return (hi << BigInt(32)) + lo;\n    },\n    getFloat64LE: isBigEndian\n        ? (source, offset) => {\n            FLOAT_BYTES[7] = source[offset];\n            FLOAT_BYTES[6] = source[offset + 1];\n            FLOAT_BYTES[5] = source[offset + 2];\n            FLOAT_BYTES[4] = source[offset + 3];\n            FLOAT_BYTES[3] = source[offset + 4];\n            FLOAT_BYTES[2] = source[offset + 5];\n            FLOAT_BYTES[1] = source[offset + 6];\n            FLOAT_BYTES[0] = source[offset + 7];\n            return FLOAT[0];\n        }\n        : (source, offset) => {\n            FLOAT_BYTES[0] = source[offset];\n            FLOAT_BYTES[1] = source[offset + 1];\n            FLOAT_BYTES[2] = source[offset + 2];\n            FLOAT_BYTES[3] = source[offset + 3];\n            FLOAT_BYTES[4] = source[offset + 4];\n            FLOAT_BYTES[5] = source[offset + 5];\n            FLOAT_BYTES[6] = source[offset + 6];\n            FLOAT_BYTES[7] = source[offset + 7];\n            return FLOAT[0];\n        },\n    setInt32BE(destination, offset, value) {\n        destination[offset + 3] = value;\n        value >>>= 8;\n        destination[offset + 2] = value;\n        value >>>= 8;\n        destination[offset + 1] = value;\n        value >>>= 8;\n        destination[offset] = value;\n        return 4;\n    },\n    setInt32LE(destination, offset, value) {\n        destination[offset] = value;\n        value >>>= 8;\n        destination[offset + 1] = value;\n        value >>>= 8;\n        destination[offset + 2] = value;\n        value >>>= 8;\n        destination[offset + 3] = value;\n        return 4;\n    },\n    setBigInt64LE(destination, offset, value) {\n        const mask32bits = BigInt(0xffff_ffff);\n        let lo = Number(value & mask32bits);\n        destination[offset] = lo;\n        lo >>= 8;\n        destination[offset + 1] = lo;\n        lo >>= 8;\n        destination[offset + 2] = lo;\n        lo >>= 8;\n        destination[offset + 3] = lo;\n        let hi = Number((value >> BigInt(32)) & mask32bits);\n        destination[offset + 4] = hi;\n        hi >>= 8;\n        destination[offset + 5] = hi;\n        hi >>= 8;\n        destination[offset + 6] = hi;\n        hi >>= 8;\n        destination[offset + 7] = hi;\n        return 8;\n    },\n    setFloat64LE: isBigEndian\n        ? (destination, offset, value) => {\n            FLOAT[0] = value;\n            destination[offset] = FLOAT_BYTES[7];\n            destination[offset + 1] = FLOAT_BYTES[6];\n            destination[offset + 2] = FLOAT_BYTES[5];\n            destination[offset + 3] = FLOAT_BYTES[4];\n            destination[offset + 4] = FLOAT_BYTES[3];\n            destination[offset + 5] = FLOAT_BYTES[2];\n            destination[offset + 6] = FLOAT_BYTES[1];\n            destination[offset + 7] = FLOAT_BYTES[0];\n            return 8;\n        }\n        : (destination, offset, value) => {\n            FLOAT[0] = value;\n            destination[offset] = FLOAT_BYTES[0];\n            destination[offset + 1] = FLOAT_BYTES[1];\n            destination[offset + 2] = FLOAT_BYTES[2];\n            destination[offset + 3] = FLOAT_BYTES[3];\n            destination[offset + 4] = FLOAT_BYTES[4];\n            destination[offset + 5] = FLOAT_BYTES[5];\n            destination[offset + 6] = FLOAT_BYTES[6];\n            destination[offset + 7] = FLOAT_BYTES[7];\n            return 8;\n        }\n};\n\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return 'Binary';\n    }\n    constructor(buffer, subType) {\n        super();\n        if (!(buffer == null) &&\n            typeof buffer === 'string' &&\n            !ArrayBuffer.isView(buffer) &&\n            !isAnyArrayBuffer(buffer) &&\n            !Array.isArray(buffer)) {\n            throw new BSONError('Binary can only be constructed from Uint8Array or number[]');\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        }\n        else {\n            this.buffer = Array.isArray(buffer)\n                ? ByteUtils.fromNumberArray(buffer)\n                : ByteUtils.toLocalBufferType(buffer);\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === 'string' && byteValue.length !== 1) {\n            throw new BSONError('only accepts single character String');\n        }\n        else if (typeof byteValue !== 'number' && byteValue.length !== 1)\n            throw new BSONError('only accepts single character Uint8Array or Array');\n        let decodedByte;\n        if (typeof byteValue === 'string') {\n            decodedByte = byteValue.charCodeAt(0);\n        }\n        else if (typeof byteValue === 'number') {\n            decodedByte = byteValue;\n        }\n        else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError('only accepts number in a valid unsigned byte range 0-255');\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        }\n        else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === 'number' ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position =\n                offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        }\n        else if (typeof sequence === 'string') {\n            throw new BSONError('input cannot be string');\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        const end = position + length;\n        return this.buffer.subarray(position, end > this.position ? this.position : end);\n    }\n    value() {\n        return this.buffer.length === this.position\n            ? this.buffer\n            : this.buffer.subarray(0, this.position);\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.buffer.subarray(0, this.position));\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        if (encoding === 'utf8' || encoding === 'utf-8')\n            return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (this.sub_type === Binary.SUBTYPE_VECTOR) {\n            validateBinaryVector(this);\n        }\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? '0' + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? '0' + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.subarray(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if ('$binary' in doc) {\n            if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            }\n            else {\n                if (typeof doc.$binary !== 'string') {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        }\n        else if ('$uuid' in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        const base64Arg = inspect(base64, options);\n        const subTypeArg = inspect(this.sub_type, options);\n        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;\n    }\n    toInt8Array() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.Int8) {\n            throw new BSONError('Binary datatype field is not Int8');\n        }\n        validateBinaryVector(this);\n        return new Int8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));\n    }\n    toFloat32Array() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.Float32) {\n            throw new BSONError('Binary datatype field is not Float32');\n        }\n        validateBinaryVector(this);\n        const floatBytes = new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));\n        if (NumberUtils.isBigEndian)\n            ByteUtils.swap32(floatBytes);\n        return new Float32Array(floatBytes.buffer);\n    }\n    toPackedBits() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {\n            throw new BSONError('Binary datatype field is not packed bit');\n        }\n        validateBinaryVector(this);\n        return new Uint8Array(this.buffer.buffer.slice(this.buffer.byteOffset + 2, this.buffer.byteOffset + this.position));\n    }\n    toBits() {\n        if (this.sub_type !== Binary.SUBTYPE_VECTOR) {\n            throw new BSONError('Binary sub_type is not Vector');\n        }\n        if (this.buffer[0] !== Binary.VECTOR_TYPE.PackedBit) {\n            throw new BSONError('Binary datatype field is not packed bit');\n        }\n        validateBinaryVector(this);\n        const byteCount = this.length() - 2;\n        const bitCount = byteCount * 8 - this.buffer[1];\n        const bits = new Int8Array(bitCount);\n        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {\n            const byteOffset = (bitOffset / 8) | 0;\n            const byte = this.buffer[byteOffset + 2];\n            const shift = 7 - (bitOffset % 8);\n            const bit = (byte >> shift) & 1;\n            bits[bitOffset] = bit;\n        }\n        return bits;\n    }\n    static fromInt8Array(array) {\n        const buffer = ByteUtils.allocate(array.byteLength + 2);\n        buffer[0] = Binary.VECTOR_TYPE.Int8;\n        buffer[1] = 0;\n        const intBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        buffer.set(intBytes, 2);\n        const bin = new this(buffer, this.SUBTYPE_VECTOR);\n        validateBinaryVector(bin);\n        return bin;\n    }\n    static fromFloat32Array(array) {\n        const binaryBytes = ByteUtils.allocate(array.byteLength + 2);\n        binaryBytes[0] = Binary.VECTOR_TYPE.Float32;\n        binaryBytes[1] = 0;\n        const floatBytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        binaryBytes.set(floatBytes, 2);\n        if (NumberUtils.isBigEndian)\n            ByteUtils.swap32(new Uint8Array(binaryBytes.buffer, 2));\n        const bin = new this(binaryBytes, this.SUBTYPE_VECTOR);\n        validateBinaryVector(bin);\n        return bin;\n    }\n    static fromPackedBits(array, padding = 0) {\n        const buffer = ByteUtils.allocate(array.byteLength + 2);\n        buffer[0] = Binary.VECTOR_TYPE.PackedBit;\n        buffer[1] = padding;\n        buffer.set(array, 2);\n        const bin = new this(buffer, this.SUBTYPE_VECTOR);\n        validateBinaryVector(bin);\n        return bin;\n    }\n    static fromBits(bits) {\n        const byteLength = (bits.length + 7) >>> 3;\n        const bytes = new Uint8Array(byteLength + 2);\n        bytes[0] = Binary.VECTOR_TYPE.PackedBit;\n        const remainder = bits.length % 8;\n        bytes[1] = remainder === 0 ? 0 : 8 - remainder;\n        for (let bitOffset = 0; bitOffset < bits.length; bitOffset++) {\n            const byteOffset = bitOffset >>> 3;\n            const bit = bits[bitOffset];\n            if (bit !== 0 && bit !== 1) {\n                throw new BSONError(`Invalid bit value at ${bitOffset}: must be 0 or 1, found ${bits[bitOffset]}`);\n            }\n            if (bit === 0)\n                continue;\n            const shift = 7 - (bitOffset % 8);\n            bytes[byteOffset + 2] |= bit << shift;\n        }\n        return new this(bytes, Binary.SUBTYPE_VECTOR);\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_SENSITIVE = 8;\nBinary.SUBTYPE_VECTOR = 9;\nBinary.SUBTYPE_USER_DEFINED = 128;\nBinary.VECTOR_TYPE = Object.freeze({\n    Int8: 0x03,\n    Float32: 0x27,\n    PackedBit: 0x10\n});\nfunction validateBinaryVector(vector) {\n    if (vector.sub_type !== Binary.SUBTYPE_VECTOR)\n        return;\n    const size = vector.position;\n    const datatype = vector.buffer[0];\n    const padding = vector.buffer[1];\n    if ((datatype === Binary.VECTOR_TYPE.Float32 || datatype === Binary.VECTOR_TYPE.Int8) &&\n        padding !== 0) {\n        throw new BSONError('Invalid Vector: padding must be zero for int8 and float32 vectors');\n    }\n    if (datatype === Binary.VECTOR_TYPE.Float32) {\n        if (size !== 0 && size - 2 !== 0 && (size - 2) % 4 !== 0) {\n            throw new BSONError('Invalid Vector: Float32 vector must contain a multiple of 4 bytes');\n        }\n    }\n    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding !== 0 && size === 2) {\n        throw new BSONError('Invalid Vector: padding must be zero for packed bit vectors that are empty');\n    }\n    if (datatype === Binary.VECTOR_TYPE.PackedBit && padding > 7) {\n        throw new BSONError(`Invalid Vector: padding must be a value between 0 and 7. found: ${padding}`);\n    }\n}\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input) {\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        }\n        else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        }\n        else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        }\n        else if (typeof input === 'string') {\n            bytes = UUID.bytesFromString(input);\n        }\n        else {\n            throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join('-');\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.id);\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        }\n        catch {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = (bytes[6] & 0x0f) | 0x40;\n        bytes[8] = (bytes[8] & 0x3f) | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === 'string') {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return (input._bsontype === 'Binary' &&\n            input.sub_type === this.SUBTYPE_UUID &&\n            input.buffer.byteLength === 16);\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, ''));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new UUID(${inspect(this.toHexString(), options)})`;\n    }\n}\n\nclass Code extends BSONValue {\n    get _bsontype() {\n        return 'Code';\n    }\n    constructor(code, scope) {\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return { code: this.code, scope: this.scope };\n        }\n        return { code: this.code };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return { $code: this.code, $scope: this.scope };\n        }\n        return { $code: this.code };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        let parametersString = inspect(this.code, options);\n        const multiLineFn = parametersString.includes('\\n');\n        if (this.scope != null) {\n            parametersString += `,${multiLineFn ? '\\n' : ' '}${inspect(this.scope, options)}`;\n        }\n        const endingNewline = multiLineFn && this.scope === null;\n        return `new Code(${multiLineFn ? '\\n' : ''}${parametersString}${endingNewline ? '\\n' : ''})`;\n    }\n}\n\nfunction isDBRefLike(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '$id' in value &&\n        value.$id != null &&\n        '$ref' in value &&\n        typeof value.$ref === 'string' &&\n        (!('$db' in value) || ('$db' in value && typeof value.$db === 'string')));\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return 'DBRef';\n    }\n    constructor(collection, oid, db, fields) {\n        super();\n        const parts = collection.split('.');\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null)\n            o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db)\n            o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const args = [\n            inspect(this.namespace, options),\n            inspect(this.oid, options),\n            ...(this.db ? [inspect(this.db, options)] : []),\n            ...(Object.keys(this.fields).length > 0 ? [inspect(this.fields, options)] : [])\n        ];\n        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];\n        return `new DBRef(${args.join(', ')})`;\n    }\n}\n\nfunction removeLeadingZerosAndExplicitPlus(str) {\n    if (str === '') {\n        return str;\n    }\n    let startIndex = 0;\n    const isNegative = str[startIndex] === '-';\n    const isExplicitlyPositive = str[startIndex] === '+';\n    if (isExplicitlyPositive || isNegative) {\n        startIndex += 1;\n    }\n    let foundInsignificantZero = false;\n    for (; startIndex < str.length && str[startIndex] === '0'; ++startIndex) {\n        foundInsignificantZero = true;\n    }\n    if (!foundInsignificantZero) {\n        return isExplicitlyPositive ? str.slice(1) : str;\n    }\n    return `${isNegative ? '-' : ''}${str.length === startIndex ? '0' : str.slice(startIndex)}`;\n}\nfunction validateStringCharacters(str, radix) {\n    radix = radix ?? 10;\n    const validCharacters = '0123456789abcdefghijklmnopqrstuvwxyz'.slice(0, radix);\n    const regex = new RegExp(`[^-+${validCharacters}]`, 'i');\n    return regex.test(str) ? false : str;\n}\n\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n}\ncatch {\n}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return 'Long';\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(lowOrValue = 0, highOrUnsigned, unsigned) {\n        super();\n        const unsignedBool = typeof highOrUnsigned === 'boolean' ? highOrUnsigned : Boolean(unsigned);\n        const high = typeof highOrUnsigned === 'number' ? highOrUnsigned : 0;\n        const res = typeof lowOrValue === 'string'\n            ? Long.fromString(lowOrValue, unsignedBool)\n            : typeof lowOrValue === 'bigint'\n                ? Long.fromBigInt(lowOrValue, unsignedBool)\n                : { low: lowOrValue | 0, high: high | 0, unsigned: unsignedBool };\n        this.low = res.low;\n        this.high = res.high;\n        this.unsigned = res.unsigned;\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if ((cache = 0 <= value && value < 256)) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache)\n                UINT_CACHE[value] = obj;\n            return obj;\n        }\n        else {\n            value |= 0;\n            if ((cache = -128 <= value && value < 128)) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache)\n                INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value))\n            return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0)\n                return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL)\n                return Long.MAX_UNSIGNED_VALUE;\n        }\n        else {\n            if (value <= -9223372036854776e3)\n                return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL)\n                return Long.MAX_VALUE;\n        }\n        if (value < 0)\n            return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        const FROM_BIGINT_BIT_MASK = BigInt(0xffffffff);\n        const FROM_BIGINT_BIT_SHIFT = BigInt(32);\n        return new Long(Number(value & FROM_BIGINT_BIT_MASK), Number((value >> FROM_BIGINT_BIT_SHIFT) & FROM_BIGINT_BIT_MASK), unsigned);\n    }\n    static _fromString(str, unsigned, radix) {\n        if (str.length === 0)\n            throw new BSONError('empty string');\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        let p;\n        if ((p = str.indexOf('-')) > 0)\n            throw new BSONError('interior hyphen');\n        else if (p === 0) {\n            return Long._fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for (let i = 0; i < str.length; i += 8) {\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            }\n            else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromStringStrict(str, unsignedOrRadix, radix) {\n        let unsigned = false;\n        if (typeof unsignedOrRadix === 'number') {\n            (radix = unsignedOrRadix), (unsignedOrRadix = false);\n        }\n        else {\n            unsigned = !!unsignedOrRadix;\n        }\n        radix ??= 10;\n        if (str.trim() !== str) {\n            throw new BSONError(`Input: '${str}' contains leading and/or trailing whitespace`);\n        }\n        if (!validateStringCharacters(str, radix)) {\n            throw new BSONError(`Input: '${str}' contains invalid characters for radix: ${radix}`);\n        }\n        const cleanedStr = removeLeadingZerosAndExplicitPlus(str);\n        const result = Long._fromString(cleanedStr, unsigned, radix);\n        if (result.toString(radix).toLowerCase() !== cleanedStr.toLowerCase()) {\n            throw new BSONError(`Input: ${str} is not representable as ${result.unsigned ? 'an unsigned' : 'a signed'} 64-bit Long ${radix != null ? `with radix: ${radix}` : ''}`);\n        }\n        return result;\n    }\n    static fromString(str, unsignedOrRadix, radix) {\n        let unsigned = false;\n        if (typeof unsignedOrRadix === 'number') {\n            (radix = unsignedOrRadix), (unsignedOrRadix = false);\n        }\n        else {\n            unsigned = !!unsignedOrRadix;\n        }\n        radix ??= 10;\n        if (str === 'NaN' && radix < 24) {\n            return Long.ZERO;\n        }\n        else if ((str === 'Infinity' || str === '+Infinity' || str === '-Infinity') && radix < 35) {\n            return Long.ZERO;\n        }\n        return Long._fromString(str, unsigned, radix);\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24), bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24), unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7], (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            '__isLong__' in value &&\n            value.__isLong__ === true);\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === 'number')\n            return Long.fromNumber(val, unsigned);\n        if (typeof val === 'string')\n            return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend))\n            addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.eq(other))\n            return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg)\n            return -1;\n        if (!thisNeg && otherNeg)\n            return 1;\n        if (!this.unsigned)\n            return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 ||\n            (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n            ? -1\n            : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (divisor.isZero())\n            throw new BSONError('division by zero');\n        if (wasm) {\n            if (!this.unsigned &&\n                this.high === -2147483648 &&\n                divisor.low === -1 &&\n                divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero())\n            return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))\n                    return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE))\n                    return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    }\n                    else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            }\n            else if (divisor.eq(Long.MIN_VALUE))\n                return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative())\n                    return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            }\n            else if (divisor.isNegative())\n                return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        }\n        else {\n            if (!divisor.unsigned)\n                divisor = divisor.toUnsigned();\n            if (divisor.gt(this))\n                return Long.UZERO;\n            if (divisor.gt(this.shru(1)))\n                return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while (rem.gte(divisor)) {\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero())\n                approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n            return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for (bit = 31; bit > 0; bit--)\n            if ((val & (1 << bit)) !== 0)\n                break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero())\n            return Long.ZERO;\n        if (!Long.isLong(multiplier))\n            multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero())\n            return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE))\n            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE))\n            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative())\n                return this.neg().mul(multiplier.neg());\n            else\n                return this.neg().mul(multiplier).neg();\n        }\n        else if (multiplier.isNegative())\n            return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))\n            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE))\n            return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n        else\n            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n        else\n            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0)\n            return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\n            }\n            else if (numBits === 32)\n                return Long.fromBits(high, 0, this.unsigned);\n            else\n                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend))\n            subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned)\n            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            (lo >>> 8) & 0xff,\n            (lo >>> 16) & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            (hi >>> 8) & 0xff,\n            (hi >>> 16) & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            (hi >>> 16) & 0xff,\n            (hi >>> 8) & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            (lo >>> 16) & 0xff,\n            (lo >>> 8) & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        if (this.isZero())\n            return '0';\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            }\n            else\n                return '-' + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = '';\n        while (true) {\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            }\n            else {\n                while (digits.length < 6)\n                    digits = '0' + digits;\n                result = '' + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed)\n            return this.toNumber();\n        return { $numberLong: this.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = { ...options };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError('$numberLong string is too long');\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const longVal = inspect(this.toString(), options);\n        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : '';\n        return `new Long(${longVal}${unsignedVal})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\n\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return { quotient: value, rem: _rem };\n    }\n    for (let i = 0; i <= 3; i++) {\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return { quotient: value, rem: _rem };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0)\n        .add(productMid2)\n        .add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return { high: productHigh, low: productLow };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    }\n    else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright)\n            return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return 'Decimal128';\n    }\n    constructor(bytes) {\n        super();\n        if (typeof bytes === 'string') {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        }\n        else if (bytes instanceof Uint8Array || isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError('Decimal128 must take a Buffer of 16 bytes');\n            }\n            this.bytes = bytes;\n        }\n        else {\n            throw new BSONError('Decimal128 must take a Buffer or string');\n        }\n    }\n    static fromString(representation) {\n        return Decimal128._fromString(representation, { allowRounding: false });\n    }\n    static fromStringWithRounding(representation) {\n        return Decimal128._fromString(representation, { allowRounding: true });\n    }\n    static _fromString(representation, options) {\n        let isNegative = false;\n        let sawSign = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [0];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if ((!stringMatch && !infMatch && !nanMatch) || representation.length === 0) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined)\n                invalidErr(representation, 'missing exponent power');\n            if (e && unsignedNumber === undefined)\n                invalidErr(representation, 'missing exponent base');\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, 'missing e before exponent');\n            }\n        }\n        if (representation[index] === '+' || representation[index] === '-') {\n            sawSign = true;\n            isNegative = representation[index++] === '-';\n        }\n        if (!isDigit(representation[index]) && representation[index] !== '.') {\n            if (representation[index] === 'i' || representation[index] === 'I') {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            }\n            else if (representation[index] === 'N') {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while (isDigit(representation[index]) || representation[index] === '.') {\n            if (representation[index] === '.') {\n                if (sawRadix)\n                    invalidErr(representation, 'contains multiple periods');\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < MAX_DIGITS) {\n                if (representation[index] !== '0' || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero)\n                nDigits = nDigits + 1;\n            if (sawRadix)\n                radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead)\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        if (representation[index] === 'e' || representation[index] === 'E') {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2])\n                return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index])\n            return new Decimal128(NAN_BUFFER);\n        if (!nDigitsStored) {\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        }\n        else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while (representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === '0') {\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {\n            exponent = EXPONENT_MIN;\n        }\n        else {\n            exponent = exponent - radixPosition;\n        }\n        while (exponent > EXPONENT_MAX) {\n            lastDigit = lastDigit + 1;\n            if (lastDigit >= MAX_DIGITS) {\n                if (significantDigits === 0) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, 'overflow');\n            }\n            exponent = exponent - 1;\n        }\n        if (options.allowRounding) {\n            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n                if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                    exponent = EXPONENT_MIN;\n                    significantDigits = 0;\n                    break;\n                }\n                if (nDigitsStored < nDigits) {\n                    nDigits = nDigits - 1;\n                }\n                else {\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                }\n                else {\n                    const digitsString = digits.join('');\n                    if (digitsString.match(/^0+$/)) {\n                        exponent = EXPONENT_MAX;\n                        break;\n                    }\n                    invalidErr(representation, 'overflow');\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                let endOfString = nDigitsRead;\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                let roundBit = 0;\n                if (roundDigit >= 5) {\n                    roundBit = 1;\n                    if (roundDigit === 5) {\n                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                        for (let i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n                            if (parseInt(representation[i], 10)) {\n                                roundBit = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (roundBit) {\n                    let dIdx = lastDigit;\n                    for (; dIdx >= 0; dIdx--) {\n                        if (++digits[dIdx] > 9) {\n                            digits[dIdx] = 0;\n                            if (dIdx === 0) {\n                                if (exponent < EXPONENT_MAX) {\n                                    exponent = exponent + 1;\n                                    digits[dIdx] = 1;\n                                }\n                                else {\n                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                                }\n                            }\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n                if (lastDigit === 0) {\n                    if (significantDigits === 0) {\n                        exponent = EXPONENT_MIN;\n                        break;\n                    }\n                    invalidErr(representation, 'exponent underflow');\n                }\n                if (nDigitsStored < nDigits) {\n                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== '0' &&\n                        significantDigits !== 0) {\n                        invalidErr(representation, 'inexact rounding');\n                    }\n                    nDigits = nDigits - 1;\n                }\n                else {\n                    if (digits[lastDigit] !== 0) {\n                        invalidErr(representation, 'inexact rounding');\n                    }\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                }\n                else {\n                    invalidErr(representation, 'overflow');\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                if (roundDigit !== 0) {\n                    invalidErr(representation, 'inexact rounding');\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        }\n        else if (lastDigit < 17) {\n            let dIdx = 0;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        else {\n            let dIdx = 0;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit - 17; dIdx++) {\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000'));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        }\n        else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString('9223372036854775808'));\n        }\n        const buffer = ByteUtils.allocateUnsafe(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = (dec.low.low >> 8) & 0xff;\n        buffer[index++] = (dec.low.low >> 16) & 0xff;\n        buffer[index++] = (dec.low.low >> 24) & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = (dec.low.high >> 8) & 0xff;\n        buffer[index++] = (dec.low.high >> 16) & 0xff;\n        buffer[index++] = (dec.low.high >> 24) & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = (dec.high.low >> 8) & 0xff;\n        buffer[index++] = (dec.high.low >> 16) & 0xff;\n        buffer[index++] = (dec.high.low >> 24) & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = (dec.high.high >> 8) & 0xff;\n        buffer[index++] = (dec.high.high >> 16) & 0xff;\n        buffer[index++] = (dec.high.high >> 24) & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for (let i = 0; i < significand.length; i++)\n            significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = { parts: [0, 0, 0, 0] };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midl = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midh = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const high = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push('-');\n        }\n        const combination = (high >> 26) & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join('') + 'Infinity';\n            }\n            else if (combination === COMBINATION_NAN) {\n                return 'NaN';\n            }\n            else {\n                biased_exponent = (high >> 15) & EXPONENT_MASK;\n                significand_msb = 0x08 + ((high >> 14) & 0x01);\n            }\n        }\n        else {\n            significand_msb = (high >> 14) & 0x07;\n            biased_exponent = (high >> 17) & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 &&\n            significand128.parts[1] === 0 &&\n            significand128.parts[2] === 0 &&\n            significand128.parts[3] === 0) {\n            is_zero = true;\n        }\n        else {\n            for (k = 3; k >= 0; k--) {\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits)\n                    continue;\n                for (j = 8; j >= 0; j--) {\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        }\n        else {\n            significand_digits = 36;\n            while (!significand[index]) {\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0)\n                    string.push(`E+${exponent}`);\n                else if (exponent < 0)\n                    string.push(`E${exponent}`);\n                return string.join('');\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push('.');\n            }\n            for (let i = 0; i < significand_digits; i++) {\n                string.push(`${significand[index++]}`);\n            }\n            string.push('E');\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            }\n            else {\n                string.push(`${scientific_exponent}`);\n            }\n        }\n        else {\n            if (exponent >= 0) {\n                for (let i = 0; i < significand_digits; i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n            else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for (let i = 0; i < radix_position; i++) {\n                        string.push(`${significand[index++]}`);\n                    }\n                }\n                else {\n                    string.push('0');\n                }\n                string.push('.');\n                while (radix_position++ < 0) {\n                    string.push('0');\n                }\n                for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join('');\n    }\n    toJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    toExtendedJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const d128string = inspect(this.toString(), options);\n        return `new Decimal128(${d128string})`;\n    }\n}\n\nclass Double extends BSONValue {\n    get _bsontype() {\n        return 'Double';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    static fromString(value) {\n        const coercedValue = Number(value);\n        if (value === 'NaN')\n            return new Double(NaN);\n        if (value === 'Infinity')\n            return new Double(Infinity);\n        if (value === '-Infinity')\n            return new Double(-Infinity);\n        if (!Number.isFinite(coercedValue)) {\n            throw new BSONError(`Input: ${value} is not representable as a Double`);\n        }\n        if (value.trim() !== value) {\n            throw new BSONError(`Input: '${value}' contains whitespace`);\n        }\n        if (value === '') {\n            throw new BSONError(`Input is an empty string`);\n        }\n        if (/[^-0-9.+eE]/.test(value)) {\n            throw new BSONError(`Input: '${value}' is not in decimal or exponential notation`);\n        }\n        return new Double(coercedValue);\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || (options.relaxed && isFinite(this.value)))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return { $numberDouble: '-0.0' };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Double(${inspect(this.value, options)})`;\n    }\n}\n\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return 'Int32';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    static fromString(value) {\n        const cleanedValue = removeLeadingZerosAndExplicitPlus(value);\n        const coercedValue = Number(value);\n        if (BSON_INT32_MAX < coercedValue) {\n            throw new BSONError(`Input: '${value}' is larger than the maximum value for Int32`);\n        }\n        else if (BSON_INT32_MIN > coercedValue) {\n            throw new BSONError(`Input: '${value}' is smaller than the minimum value for Int32`);\n        }\n        else if (!Number.isSafeInteger(coercedValue)) {\n            throw new BSONError(`Input: '${value}' is not a safe integer`);\n        }\n        else if (coercedValue.toString() !== cleanedValue) {\n            throw new BSONError(`Input: '${value}' is not a valid Int32 string`);\n        }\n        return new Int32(coercedValue);\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy))\n            return this.value;\n        return { $numberInt: this.value.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Int32(${inspect(this.value, options)})`;\n    }\n}\n\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return 'MaxKey';\n    }\n    toExtendedJSON() {\n        return { $maxKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    inspect() {\n        return 'new MaxKey()';\n    }\n}\n\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return 'MinKey';\n    }\n    toExtendedJSON() {\n        return { $minKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    inspect() {\n        return 'new MinKey()';\n    }\n}\n\nlet PROCESS_UNIQUE = null;\nconst __idCache = new WeakMap();\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return 'ObjectId';\n    }\n    constructor(inputId) {\n        super();\n        let workingId;\n        if (typeof inputId === 'object' && inputId && 'id' in inputId) {\n            if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError('Argument passed in must have an id that is of type string or Buffer');\n            }\n            if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            }\n            else {\n                workingId = inputId.id;\n            }\n        }\n        else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === 'number') {\n            this.buffer = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\n        }\n        else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this.buffer = ByteUtils.toLocalBufferType(workingId);\n        }\n        else if (typeof workingId === 'string') {\n            if (ObjectId.validateHexString(workingId)) {\n                this.buffer = ByteUtils.fromHex(workingId);\n                if (ObjectId.cacheHexString) {\n                    __idCache.set(this, workingId);\n                }\n            }\n            else {\n                throw new BSONError('input must be a 24 character hex string, 12 byte Uint8Array, or an integer');\n            }\n        }\n        else {\n            throw new BSONError('Argument passed in does not match the accepted types');\n        }\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n        if (ObjectId.cacheHexString) {\n            __idCache.set(this, ByteUtils.toHex(value));\n        }\n    }\n    static validateHexString(string) {\n        if (string?.length !== 24)\n            return false;\n        for (let i = 0; i < 24; i++) {\n            const char = string.charCodeAt(i);\n            if ((char >= 48 && char <= 57) ||\n                (char >= 97 && char <= 102) ||\n                (char >= 65 && char <= 70)) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString) {\n            const __id = __idCache.get(this);\n            if (__id)\n                return __id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString) {\n            __idCache.set(this, hexString);\n        }\n        return hexString;\n    }\n    static getInc() {\n        return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);\n    }\n    static generate(time) {\n        if ('number' !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocateUnsafe(12);\n        NumberUtils.setInt32BE(buffer, 0, time);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = (inc >> 8) & 0xff;\n        buffer[9] = (inc >> 16) & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        if (encoding === 'hex')\n            return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    static is(variable) {\n        return (variable != null &&\n            typeof variable === 'object' &&\n            '_bsontype' in variable &&\n            variable._bsontype === 'ObjectId');\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (ObjectId.is(otherId)) {\n            return (this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer));\n        }\n        if (typeof otherId === 'string') {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === 'object' && typeof otherId.toHexString === 'function') {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString();\n            return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = NumberUtils.getUint32BE(this.buffer, 0);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    serializeInto(uint8array, index) {\n        uint8array[index] = this.buffer[0];\n        uint8array[index + 1] = this.buffer[1];\n        uint8array[index + 2] = this.buffer[2];\n        uint8array[index + 3] = this.buffer[3];\n        uint8array[index + 4] = this.buffer[4];\n        uint8array[index + 5] = this.buffer[5];\n        uint8array[index + 6] = this.buffer[6];\n        uint8array[index + 7] = this.buffer[7];\n        uint8array[index + 8] = this.buffer[8];\n        uint8array[index + 9] = this.buffer[9];\n        uint8array[index + 10] = this.buffer[10];\n        uint8array[index + 11] = this.buffer[11];\n        return 12;\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.allocate(12);\n        for (let i = 11; i >= 4; i--)\n            buffer[i] = 0;\n        NumberUtils.setInt32BE(buffer, 0, time);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError('hex string must be 24 characters');\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError('base64 string must be 16 characters');\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null)\n            return false;\n        if (typeof id === 'string')\n            return ObjectId.validateHexString(id);\n        try {\n            new ObjectId(id);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString)\n            return { $oid: this.toHexString() };\n        return { $oid: this.toString('hex') };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    isCached() {\n        return ObjectId.cacheHexString && __idCache.has(this);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new ObjectId(${inspect(this.toHexString(), options)})`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\n\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)) {\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n    }\n    switch (typeof value) {\n        case 'string':\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case 'number':\n            if (Math.floor(value) === value &&\n                value >= JS_INT_MIN &&\n                value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                }\n                else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            }\n            else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case 'undefined':\n            if (isArray || !ignoreUndefined)\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case 'boolean':\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case 'object':\n            if (value != null &&\n                typeof value._bsontype === 'string' &&\n                value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            }\n            else if (value._bsontype === 'ObjectId') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (ArrayBuffer.isView(value) ||\n                value instanceof ArrayBuffer ||\n                isAnyArrayBuffer(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength);\n            }\n            else if (value._bsontype === 'Long' ||\n                value._bsontype === 'Double' ||\n                value._bsontype === 'Timestamp') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (value._bsontype === 'Decimal128') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            }\n            else if (value._bsontype === 'Code') {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1 +\n                        internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1);\n                }\n            }\n            else if (value._bsontype === 'Binary') {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        (binary.position + 1 + 4 + 1 + 4));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1));\n                }\n            }\n            else if (value._bsontype === 'Symbol') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    ByteUtils.utf8ByteLength(value.value) +\n                    4 +\n                    1 +\n                    1);\n            }\n            else if (value._bsontype === 'DBRef') {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values['$db'] = value.db;\n                }\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined));\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.source) +\n                    1 +\n                    (value.global ? 1 : 0) +\n                    (value.ignoreCase ? 1 : 0) +\n                    (value.multiline ? 1 : 0) +\n                    1);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.pattern) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.options) +\n                    1);\n            }\n            else {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) +\n                    1);\n            }\n        case 'function':\n            if (serializeFunctions) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    4 +\n                    ByteUtils.utf8ByteLength(value.toString()) +\n                    1);\n            }\n            return 0;\n        case 'bigint':\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n        case 'symbol':\n            return 0;\n        default:\n            throw new BSONError(`Unrecognized JS type: ${typeof value}`);\n    }\n}\n\nfunction alphabetize(str) {\n    return str.split('').sort().join('');\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return 'BSONRegExp';\n    }\n    constructor(pattern, options) {\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? '');\n        if (this.pattern.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for (let i = 0; i < this.options.length; i++) {\n            if (!(this.options[i] === 'i' ||\n                this.options[i] === 'm' ||\n                this.options[i] === 'x' ||\n                this.options[i] === 'l' ||\n                this.options[i] === 's' ||\n                this.options[i] === 'u')) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split('').sort().join('') : '';\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return { $regex: this.pattern, $options: this.options };\n        }\n        return { $regularExpression: { pattern: this.pattern, options: this.options } };\n    }\n    static fromExtendedJSON(doc) {\n        if ('$regex' in doc) {\n            if (typeof doc.$regex !== 'string') {\n                if (doc.$regex._bsontype === 'BSONRegExp') {\n                    return doc;\n                }\n            }\n            else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if ('$regularExpression' in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    inspect(depth, options, inspect) {\n        const stylize = getStylizeFunction(options) ?? (v => v);\n        inspect ??= defaultInspect;\n        const pattern = stylize(inspect(this.pattern), 'regexp');\n        const flags = stylize(inspect(this.options), 'regexp');\n        return `new BSONRegExp(${pattern}, ${flags})`;\n    }\n}\n\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return 'BSONSymbol';\n    }\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return { $symbol: this.value };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new BSONSymbol(${inspect(this.value, options)})`;\n    }\n}\n\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return 'Timestamp';\n    }\n    get i() {\n        return this.low >>> 0;\n    }\n    get t() {\n        return this.high >>> 0;\n    }\n    constructor(low) {\n        if (low == null) {\n            super(0, 0, true);\n        }\n        else if (typeof low === 'bigint') {\n            super(low, true);\n        }\n        else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        }\n        else if (typeof low === 'object' && 't' in low && 'i' in low) {\n            if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');\n            }\n            if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');\n            }\n            const t = Number(low.t);\n            const i = Number(low.i);\n            if (t < 0 || Number.isNaN(t)) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');\n            }\n            if (i < 0 || Number.isNaN(i)) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');\n            }\n            if (t > 0xffff_ffff) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');\n            }\n            if (i > 0xffff_ffff) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');\n            }\n            super(i, t, true);\n        }\n        else {\n            throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({ i: lowBits, t: highBits });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return { $timestamp: { t: this.t, i: this.i } };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i)\n            ? doc.$timestamp.i.getLowBitsUnsigned()\n            : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t)\n            ? doc.$timestamp.t.getLowBitsUnsigned()\n            : doc.$timestamp.t;\n        return new Timestamp({ t, i });\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const t = inspect(this.t, options);\n        const i = inspect(this.i, options);\n        return `new Timestamp({ t: ${t}, i: ${i} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\n\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = NumberUtils.getInt32LE(buffer, index);\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n    const raw = options['raw'] == null ? false : options['raw'];\n    const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    const validation = options.validation == null ? { utf8: true } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    let utf8KeysSet;\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === 'boolean') {\n        validationSetting = utf8ValidatedKeys;\n    }\n    else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError('UTF-8 validation setting cannot be empty');\n        }\n        if (typeof utf8ValidationValues[0] !== 'boolean') {\n            throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every(item => item === validationSetting)) {\n            throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\n        }\n    }\n    if (!globalUTFValidation) {\n        utf8KeysSet = new Set();\n        for (const key of Object.keys(utf8ValidatedKeys)) {\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5)\n        throw new BSONError('corrupt bson message < 5 bytes long');\n    const size = NumberUtils.getInt32LE(buffer, index);\n    index += 4;\n    if (size < 5 || size > buffer.length)\n        throw new BSONError('corrupt bson message');\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    let isPossibleDBRef = isArray ? false : null;\n    while (true) {\n        const elementType = buffer[index++];\n        if (elementType === 0)\n            break;\n        let i = index;\n        while (buffer[i] !== 0x00 && i < buffer.length) {\n            i++;\n        }\n        if (i >= buffer.byteLength)\n            throw new BSONError('Bad BSON Document: illegal CString');\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false);\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet?.has(name)) {\n            shouldValidateKey = validationSetting;\n        }\n        else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === '$') {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocateUnsafe(12);\n            for (let i = 0; i < 12; i++)\n                oid[i] = buffer[index + i];\n            value = new ObjectId(oid);\n            index = index + 12;\n        }\n        else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(NumberUtils.getInt32LE(buffer, index));\n            index += 4;\n        }\n        else if (elementType === BSON_DATA_INT) {\n            value = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n        }\n        else if (elementType === BSON_DATA_NUMBER) {\n            value = NumberUtils.getFloat64LE(buffer, index);\n            index += 8;\n            if (promoteValues === false)\n                value = new Double(value);\n        }\n        else if (elementType === BSON_DATA_DATE) {\n            const lowBits = NumberUtils.getInt32LE(buffer, index);\n            const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n            index += 8;\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        }\n        else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1)\n                throw new BSONError('illegal boolean type value');\n            value = buffer[index++] === 1;\n        }\n        else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            if (objectSize <= 0 || objectSize > buffer.length - index)\n                throw new BSONError('bad embedded document length in bson');\n            if (raw) {\n                value = buffer.subarray(index, index + objectSize);\n            }\n            else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = { ...options, validation: { utf8: shouldValidateKey } };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        }\n        else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = { ...options, raw: true };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0)\n                throw new BSONError('invalid array terminator byte');\n            if (index !== stopIndex)\n                throw new BSONError('corrupted array bson');\n        }\n        else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        }\n        else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        }\n        else if (elementType === BSON_DATA_LONG) {\n            if (useBigInt64) {\n                value = NumberUtils.getBigInt64LE(buffer, index);\n                index += 8;\n            }\n            else {\n                const lowBits = NumberUtils.getInt32LE(buffer, index);\n                const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n                index += 8;\n                const long = new Long(lowBits, highBits);\n                if (promoteLongs && promoteValues === true) {\n                    value =\n                        long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\n                            ? long.toNumber()\n                            : long;\n                }\n                else {\n                    value = long;\n                }\n            }\n        }\n        else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocateUnsafe(16);\n            for (let i = 0; i < 16; i++)\n                bytes[i] = buffer[index + i];\n            index = index + 16;\n            value = new Decimal128(bytes);\n        }\n        else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0)\n                throw new BSONError('Negative binary type element size found');\n            if (binarySize > buffer.byteLength)\n                throw new BSONError('Binary type size larger than document size');\n            if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                binarySize = NumberUtils.getInt32LE(buffer, index);\n                index += 4;\n                if (binarySize < 0)\n                    throw new BSONError('Negative binary type element size found for subtype 0x02');\n                if (binarySize > totalBinarySize - 4)\n                    throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n                if (binarySize < totalBinarySize - 4)\n                    throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n            }\n            if (promoteBuffers && promoteValues) {\n                value = ByteUtils.toLocalBufferType(buffer.subarray(index, index + binarySize));\n            }\n            else {\n                value = new Binary(buffer.subarray(index, index + binarySize), subType);\n                if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                    value = value.toUUID();\n                }\n            }\n            index = index + binarySize;\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for (i = 0; i < regExpOptions.length; i++) {\n                switch (regExpOptions[i]) {\n                    case 'm':\n                        optionsArray[i] = 'm';\n                        break;\n                    case 's':\n                        optionsArray[i] = 'g';\n                        break;\n                    case 'i':\n                        optionsArray[i] = 'i';\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(''));\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        }\n        else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const symbol = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_TIMESTAMP) {\n            value = new Timestamp({\n                i: NumberUtils.getUint32LE(buffer, index),\n                t: NumberUtils.getUint32LE(buffer, index + 4)\n            });\n            index += 8;\n        }\n        else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        }\n        else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        }\n        else if (elementType === BSON_DATA_CODE) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError('code_w_scope total size shorter minimum expected length');\n            }\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too short, truncating scope');\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too long, clips outer document');\n            }\n            value = new Code(functionString, scopeObject);\n        }\n        else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0)\n                throw new BSONError('bad string length in bson');\n            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocateUnsafe(12);\n            for (let i = 0; i < 12; i++)\n                oidBuffer[i] = buffer[index + i];\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        }\n        else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === '__proto__') {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n        else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray)\n            throw new BSONError('corrupt array bson');\n        throw new BSONError('corrupt object bson');\n    }\n    if (!isPossibleDBRef)\n        return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\n\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    NumberUtils.setInt32LE(buffer, index, size + 1);\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero &&\n        Number.isSafeInteger(value) &&\n        value <= BSON_INT32_MAX &&\n        value >= BSON_INT32_MIN\n        ? BSON_DATA_INT\n        : BSON_DATA_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    if (type === BSON_DATA_INT) {\n        index += NumberUtils.setInt32LE(buffer, index, value);\n    }\n    else {\n        index += NumberUtils.setFloat64LE(buffer, index, value);\n    }\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setBigInt64LE(buffer, index, value);\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    index += NumberUtils.setInt32LE(buffer, index, lowBits);\n    index += NumberUtils.setInt32LE(buffer, index, highBits);\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError('value ' + value.source + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase)\n        buffer[index++] = 0x69;\n    if (value.global)\n        buffer[index++] = 0x73;\n    if (value.multiline)\n        buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split('').sort().join('');\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    }\n    else if (value._bsontype === 'MinKey') {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    }\n    else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += value.serializeInto(buffer, index);\n    return index;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    index += NumberUtils.setInt32LE(buffer, index, size);\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    if (size <= 16) {\n        for (let i = 0; i < size; i++)\n            buffer[index + i] = value[i];\n    }\n    else {\n        buffer.set(value, index);\n    }\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError('Cannot convert circular structure to BSON');\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    for (let i = 0; i < 16; i++)\n        buffer[index + i] = value.bytes[i];\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] =\n        value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    index += NumberUtils.setInt32LE(buffer, index, lowBits);\n    index += NumberUtils.setInt32LE(buffer, index, highBits);\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setInt32LE(buffer, index, value);\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setFloat64LE(buffer, index, value.value);\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    NumberUtils.setInt32LE(buffer, index, size);\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === 'object') {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        NumberUtils.setInt32LE(buffer, index, codeSize);\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        startIndex += NumberUtils.setInt32LE(buffer, startIndex, totalSize);\n        buffer[index++] = 0;\n    }\n    else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        NumberUtils.setInt32LE(buffer, index, size);\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)\n        size = size + 4;\n    index += NumberUtils.setInt32LE(buffer, index, size);\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        index += NumberUtils.setInt32LE(buffer, index, size);\n    }\n    if (value.sub_type === Binary.SUBTYPE_VECTOR) {\n        validateBinaryVector(value);\n    }\n    if (size <= 16) {\n        for (let i = 0; i < size; i++)\n            buffer[index + i] = data[i];\n    }\n    else {\n        buffer.set(data, index);\n    }\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    NumberUtils.setInt32LE(buffer, index, size);\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    startIndex += NumberUtils.setInt32LE(buffer, index, size);\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError('serialize does not support an array as the root input');\n        }\n        if (typeof object !== 'object') {\n            throw new BSONError('serialize does not support non-object as the root input');\n        }\n        else if ('_bsontype' in object && typeof object._bsontype === 'string') {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        }\n        else if (isDate(object) ||\n            isRegExp(object) ||\n            isUint8Array(object) ||\n            isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                if (value instanceof Date || isDate(value)) {\n                    index = serializeDate(buffer, key, value, index);\n                }\n                else if (value instanceof Uint8Array || isUint8Array(value)) {\n                    index = serializeBuffer(buffer, key, value, index);\n                }\n                else if (value instanceof RegExp || isRegExp(value)) {\n                    index = serializeRegExp(buffer, key, value, index);\n                }\n                else {\n                    index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n            }\n            else if (type === 'object') {\n                if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                    throw new BSONVersionError();\n                }\n                else if (value._bsontype === 'ObjectId') {\n                    index = serializeObjectId(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Decimal128') {\n                    index = serializeDecimal128(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                    index = serializeLong(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Double') {\n                    index = serializeDouble(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Code') {\n                    index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n                else if (value._bsontype === 'Binary') {\n                    index = serializeBinary(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'BSONSymbol') {\n                    index = serializeSymbol(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'DBRef') {\n                    index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n                }\n                else if (value._bsontype === 'BSONRegExp') {\n                    index = serializeBSONRegExp(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Int32') {\n                    index = serializeInt32(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                    index = serializeMinMax(buffer, key, value, index);\n                }\n                else if (typeof value._bsontype !== 'undefined') {\n                    throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n                }\n            }\n            else if (type === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n        }\n    }\n    else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while (!done) {\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done)\n                continue;\n            const key = entry.value ? entry.value[0] : undefined;\n            let value = entry.value ? entry.value[1] : undefined;\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (key.includes('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (value === undefined) {\n                if (ignoreUndefined === false)\n                    index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                if (value instanceof Date || isDate(value)) {\n                    index = serializeDate(buffer, key, value, index);\n                }\n                else if (value instanceof Uint8Array || isUint8Array(value)) {\n                    index = serializeBuffer(buffer, key, value, index);\n                }\n                else if (value instanceof RegExp || isRegExp(value)) {\n                    index = serializeRegExp(buffer, key, value, index);\n                }\n                else {\n                    index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n            }\n            else if (type === 'object') {\n                if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                    throw new BSONVersionError();\n                }\n                else if (value._bsontype === 'ObjectId') {\n                    index = serializeObjectId(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Decimal128') {\n                    index = serializeDecimal128(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                    index = serializeLong(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Double') {\n                    index = serializeDouble(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Code') {\n                    index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n                else if (value._bsontype === 'Binary') {\n                    index = serializeBinary(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'BSONSymbol') {\n                    index = serializeSymbol(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'DBRef') {\n                    index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n                }\n                else if (value._bsontype === 'BSONRegExp') {\n                    index = serializeBSONRegExp(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Int32') {\n                    index = serializeInt32(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                    index = serializeMinMax(buffer, key, value, index);\n                }\n                else if (typeof value._bsontype !== 'undefined') {\n                    throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n                }\n            }\n            else if (type === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n            if (object != null && typeof object !== 'object') {\n                throw new BSONError('toBSON function did not return an object');\n            }\n        }\n        for (const key of Object.keys(object)) {\n            let value = object[key];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (key.includes('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (value === undefined) {\n                if (ignoreUndefined === false)\n                    index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                if (value instanceof Date || isDate(value)) {\n                    index = serializeDate(buffer, key, value, index);\n                }\n                else if (value instanceof Uint8Array || isUint8Array(value)) {\n                    index = serializeBuffer(buffer, key, value, index);\n                }\n                else if (value instanceof RegExp || isRegExp(value)) {\n                    index = serializeRegExp(buffer, key, value, index);\n                }\n                else {\n                    index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n            }\n            else if (type === 'object') {\n                if (value[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n                    throw new BSONVersionError();\n                }\n                else if (value._bsontype === 'ObjectId') {\n                    index = serializeObjectId(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Decimal128') {\n                    index = serializeDecimal128(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                    index = serializeLong(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Double') {\n                    index = serializeDouble(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Code') {\n                    index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n                }\n                else if (value._bsontype === 'Binary') {\n                    index = serializeBinary(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'BSONSymbol') {\n                    index = serializeSymbol(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'DBRef') {\n                    index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n                }\n                else if (value._bsontype === 'BSONRegExp') {\n                    index = serializeBSONRegExp(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'Int32') {\n                    index = serializeInt32(buffer, key, value, index);\n                }\n                else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                    index = serializeMinMax(buffer, key, value, index);\n                }\n                else if (typeof value._bsontype !== 'undefined') {\n                    throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n                }\n            }\n            else if (type === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    startingIndex += NumberUtils.setInt32LE(buffer, startingIndex, size);\n    return index;\n}\n\nfunction isBSONType(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '_bsontype' in value &&\n        typeof value._bsontype === 'string');\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === 'number') {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== 'object')\n        return value;\n    if (value.$undefined)\n        return null;\n    const keys = Object.keys(value).filter(k => k.startsWith('$') && value[k] != null);\n    for (let i = 0; i < keys.length; i++) {\n        const c = keysToCodecs[keys[i]];\n        if (c)\n            return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === 'number')\n                date.setTime(d);\n            else if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        else {\n            if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (Long.isLong(d))\n                date.setTime(d.toNumber());\n            else if (typeof d === 'number' && options.relaxed)\n                date.setTime(d);\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef)\n            return v;\n        const dollarKeys = Object.keys(v).filter(k => k.startsWith('$'));\n        let valid = true;\n        dollarKeys.forEach(k => {\n            if (['$ref', '$id', '$db'].indexOf(k) === -1)\n                valid = false;\n        });\n        if (valid)\n            return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index) => {\n        options.seenObjects.push({ propertyName: `index ${index}`, obj: null });\n        try {\n            return serializeValue(v, options);\n        }\n        finally {\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value) {\n            if (typeof k !== 'string') {\n                throw new BSONError('Can only serialize maps with string keys');\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === 'object' || typeof value === 'function') && value !== null) {\n        const index = options.seenObjects.findIndex(entry => entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map(entry => entry.propertyName);\n            const leadingPart = props\n                .slice(0, index)\n                .map(prop => `${prop} -> `)\n                .join('');\n            const alreadySeen = props[index];\n            const circularPart = ' -> ' +\n                props\n                    .slice(index + 1, props.length - 1)\n                    .map(prop => `${prop} -> `)\n                    .join('');\n            const current = props[props.length - 1];\n            const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError('Converting circular structure to EJSON:\\n' +\n                `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` +\n                `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value))\n        return serializeArray(value, options);\n    if (value === undefined)\n        return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange\n                ? { $date: value.getTime() }\n                : { $date: getISOString(value) };\n        }\n        return options.relaxed && inRange\n            ? { $date: getISOString(value) }\n            : { $date: { $numberLong: value.getTime().toString() } };\n    }\n    if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return { $numberInt: value.toString() };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return { $numberLong: value.toString() };\n            }\n        }\n        return { $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString() };\n    }\n    if (typeof value === 'bigint') {\n        if (!options.relaxed) {\n            return { $numberLong: BigInt.asIntN(64, value).toString() };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === 'object')\n        return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o) => new Binary(o.value(), o.sub_type),\n    Code: (o) => new Code(o.code, o.scope),\n    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o) => new Decimal128(o.bytes),\n    Double: (o) => new Double(o.value),\n    Int32: (o) => new Int32(o.value),\n    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: () => new MaxKey(),\n    MinKey: () => new MinKey(),\n    ObjectId: (o) => new ObjectId(o),\n    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o) => new BSONSymbol(o.value),\n    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== 'object')\n        throw new BSONError('not an object instance');\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === 'undefined') {\n        const _doc = {};\n        for (const name of Object.keys(doc)) {\n            options.seenObjects.push({ propertyName: name, obj: null });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === '__proto__') {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n                else {\n                    _doc[name] = value;\n                }\n            }\n            finally {\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    }\n    else if (doc != null &&\n        typeof doc === 'object' &&\n        typeof doc._bsontype === 'string' &&\n        doc[BSON_VERSION_SYMBOL] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    }\n    else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== 'function') {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === 'Code' && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        }\n        else if (bsontype === 'DBRef' && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    }\n    else {\n        throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value) => {\n        if (key.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === 'object') {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {\n        seenObjects: [{ propertyName: '(root)', obj: null }]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\n\nconst BSONElementType = {\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: 255,\n    maxKey: 127\n};\nfunction getSize(source, offset) {\n    try {\n        return NumberUtils.getNonnegativeInt32LE(source, offset);\n    }\n    catch (cause) {\n        throw new BSONOffsetError('BSON size cannot be negative', offset, { cause });\n    }\n}\nfunction findNull(bytes, offset) {\n    let nullTerminatorOffset = offset;\n    for (; bytes[nullTerminatorOffset] !== 0x00; nullTerminatorOffset++)\n        ;\n    if (nullTerminatorOffset === bytes.length - 1) {\n        throw new BSONOffsetError('Null terminator not found', offset);\n    }\n    return nullTerminatorOffset;\n}\nfunction parseToElements(bytes, startOffset = 0) {\n    startOffset ??= 0;\n    if (bytes.length < 5) {\n        throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);\n    }\n    const documentSize = getSize(bytes, startOffset);\n    if (documentSize > bytes.length - startOffset) {\n        throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);\n    }\n    if (bytes[startOffset + documentSize - 1] !== 0x00) {\n        throw new BSONOffsetError('BSON documents must end in 0x00', startOffset + documentSize);\n    }\n    const elements = [];\n    let offset = startOffset + 4;\n    while (offset <= documentSize + startOffset) {\n        const type = bytes[offset];\n        offset += 1;\n        if (type === 0) {\n            if (offset - startOffset !== documentSize) {\n                throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);\n            }\n            break;\n        }\n        const nameOffset = offset;\n        const nameLength = findNull(bytes, offset) - nameOffset;\n        offset += nameLength + 1;\n        let length;\n        if (type === BSONElementType.double ||\n            type === BSONElementType.long ||\n            type === BSONElementType.date ||\n            type === BSONElementType.timestamp) {\n            length = 8;\n        }\n        else if (type === BSONElementType.int) {\n            length = 4;\n        }\n        else if (type === BSONElementType.objectId) {\n            length = 12;\n        }\n        else if (type === BSONElementType.decimal) {\n            length = 16;\n        }\n        else if (type === BSONElementType.bool) {\n            length = 1;\n        }\n        else if (type === BSONElementType.null ||\n            type === BSONElementType.undefined ||\n            type === BSONElementType.maxKey ||\n            type === BSONElementType.minKey) {\n            length = 0;\n        }\n        else if (type === BSONElementType.regex) {\n            length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;\n        }\n        else if (type === BSONElementType.object ||\n            type === BSONElementType.array ||\n            type === BSONElementType.javascriptWithScope) {\n            length = getSize(bytes, offset);\n        }\n        else if (type === BSONElementType.string ||\n            type === BSONElementType.binData ||\n            type === BSONElementType.dbPointer ||\n            type === BSONElementType.javascript ||\n            type === BSONElementType.symbol) {\n            length = getSize(bytes, offset) + 4;\n            if (type === BSONElementType.binData) {\n                length += 1;\n            }\n            if (type === BSONElementType.dbPointer) {\n                length += 12;\n            }\n        }\n        else {\n            throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, '0')} type byte`, offset);\n        }\n        if (length > documentSize) {\n            throw new BSONOffsetError('value reports length larger than document', offset);\n        }\n        elements.push([type, nameOffset, nameLength, offset, length]);\n        offset += length;\n    }\n    return elements;\n}\n\nconst onDemand = Object.create(null);\nonDemand.parseToElements = parseToElements;\nonDemand.ByteUtils = ByteUtils;\nonDemand.NumberUtils = NumberUtils;\nObject.freeze(onDemand);\n\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === 'number' ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for (let i = 0; i < numberOfDocuments; i++) {\n        const size = NumberUtils.getInt32LE(bufferData, index);\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\n\nvar bson = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONOffsetError: BSONOffsetError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    onDemand: onDemand,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\n\nexport { bson as BSON, BSONError, BSONOffsetError, BSONRegExp, BSONRuntimeError, BSONSymbol, BSONType, BSONValue, BSONVersionError, Binary, Code, DBRef, Decimal128, Double, EJSON, Int32, Long, MaxKey, MinKey, ObjectId, Timestamp, UUID, calculateObjectSize, deserialize, deserializeStream, onDemand, serialize, serializeWithBufferAndIndex, setInternalBufferSize };\n//# sourceMappingURL=bson.mjs.map\n","/**\n * IndexDBFileSystemStorageAdapter implements LocalStorageAdapter using IndexedDB.\n * Suitable for web browsers and web-based environments.\n */\nexport class IndexDBFileSystemStorageAdapter {\n    databaseName;\n    dbPromise;\n    constructor(databaseName = 'PowerSyncFiles') {\n        this.databaseName = databaseName;\n    }\n    async initialize() {\n        this.dbPromise = new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.databaseName, 1);\n            request.onupgradeneeded = () => {\n                request.result.createObjectStore('files');\n            };\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n    async clear() {\n        const db = await this.dbPromise;\n        return new Promise((resolve, reject) => {\n            const tx = db.transaction('files', 'readwrite');\n            const store = tx.objectStore('files');\n            const req = store.clear();\n            req.onsuccess = () => resolve();\n            req.onerror = () => reject(req.error);\n        });\n    }\n    getLocalUri(filename) {\n        return `indexeddb://${this.databaseName}/files/${filename}`;\n    }\n    async getStore(mode = 'readonly') {\n        const db = await this.dbPromise;\n        const tx = db.transaction('files', mode);\n        return tx.objectStore('files');\n    }\n    async saveFile(filePath, data) {\n        const store = await this.getStore('readwrite');\n        let dataToStore;\n        let size;\n        if (typeof data === 'string') {\n            const binaryString = atob(data);\n            const bytes = new Uint8Array(binaryString.length);\n            for (let i = 0; i < binaryString.length; i++) {\n                bytes[i] = binaryString.charCodeAt(i);\n            }\n            dataToStore = bytes.buffer;\n            size = bytes.byteLength;\n        }\n        else {\n            dataToStore = data;\n            size = dataToStore.byteLength;\n        }\n        return await new Promise((resolve, reject) => {\n            const req = store.put(dataToStore, filePath);\n            req.onsuccess = () => resolve(size);\n            req.onerror = () => reject(req.error);\n        });\n    }\n    async readFile(fileUri, options) {\n        const store = await this.getStore();\n        return new Promise((resolve, reject) => {\n            const req = store.get(fileUri);\n            req.onsuccess = async () => {\n                if (!req.result) {\n                    reject(new Error('File not found'));\n                    return;\n                }\n                resolve(req.result);\n            };\n            req.onerror = () => reject(req.error);\n        });\n    }\n    async deleteFile(uri, options) {\n        const store = await this.getStore('readwrite');\n        await new Promise((resolve, reject) => {\n            const req = store.delete(uri);\n            req.onsuccess = () => resolve();\n            req.onerror = () => reject(req.error);\n        });\n    }\n    async fileExists(fileUri) {\n        const store = await this.getStore();\n        return new Promise((resolve, reject) => {\n            const req = store.get(fileUri);\n            req.onsuccess = () => resolve(!!req.result);\n            req.onerror = () => reject(req.error);\n        });\n    }\n    async makeDir(path) {\n        // No-op for IndexedDB as it does not have a directory structure\n    }\n    async rmDir(path) {\n        const store = await this.getStore('readwrite');\n        const range = IDBKeyRange.bound(path + '/', path + '/\\uffff', false, false);\n        await new Promise((resolve, reject) => {\n            const req = store.delete(range);\n            req.onsuccess = () => resolve();\n            req.onerror = () => reject(req.error);\n        });\n    }\n}\n","import { getNavigatorLocks } from '../shared/navigator.js';\n/**\n * @internal\n * @experimental\n */\nexport const NAVIGATOR_TRIGGER_CLAIM_MANAGER = {\n    async obtainClaim(identifier) {\n        return new Promise((resolveReleaser) => {\n            getNavigatorLocks().request(identifier, async () => {\n                await new Promise((releaseLock) => {\n                    resolveReleaser(async () => releaseLock());\n                });\n            });\n        });\n    },\n    async checkClaim(identifier) {\n        const currentState = await getNavigatorLocks().query();\n        return currentState.held?.find((heldLock) => heldLock.name == identifier) != null;\n    }\n};\n","import { AbstractPowerSyncDatabase, SqliteBucketStorage, isDBAdapter, isSQLOpenFactory } from '@powersync/common';\nimport { Mutex } from 'async-mutex';\nimport { getNavigatorLocks } from '../shared/navigator.js';\nimport { NAVIGATOR_TRIGGER_CLAIM_MANAGER } from './NavigatorTriggerClaimManager.js';\nimport { LockedAsyncDatabaseAdapter } from './adapters/LockedAsyncDatabaseAdapter.js';\nimport { WASQLiteOpenFactory } from './adapters/wa-sqlite/WASQLiteOpenFactory.js';\nimport { DEFAULT_WEB_SQL_FLAGS, isServerSide, resolveWebSQLFlags } from './adapters/web-sql-flags.js';\nimport { SSRStreamingSyncImplementation } from './sync/SSRWebStreamingSyncImplementation.js';\nimport { SharedWebStreamingSyncImplementation } from './sync/SharedWebStreamingSyncImplementation.js';\nimport { WebRemote } from './sync/WebRemote.js';\nimport { WebStreamingSyncImplementation } from './sync/WebStreamingSyncImplementation.js';\nexport const DEFAULT_POWERSYNC_FLAGS = {\n    ...DEFAULT_WEB_SQL_FLAGS,\n    externallyUnload: false\n};\nexport const resolveWebPowerSyncFlags = (flags) => {\n    return {\n        ...DEFAULT_POWERSYNC_FLAGS,\n        ...flags,\n        ...resolveWebSQLFlags(flags)\n    };\n};\n/**\n * Asserts that the database options are valid for custom database constructors.\n */\nfunction assertValidDatabaseOptions(options) {\n    if ('database' in options && 'encryptionKey' in options) {\n        const { database } = options;\n        if (isSQLOpenFactory(database) || isDBAdapter(database)) {\n            throw new Error(`Invalid configuration: 'encryptionKey' should only be included inside the database object when using a custom ${isSQLOpenFactory(database) ? 'WASQLiteOpenFactory' : 'WASQLiteDBAdapter'} constructor.`);\n        }\n    }\n}\n/**\n * A PowerSync database which provides SQLite functionality\n * which is automatically synced.\n *\n * @example\n * ```typescript\n * export const db = new PowerSyncDatabase({\n *  schema: AppSchema,\n *  database: {\n *    dbFilename: 'example.db'\n *  }\n * });\n * ```\n */\nexport class PowerSyncDatabase extends AbstractPowerSyncDatabase {\n    options;\n    static SHARED_MUTEX = new Mutex();\n    unloadListener;\n    resolvedFlags;\n    constructor(options) {\n        super(options);\n        this.options = options;\n        assertValidDatabaseOptions(options);\n        this.resolvedFlags = resolveWebPowerSyncFlags(options.flags);\n        if (this.resolvedFlags.enableMultiTabs && !this.resolvedFlags.externallyUnload) {\n            this.unloadListener = () => this.close({ disconnect: false });\n            window.addEventListener('unload', this.unloadListener);\n        }\n    }\n    async _initialize() {\n        if (this.database instanceof LockedAsyncDatabaseAdapter) {\n            /**\n             * While init is done automatically,\n             * LockedAsyncDatabaseAdapter only exposes config after init.\n             * We can explicitly wait for init here in order to access config.\n             */\n            await this.database.init();\n        }\n        // In some cases, like the SQLJs adapter, we don't pass a WebDBAdapter, so we need to check.\n        if (typeof this.database.getConfiguration == 'function') {\n            const config = this.database.getConfiguration();\n            if (config.requiresPersistentTriggers) {\n                this.triggersImpl.updateDefaults({\n                    useStorageByDefault: true\n                });\n            }\n        }\n    }\n    generateTriggerManagerConfig() {\n        return {\n            // We need to share hold information between tabs for web\n            claimManager: NAVIGATOR_TRIGGER_CLAIM_MANAGER\n        };\n    }\n    openDBAdapter(options) {\n        const defaultFactory = new WASQLiteOpenFactory({\n            ...options.database,\n            flags: resolveWebPowerSyncFlags(options.flags),\n            encryptionKey: options.encryptionKey\n        });\n        return defaultFactory.openDB();\n    }\n    /**\n     * Closes the database connection.\n     * By default the sync stream client is only disconnected if\n     * multiple tabs are not enabled.\n     */\n    close(options) {\n        if (this.unloadListener) {\n            window.removeEventListener('unload', this.unloadListener);\n        }\n        return super.close({\n            // Don't disconnect by default if multiple tabs are enabled\n            disconnect: options?.disconnect ?? !this.resolvedFlags.enableMultiTabs\n        });\n    }\n    async loadVersion() {\n        if (isServerSide()) {\n            return;\n        }\n        return super.loadVersion();\n    }\n    async resolveOfflineSyncStatus() {\n        if (isServerSide()) {\n            return;\n        }\n        return super.resolveOfflineSyncStatus();\n    }\n    generateBucketStorageAdapter() {\n        return new SqliteBucketStorage(this.database);\n    }\n    async runExclusive(cb) {\n        if (this.resolvedFlags.ssrMode) {\n            return PowerSyncDatabase.SHARED_MUTEX.runExclusive(cb);\n        }\n        return getNavigatorLocks().request(`lock-${this.database.name}`, cb);\n    }\n    generateSyncStreamImplementation(connector, options) {\n        const remote = new WebRemote(connector, this.logger);\n        const syncOptions = {\n            ...this.options,\n            ...options,\n            flags: this.resolvedFlags,\n            adapter: this.bucketStorageAdapter,\n            remote,\n            uploadCrud: async () => {\n                await this.waitForReady();\n                await connector.uploadData(this);\n            },\n            identifier: this.database.name,\n            logger: this.logger\n        };\n        switch (true) {\n            case this.resolvedFlags.ssrMode:\n                return new SSRStreamingSyncImplementation(syncOptions);\n            case this.resolvedFlags.enableMultiTabs:\n                if (!this.resolvedFlags.broadcastLogs) {\n                    const warning = `\n            Multiple tabs are enabled, but broadcasting of logs is disabled.\n            Logs for shared sync worker will only be available in the shared worker context\n          `;\n                    const logger = this.options.logger;\n                    logger ? logger.warn(warning) : console.warn(warning);\n                }\n                return new SharedWebStreamingSyncImplementation({\n                    ...syncOptions,\n                    db: this.database // This should always be the case\n                });\n            default:\n                return new WebStreamingSyncImplementation(syncOptions);\n        }\n    }\n}\n","import { AbstractPowerSyncDatabaseOpenFactory } from '@powersync/common';\nimport { PowerSyncDatabase, resolveWebPowerSyncFlags } from '../../db/PowerSyncDatabase.js';\n/**\n * Intermediate PowerSync Database Open factory for Web which uses a mock\n * SSR DB Adapter if running on server side.\n * Most SQLite DB implementations only run on client side, this will safely return\n * empty query results in SSR which will allow for generating server partial views.\n */\nexport class AbstractWebPowerSyncDatabaseOpenFactory extends AbstractPowerSyncDatabaseOpenFactory {\n    options;\n    constructor(options) {\n        super(options);\n        this.options = options;\n    }\n    generateOptions() {\n        return {\n            ...this.options,\n            database: this.openDB(),\n            schema: this.schema,\n            flags: resolveWebPowerSyncFlags(this.options.flags)\n        };\n    }\n    generateInstance(options) {\n        return new PowerSyncDatabase(options);\n    }\n}\n","import { createLogger } from '@powersync/common';\nimport { SSRDBAdapter } from './SSRDBAdapter.js';\nimport { isServerSide, resolveWebSQLFlags } from './web-sql-flags.js';\nexport class AbstractWebSQLOpenFactory {\n    options;\n    resolvedFlags;\n    logger;\n    constructor(options) {\n        this.options = options;\n        this.resolvedFlags = resolveWebSQLFlags(options.flags);\n        this.logger = options.logger ?? createLogger(`AbstractWebSQLOpenFactory - ${this.options.dbFilename}`);\n    }\n    /**\n     * Opens a {@link DBAdapter} using resolved flags.\n     * A SSR implementation is loaded if SSR mode is detected.\n     */\n    openDB() {\n        const { resolvedFlags: { disableSSRWarning, enableMultiTabs, ssrMode = isServerSide() } } = this;\n        if (ssrMode && !disableSSRWarning) {\n            this.logger.warn(`\n  Running PowerSync in SSR mode.\n  Only empty query results will be returned.\n  Disable this warning by setting 'disableSSRWarning: true' in options.`);\n        }\n        if (!enableMultiTabs) {\n            this.logger.warn('Multiple tab support is not enabled. Using this site across multiple tabs may not function correctly.');\n        }\n        if (ssrMode) {\n            return new SSRDBAdapter();\n        }\n        return this.openAdapter();\n    }\n}\n","export {};\n","import { BaseObserver, ConnectionClosedError, createLogger } from '@powersync/common';\nimport { getNavigatorLocks } from '../../shared/navigator.js';\nimport { WorkerWrappedAsyncDatabaseConnection } from './WorkerWrappedAsyncDatabaseConnection.js';\nimport { WASQLiteVFS } from './wa-sqlite/WASQLiteConnection.js';\n/**\n * @internal\n * Wraps a {@link AsyncDatabaseConnection} and provides exclusive locking functions in\n * order to implement {@link DBAdapter}.\n */\nexport class LockedAsyncDatabaseAdapter extends BaseObserver {\n    options;\n    logger;\n    dbGetHelpers;\n    debugMode;\n    _dbIdentifier;\n    initPromise;\n    _db = null;\n    _disposeTableChangeListener = null;\n    _config = null;\n    pendingAbortControllers;\n    requiresHolds;\n    databaseOpenPromise = null;\n    closing;\n    closed;\n    constructor(options) {\n        super();\n        this.options = options;\n        this._dbIdentifier = options.name;\n        this.logger = options.logger ?? createLogger(`LockedAsyncDatabaseAdapter - ${this._dbIdentifier}`);\n        this.pendingAbortControllers = new Set();\n        this.closed = false;\n        this.closing = false;\n        this.requiresHolds = null;\n        // Set the name if provided. We can query for the name if not available yet\n        this.debugMode = options.debugMode ?? false;\n        if (this.debugMode) {\n            const originalExecute = this._execute.bind(this);\n            this._execute = async (sql, bindings) => {\n                const start = performance.now();\n                try {\n                    const r = await originalExecute(sql, bindings);\n                    performance.measure(`[SQL] ${sql}`, { start });\n                    return r;\n                }\n                catch (e) {\n                    performance.measure(`[SQL] [ERROR: ${e.message}] ${sql}`, { start });\n                    throw e;\n                }\n            };\n        }\n        this.dbGetHelpers = this.generateDBHelpers({\n            execute: (query, params) => this.acquireLock(() => this._execute(query, params)),\n            executeRaw: (query, params) => this.acquireLock(() => this._executeRaw(query, params))\n        });\n        this.initPromise = this._init();\n    }\n    get baseDB() {\n        if (!this._db) {\n            throw new Error(`Initialization has not completed yet. Cannot access base db`);\n        }\n        return this._db;\n    }\n    get name() {\n        return this._dbIdentifier;\n    }\n    /**\n     * Init is automatic, this helps catch errors or explicitly await initialization\n     */\n    async init() {\n        return this.initPromise;\n    }\n    async openInternalDB() {\n        /**\n         * Execute opening of the db in a lock in order not to interfere with other operations.\n         */\n        return this._acquireLock(async () => {\n            // Dispose any previous table change listener.\n            this._disposeTableChangeListener?.();\n            this._disposeTableChangeListener = null;\n            this._db?.close().catch((ex) => this.logger.warn(`Error closing database before opening new instance`, ex));\n            const isReOpen = !!this._db;\n            this._db = null;\n            this._db = await this.options.openConnection();\n            await this._db.init();\n            this._config = await this._db.getConfig();\n            await this.registerOnChangeListener(this._db);\n            if (isReOpen) {\n                this.iterateListeners((cb) => cb.databaseReOpened?.());\n            }\n            /**\n             * This is only required for the long-lived shared IndexedDB connections.\n             */\n            this.requiresHolds = this._config.vfs == WASQLiteVFS.IDBBatchAtomicVFS;\n        });\n    }\n    _reOpen() {\n        this.databaseOpenPromise = this.openInternalDB().finally(() => {\n            this.databaseOpenPromise = null;\n        });\n        return this.databaseOpenPromise;\n    }\n    /**\n     * Re-opens the underlying database.\n     * Returns a pending operation if one is already in progress.\n     */\n    async reOpenInternalDB() {\n        if (this.closing || !this.options.reOpenOnConnectionClosed) {\n            // No-op\n            return;\n        }\n        else if (this.databaseOpenPromise) {\n            // Already busy opening\n            return this.databaseOpenPromise;\n        }\n        else {\n            return this._reOpen();\n        }\n    }\n    async _init() {\n        /**\n         * For OPFS, we can see this open call sometimes fail due to NoModificationAllowedError.\n         * We should be able to recover from this by re-opening the database.\n         */\n        const maxAttempts = 3;\n        for (let count = 0; count < maxAttempts; count++) {\n            try {\n                await this.openInternalDB();\n                break;\n            }\n            catch (ex) {\n                if (count == maxAttempts - 1) {\n                    throw ex;\n                }\n                this.logger.warn(`Attempt ${count + 1} of ${maxAttempts} to open database failed, retrying in 1 second...`, ex);\n                await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n        }\n        this.iterateListeners((cb) => cb.initialized?.());\n    }\n    getConfiguration() {\n        if (!this._config) {\n            throw new Error(`Cannot get config before initialization is completed`);\n        }\n        return {\n            ...this._config,\n            // This can be overridden by the adapter later\n            requiresPersistentTriggers: false\n        };\n    }\n    async waitForInitialized() {\n        // Awaiting this will expose errors on function calls like .execute etc\n        await this.initPromise;\n    }\n    async shareConnection() {\n        if (false == this._db instanceof WorkerWrappedAsyncDatabaseConnection) {\n            throw new Error(`Only worker connections can be shared`);\n        }\n        return this._db.shareConnection();\n    }\n    /**\n     * Registers a table change notification callback with the base database.\n     * This can be extended by custom implementations in order to handle proxy events.\n     */\n    async registerOnChangeListener(db) {\n        this._disposeTableChangeListener = await db.registerOnTableChange((event) => {\n            this.iterateListeners((cb) => cb.tablesUpdated?.(event));\n        });\n    }\n    /**\n     * This is currently a no-op on web\n     */\n    async refreshSchema() { }\n    async execute(query, params) {\n        return this.writeLock((ctx) => ctx.execute(query, params));\n    }\n    async executeRaw(query, params) {\n        return this.writeLock((ctx) => ctx.executeRaw(query, params));\n    }\n    async executeBatch(query, params) {\n        return this.writeLock((ctx) => this._executeBatch(query, params));\n    }\n    /**\n     * Attempts to close the connection.\n     * Shared workers might not actually close the connection if other\n     * tabs are still using it.\n     */\n    async close() {\n        this.closing = true;\n        /**\n         * Note that we obtain a reference to the callback to avoid calling the callback with `this` as the context.\n         * This is to avoid Comlink attempting to clone `this` when calling the method.\n         */\n        const dispose = this._disposeTableChangeListener;\n        if (dispose) {\n            dispose();\n        }\n        this.pendingAbortControllers.forEach((controller) => controller.abort('Closed'));\n        await this.baseDB?.close?.();\n        this.closed = true;\n    }\n    async getAll(sql, parameters) {\n        await this.waitForInitialized();\n        return this.dbGetHelpers.getAll(sql, parameters);\n    }\n    async getOptional(sql, parameters) {\n        await this.waitForInitialized();\n        return this.dbGetHelpers.getOptional(sql, parameters);\n    }\n    async get(sql, parameters) {\n        await this.waitForInitialized();\n        return this.dbGetHelpers.get(sql, parameters);\n    }\n    async readLock(fn, options) {\n        await this.waitForInitialized();\n        return this.acquireLock(async () => fn(this.generateDBHelpers({ execute: this._execute, executeRaw: this._executeRaw })), {\n            timeoutMs: options?.timeoutMs ?? this.options.defaultLockTimeoutMs\n        });\n    }\n    async writeLock(fn, options) {\n        await this.waitForInitialized();\n        return this.acquireLock(async () => fn(this.generateDBHelpers({ execute: this._execute, executeRaw: this._executeRaw })), {\n            timeoutMs: options?.timeoutMs ?? this.options.defaultLockTimeoutMs\n        });\n    }\n    async _acquireLock(callback, options) {\n        if (this.closing) {\n            throw new Error(`Cannot acquire lock, the database is closing`);\n        }\n        const abortController = new AbortController();\n        this.pendingAbortControllers.add(abortController);\n        const { timeoutMs } = options ?? {};\n        const timeoutId = timeoutMs\n            ? setTimeout(() => {\n                abortController.abort(`Timeout after ${timeoutMs}ms`);\n                this.pendingAbortControllers.delete(abortController);\n            }, timeoutMs)\n            : null;\n        return getNavigatorLocks().request(`db-lock-${this._dbIdentifier}`, { signal: abortController.signal }, async () => {\n            this.pendingAbortControllers.delete(abortController);\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n            return await callback();\n        });\n    }\n    async acquireLock(callback, options) {\n        await this.waitForInitialized();\n        // The database is being (re)opened in the background. Wait for it here.\n        if (this.databaseOpenPromise) {\n            await this.databaseOpenPromise;\n        }\n        else if (!this._db) {\n            /**\n             * The database is not open anymore, we might need to re-open it.\n             * Typically, _db, can be `null` if we tried to reOpen the database, but failed to succeed in re-opening.\n             * This can happen when disconnecting the client.\n             * Note: It is safe to re-enter this method multiple times.\n             */\n            await this.reOpenInternalDB();\n        }\n        return this._acquireLock(async () => {\n            let holdId = null;\n            try {\n                /**\n                 * We can't await this since it uses the same lock as we're in now.\n                 * If there is a pending open, this call will throw.\n                 * If there is no pending open, but there is also no database - the open\n                 * might have failed. We need to re-open the database.\n                 */\n                if (this.databaseOpenPromise || !this._db) {\n                    throw new ConnectionClosedError('Connection is busy re-opening');\n                }\n                holdId = this.requiresHolds ? await this.baseDB.markHold() : null;\n                return await callback();\n            }\n            catch (ex) {\n                if (ConnectionClosedError.MATCHES(ex)) {\n                    // Immediately re-open the database. We need to miss as little table updates as possible.\n                    // Note, don't await this since it uses the same lock as we're in now.\n                    this.reOpenInternalDB();\n                }\n                throw ex;\n            }\n            finally {\n                if (holdId) {\n                    await this.baseDB.releaseHold(holdId);\n                }\n            }\n        }, options);\n    }\n    async readTransaction(fn, options) {\n        return this.readLock(this.wrapTransaction(fn));\n    }\n    writeTransaction(fn, options) {\n        return this.writeLock(this.wrapTransaction(fn, true));\n    }\n    generateDBHelpers(tx) {\n        return {\n            ...tx,\n            /**\n             *  Execute a read-only query and return results\n             */\n            async getAll(sql, parameters) {\n                const res = await tx.execute(sql, parameters);\n                return res.rows?._array ?? [];\n            },\n            /**\n             * Execute a read-only query and return the first result, or null if the ResultSet is empty.\n             */\n            async getOptional(sql, parameters) {\n                const res = await tx.execute(sql, parameters);\n                return res.rows?.item(0) ?? null;\n            },\n            /**\n             * Execute a read-only query and return the first result, error if the ResultSet is empty.\n             */\n            async get(sql, parameters) {\n                const res = await tx.execute(sql, parameters);\n                const first = res.rows?.item(0);\n                if (!first) {\n                    throw new Error('Result set is empty');\n                }\n                return first;\n            }\n        };\n    }\n    /**\n     * Wraps a lock context into a transaction context\n     */\n    wrapTransaction(cb, write = false) {\n        return async (tx) => {\n            await this._execute(write ? 'BEGIN EXCLUSIVE' : 'BEGIN');\n            let finalized = false;\n            const commit = async () => {\n                if (finalized) {\n                    return { rowsAffected: 0 };\n                }\n                finalized = true;\n                return this._execute('COMMIT');\n            };\n            const rollback = () => {\n                finalized = true;\n                return this._execute('ROLLBACK');\n            };\n            try {\n                const result = await cb({\n                    ...tx,\n                    commit,\n                    rollback\n                });\n                if (!finalized) {\n                    await commit();\n                }\n                return result;\n            }\n            catch (ex) {\n                this.logger.debug('Caught ex in transaction', ex);\n                try {\n                    await rollback();\n                }\n                catch (ex2) {\n                    // In rare cases, a rollback may fail.\n                    // Safe to ignore.\n                }\n                throw ex;\n            }\n        };\n    }\n    /**\n     * Wraps the worker execute function, awaiting for it to be available\n     */\n    _execute = async (sql, bindings) => {\n        await this.waitForInitialized();\n        const result = await this.baseDB.execute(sql, bindings);\n        return {\n            ...result,\n            rows: {\n                ...result.rows,\n                item: (idx) => result.rows._array[idx]\n            }\n        };\n    };\n    /**\n     * Wraps the worker executeRaw function, awaiting for it to be available\n     */\n    _executeRaw = async (sql, bindings) => {\n        await this.waitForInitialized();\n        return await this.baseDB.executeRaw(sql, bindings);\n    };\n    /**\n     * Wraps the worker executeBatch function, awaiting for it to be available\n     */\n    _executeBatch = async (query, params) => {\n        await this.waitForInitialized();\n        const result = await this.baseDB.executeBatch(query, params);\n        return {\n            ...result,\n            rows: undefined\n        };\n    };\n}\n","import { BaseObserver } from '@powersync/common';\nimport { Mutex } from 'async-mutex';\nconst MOCK_QUERY_RESPONSE = {\n    rowsAffected: 0\n};\n/**\n * Implements a Mock DB adapter for use in Server Side Rendering (SSR).\n * This adapter will return empty results for queries, which will allow\n * server rendered views to initially generate scaffolding components\n */\nexport class SSRDBAdapter extends BaseObserver {\n    name;\n    readMutex;\n    writeMutex;\n    constructor() {\n        super();\n        this.name = 'SSR DB';\n        this.readMutex = new Mutex();\n        this.writeMutex = new Mutex();\n    }\n    close() { }\n    async readLock(fn, options) {\n        return this.readMutex.runExclusive(() => fn(this));\n    }\n    async readTransaction(fn, options) {\n        return this.readLock(() => fn(this.generateMockTransactionContext()));\n    }\n    async writeLock(fn, options) {\n        return this.writeMutex.runExclusive(() => fn(this));\n    }\n    async writeTransaction(fn, options) {\n        return this.writeLock(() => fn(this.generateMockTransactionContext()));\n    }\n    async execute(query, params) {\n        return this.writeMutex.runExclusive(async () => MOCK_QUERY_RESPONSE);\n    }\n    async executeRaw(query, params) {\n        return this.writeMutex.runExclusive(async () => []);\n    }\n    async executeBatch(query, params) {\n        return this.writeMutex.runExclusive(async () => MOCK_QUERY_RESPONSE);\n    }\n    async getAll(sql, parameters) {\n        return [];\n    }\n    async getOptional(sql, parameters) {\n        return null;\n    }\n    async get(sql, parameters) {\n        throw new Error(`No values are returned in SSR mode`);\n    }\n    /**\n     * Generates a mock context for use in read/write transactions.\n     * `this` already mocks most of the API, commit and rollback mocks\n     *  are added here\n     */\n    generateMockTransactionContext() {\n        return {\n            ...this,\n            commit: async () => {\n                return MOCK_QUERY_RESPONSE;\n            },\n            rollback: async () => {\n                return MOCK_QUERY_RESPONSE;\n            }\n        };\n    }\n    async refreshSchema() { }\n}\n","import { BaseObserver, ConnectionClosedError } from '@powersync/common';\nimport * as Comlink from 'comlink';\n/**\n * Wraps a provided instance of {@link AsyncDatabaseConnection}, providing necessary proxy\n * functions for worker listeners.\n */\nexport class WorkerWrappedAsyncDatabaseConnection extends BaseObserver {\n    options;\n    lockAbortController = new AbortController();\n    notifyRemoteClosed;\n    constructor(options) {\n        super();\n        this.options = options;\n        if (options.remoteCanCloseUnexpectedly) {\n            this.notifyRemoteClosed = new AbortController();\n        }\n    }\n    get baseConnection() {\n        return this.options.baseConnection;\n    }\n    init() {\n        return this.baseConnection.init();\n    }\n    /**\n     * Marks the remote as closed.\n     *\n     * This can sometimes happen outside of our control, e.g. when a shared worker requests a connection from a tab. When\n     * it happens, all methods on the {@link baseConnection} would never resolve. To avoid livelocks in this scenario, we\n     * throw on all outstanding promises and forbid new calls.\n     */\n    markRemoteClosed() {\n        // Can non-null assert here because this function is only supposed to be called when remoteCanCloseUnexpectedly was\n        // set.\n        this.notifyRemoteClosed.abort();\n    }\n    markHold() {\n        return this.withRemote(() => this.baseConnection.markHold());\n    }\n    releaseHold(holdId) {\n        return this.withRemote(() => this.baseConnection.releaseHold(holdId));\n    }\n    isAutoCommit() {\n        return this.withRemote(() => this.baseConnection.isAutoCommit());\n    }\n    withRemote(workerPromise, fireActionOnAbort = false) {\n        const controller = this.notifyRemoteClosed;\n        if (controller) {\n            return new Promise((resolve, reject) => {\n                if (controller.signal.aborted) {\n                    reject(new ConnectionClosedError('Called operation on closed remote'));\n                    if (!fireActionOnAbort) {\n                        // Don't run the operation if we're going to reject\n                        // We might want to fire-and-forget the operation in some cases (like a close operation)\n                        return;\n                    }\n                }\n                function handleAbort() {\n                    reject(new ConnectionClosedError('Remote peer closed with request in flight'));\n                }\n                function completePromise(action) {\n                    controller.signal.removeEventListener('abort', handleAbort);\n                    action();\n                }\n                controller.signal.addEventListener('abort', handleAbort);\n                workerPromise()\n                    .then((data) => completePromise(() => resolve(data)))\n                    .catch((e) => completePromise(() => reject(e)));\n            });\n        }\n        else {\n            // Can't close, so just return the inner worker promise unguarded.\n            return workerPromise();\n        }\n    }\n    /**\n     * Get a MessagePort which can be used to share the internals of this connection.\n     */\n    async shareConnection() {\n        const { identifier, remote } = this.options;\n        /**\n         * Hold a navigator lock in order to avoid features such as Chrome's frozen tabs,\n         * or Edge's sleeping tabs from pausing the thread for this connection.\n         * This promise resolves once a lock is obtained.\n         * This lock will be held as long as this connection is open.\n         * The `shareConnection` method should not be called on multiple tabs concurrently.\n         */\n        await new Promise((resolve, reject) => navigator.locks\n            .request(`shared-connection-${this.options.identifier}-${Date.now()}-${Math.round(Math.random() * 10000)}`, {\n            signal: this.lockAbortController.signal\n        }, async () => {\n            resolve();\n            // Free the lock when the connection is already closed.\n            if (this.lockAbortController.signal.aborted) {\n                return;\n            }\n            // Hold the lock while the shared connection is in use.\n            await new Promise((releaseLock) => {\n                this.lockAbortController.signal.addEventListener('abort', () => {\n                    releaseLock();\n                });\n            });\n        })\n            // We aren't concerned with abort errors here\n            .catch((ex) => {\n            if (ex.name == 'AbortError') {\n                resolve();\n            }\n            else {\n                reject(ex);\n            }\n        }));\n        const newPort = await remote[Comlink.createEndpoint]();\n        return { port: newPort, identifier };\n    }\n    /**\n     * Registers a table change notification callback with the base database.\n     * This can be extended by custom implementations in order to handle proxy events.\n     */\n    async registerOnTableChange(callback) {\n        return this.baseConnection.registerOnTableChange(Comlink.proxy(callback));\n    }\n    async close() {\n        // Abort any pending lock requests.\n        this.lockAbortController.abort();\n        try {\n            // fire and forget the close operation\n            await this.withRemote(() => this.baseConnection.close(), true);\n        }\n        finally {\n            this.options.remote[Comlink.releaseProxy]();\n            this.options.onClose?.();\n            this.iterateListeners((l) => l.closing?.());\n        }\n    }\n    execute(sql, params) {\n        return this.withRemote(() => this.baseConnection.execute(sql, params));\n    }\n    executeRaw(sql, params) {\n        return this.withRemote(() => this.baseConnection.executeRaw(sql, params));\n    }\n    executeBatch(sql, params) {\n        return this.withRemote(() => this.baseConnection.executeBatch(sql, params));\n    }\n    getConfig() {\n        return this.withRemote(() => this.baseConnection.getConfig());\n    }\n}\n","import { LockedAsyncDatabaseAdapter } from '../LockedAsyncDatabaseAdapter.js';\nimport { WASQLiteVFS } from './WASQLiteConnection.js';\n/**\n * @internal\n * An intermediary implementation of WASQLiteDBAdapter, which takes the same\n * constructor arguments as {@link LockedAsyncDatabaseAdapter}, but provides some\n * basic WA-SQLite specific functionality.\n * This base class is used to avoid requiring overloading the constructor of {@link WASQLiteDBAdapter}\n */\nexport class InternalWASQLiteDBAdapter extends LockedAsyncDatabaseAdapter {\n    getConfiguration() {\n        // This is valid since we only handle WASQLite connections\n        const baseConfig = super.getConfiguration();\n        return {\n            ...super.getConfiguration(),\n            requiresPersistentTriggers: baseConfig.vfs == WASQLiteVFS.OPFSCoopSyncVFS || baseConfig.vfs == WASQLiteVFS.AccessHandlePoolVFS\n        };\n    }\n}\n","import * as SQLite from '@journeyapps/wa-sqlite';\nimport { BaseObserver } from '@powersync/common';\nimport { Mutex } from 'async-mutex';\n/**\n * List of currently tested virtual filesystems\n */\nexport var WASQLiteVFS;\n(function (WASQLiteVFS) {\n    WASQLiteVFS[\"IDBBatchAtomicVFS\"] = \"IDBBatchAtomicVFS\";\n    WASQLiteVFS[\"OPFSCoopSyncVFS\"] = \"OPFSCoopSyncVFS\";\n    WASQLiteVFS[\"AccessHandlePoolVFS\"] = \"AccessHandlePoolVFS\";\n})(WASQLiteVFS || (WASQLiteVFS = {}));\n/**\n * @internal\n */\nexport const AsyncWASQLiteModuleFactory = async () => {\n    const { default: factory } = await import('@journeyapps/wa-sqlite/dist/wa-sqlite-async.mjs');\n    return factory();\n};\n/**\n * @internal\n */\nexport const MultiCipherAsyncWASQLiteModuleFactory = async () => {\n    const { default: factory } = await import('@journeyapps/wa-sqlite/dist/mc-wa-sqlite-async.mjs');\n    return factory();\n};\n/**\n * @internal\n */\nexport const SyncWASQLiteModuleFactory = async () => {\n    const { default: factory } = await import('@journeyapps/wa-sqlite/dist/wa-sqlite.mjs');\n    return factory();\n};\n/**\n * @internal\n */\nexport const MultiCipherSyncWASQLiteModuleFactory = async () => {\n    const { default: factory } = await import('@journeyapps/wa-sqlite/dist/mc-wa-sqlite.mjs');\n    return factory();\n};\n/**\n * @internal\n */\nexport const DEFAULT_MODULE_FACTORIES = {\n    [WASQLiteVFS.IDBBatchAtomicVFS]: async (options) => {\n        let module;\n        if (options.encryptionKey) {\n            module = await MultiCipherAsyncWASQLiteModuleFactory();\n        }\n        else {\n            module = await AsyncWASQLiteModuleFactory();\n        }\n        const { IDBBatchAtomicVFS } = await import('@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js');\n        return {\n            module,\n            // @ts-expect-error The types for this static method are missing upstream\n            vfs: await IDBBatchAtomicVFS.create(options.dbFileName, module, { lockPolicy: 'exclusive' })\n        };\n    },\n    [WASQLiteVFS.AccessHandlePoolVFS]: async (options) => {\n        let module;\n        if (options.encryptionKey) {\n            module = await MultiCipherSyncWASQLiteModuleFactory();\n        }\n        else {\n            module = await SyncWASQLiteModuleFactory();\n        }\n        // @ts-expect-error The types for this static method are missing upstream\n        const { AccessHandlePoolVFS } = await import('@journeyapps/wa-sqlite/src/examples/AccessHandlePoolVFS.js');\n        return {\n            module,\n            vfs: await AccessHandlePoolVFS.create(options.dbFileName, module)\n        };\n    },\n    [WASQLiteVFS.OPFSCoopSyncVFS]: async (options) => {\n        let module;\n        if (options.encryptionKey) {\n            module = await MultiCipherSyncWASQLiteModuleFactory();\n        }\n        else {\n            module = await SyncWASQLiteModuleFactory();\n        }\n        // @ts-expect-error The types for this static method are missing upstream\n        const { OPFSCoopSyncVFS } = await import('@journeyapps/wa-sqlite/src/examples/OPFSCoopSyncVFS.js');\n        const vfs = await OPFSCoopSyncVFS.create(options.dbFileName, module);\n        return {\n            module,\n            vfs\n        };\n    }\n};\n/**\n * @internal\n * WA-SQLite connection which directly interfaces with WA-SQLite.\n * This is usually instantiated inside a worker.\n */\nexport class WASqliteConnection extends BaseObserver {\n    options;\n    _sqliteAPI = null;\n    _dbP = null;\n    _moduleFactory;\n    updatedTables;\n    updateTimer;\n    statementMutex;\n    broadcastChannel;\n    /**\n     * Unique id for this specific connection. This is used to prevent broadcast table change\n     * notification loops.\n     */\n    connectionId;\n    _holdCounter;\n    _holdId;\n    constructor(options) {\n        super();\n        this.options = options;\n        this.updatedTables = new Set();\n        this.updateTimer = null;\n        this.broadcastChannel = null;\n        this.connectionId = new Date().valueOf() + Math.random();\n        this.statementMutex = new Mutex();\n        this._moduleFactory = DEFAULT_MODULE_FACTORIES[this.options.vfs];\n        this._holdCounter = 0;\n        this._holdId = null;\n    }\n    /**\n     * Gets the id for the current hold.\n     * This can be used to check for invalid states.\n     */\n    get currentHoldId() {\n        return this._holdId;\n    }\n    get sqliteAPI() {\n        if (!this._sqliteAPI) {\n            throw new Error(`Initialization has not completed`);\n        }\n        return this._sqliteAPI;\n    }\n    get dbP() {\n        if (!this._dbP) {\n            throw new Error(`Initialization has not completed`);\n        }\n        return this._dbP;\n    }\n    /**\n     * Checks if the database connection is in autocommit mode.\n     * @returns true if in autocommit mode, false if in a transaction\n     */\n    async isAutoCommit() {\n        return this.sqliteAPI.get_autocommit(this.dbP) != 0;\n    }\n    async markHold() {\n        const previousHoldId = this._holdId;\n        this._holdId = `${++this._holdCounter}`;\n        if (previousHoldId) {\n            await this.iterateAsyncListeners(async (cb) => cb.holdOverwritten?.(previousHoldId));\n        }\n        return this._holdId;\n    }\n    async releaseHold(holdId) {\n        if (holdId != this._holdId) {\n            throw new Error(`Invalid hold state, expected ${this._holdId} but got ${holdId}`);\n        }\n        this._holdId = null;\n    }\n    async openDB() {\n        this._dbP = await this.sqliteAPI.open_v2(this.options.dbFilename);\n        return this._dbP;\n    }\n    async executeEncryptionPragma() {\n        if (this.options.encryptionKey) {\n            await this.executeSingleStatement(`PRAGMA key = \"${this.options.encryptionKey}\"`);\n        }\n        return;\n    }\n    async openSQLiteAPI() {\n        const { module, vfs } = await this._moduleFactory({\n            dbFileName: this.options.dbFilename,\n            encryptionKey: this.options.encryptionKey\n        });\n        const sqlite3 = SQLite.Factory(module);\n        sqlite3.vfs_register(vfs, true);\n        /**\n         * Register the PowerSync core SQLite extension\n         */\n        module.ccall('powersync_init_static', 'int', []);\n        /**\n         * Create the multiple cipher vfs if an encryption key is provided\n         */\n        if (this.options.encryptionKey) {\n            const createResult = module.ccall('sqlite3mc_vfs_create', 'int', ['string', 'int'], [this.options.dbFilename, 1]);\n            if (createResult !== 0) {\n                throw new Error('Failed to create multiple cipher vfs, Database encryption will not work');\n            }\n        }\n        return sqlite3;\n    }\n    registerBroadcastListeners() {\n        this.broadcastChannel = new BroadcastChannel(`${this.options.dbFilename}-table-updates`);\n        this.broadcastChannel.addEventListener('message', (event) => {\n            const data = event.data;\n            if (this.connectionId == data.connectionId) {\n                // Ignore messages from the same connection\n                return;\n            }\n            // Ensuring that we don't rebroadcast the same message\n            this.queueTableUpdate(data.changedTables, false);\n        });\n    }\n    queueTableUpdate(tableNames, shouldBroadcast = true) {\n        tableNames.forEach((tableName) => this.updatedTables.add(tableName));\n        if (this.updateTimer == null) {\n            this.updateTimer = setTimeout(() => this.fireUpdates(shouldBroadcast), 0);\n        }\n    }\n    async init() {\n        this._sqliteAPI = await this.openSQLiteAPI();\n        await this.openDB();\n        this.registerBroadcastListeners();\n        await this.executeSingleStatement(`PRAGMA temp_store = ${this.options.temporaryStorage};`);\n        await this.executeEncryptionPragma();\n        await this.executeSingleStatement(`PRAGMA cache_size = -${this.options.cacheSizeKb};`);\n        this.sqliteAPI.update_hook(this.dbP, (updateType, dbName, tableName) => {\n            if (!tableName) {\n                return;\n            }\n            const changedTables = new Set([tableName]);\n            this.queueTableUpdate(changedTables);\n        });\n    }\n    async getConfig() {\n        return this.options;\n    }\n    fireUpdates(shouldBroadcast = true) {\n        this.updateTimer = null;\n        const event = { tables: [...this.updatedTables], groupedUpdates: {}, rawUpdates: [] };\n        // Share to other connections\n        if (shouldBroadcast) {\n            this.broadcastChannel.postMessage({\n                changedTables: this.updatedTables,\n                connectionId: this.connectionId\n            });\n        }\n        this.updatedTables.clear();\n        this.iterateListeners((cb) => cb.tablesUpdated?.(event));\n    }\n    /**\n     * This executes SQL statements in a batch.\n     */\n    async executeBatch(sql, bindings) {\n        return this.acquireExecuteLock(async () => {\n            let affectedRows = 0;\n            try {\n                await this.executeSingleStatement('BEGIN TRANSACTION');\n                const wrappedBindings = bindings ? bindings : [];\n                for await (const stmt of this.sqliteAPI.statements(this.dbP, sql)) {\n                    if (stmt === null) {\n                        return {\n                            rowsAffected: 0,\n                            rows: { _array: [], length: 0 }\n                        };\n                    }\n                    //Prepare statement once\n                    for (const binding of wrappedBindings) {\n                        // TODO not sure why this is needed currently, but booleans break\n                        for (let i = 0; i < binding.length; i++) {\n                            const b = binding[i];\n                            if (typeof b == 'boolean') {\n                                binding[i] = b ? 1 : 0;\n                            }\n                        }\n                        if (bindings) {\n                            this.sqliteAPI.bind_collection(stmt, binding);\n                        }\n                        const result = await this.sqliteAPI.step(stmt);\n                        if (result === SQLite.SQLITE_DONE) {\n                            //The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero.\n                            affectedRows += this.sqliteAPI.changes(this.dbP);\n                        }\n                        this.sqliteAPI.reset(stmt);\n                    }\n                }\n                await this.executeSingleStatement('COMMIT');\n            }\n            catch (err) {\n                await this.executeSingleStatement('ROLLBACK');\n                return {\n                    rowsAffected: 0,\n                    rows: { _array: [], length: 0 }\n                };\n            }\n            const result = {\n                rowsAffected: affectedRows,\n                rows: { _array: [], length: 0 }\n            };\n            return result;\n        });\n    }\n    /**\n     * This executes single SQL statements inside a requested lock.\n     */\n    async execute(sql, bindings) {\n        // Running multiple statements on the same connection concurrently should not be allowed\n        return this.acquireExecuteLock(async () => {\n            return this.executeSingleStatement(sql, bindings);\n        });\n    }\n    async executeRaw(sql, bindings) {\n        return this.acquireExecuteLock(async () => {\n            return this.executeSingleStatementRaw(sql, bindings);\n        });\n    }\n    async close() {\n        this.broadcastChannel?.close();\n        await this.acquireExecuteLock(async () => {\n            /**\n             * Running the close operation inside the same execute mutex prevents errors like:\n             * ```\n             * unable to close due to unfinalized statements or unfinished backups\n             * ```\n             */\n            await this.sqliteAPI.close(this.dbP);\n        });\n    }\n    async registerOnTableChange(callback) {\n        return this.registerListener({\n            tablesUpdated: (event) => callback(event)\n        });\n    }\n    /**\n     * This requests a lock for executing statements.\n     * Should only be used internally.\n     */\n    acquireExecuteLock = (callback) => {\n        return this.statementMutex.runExclusive(callback);\n    };\n    /**\n     * This executes a single statement using SQLite3.\n     */\n    async executeSingleStatement(sql, bindings) {\n        const results = await this._execute(sql, bindings);\n        const rows = [];\n        for (const resultSet of results) {\n            for (const row of resultSet.rows) {\n                const outRow = {};\n                resultSet.columns.forEach((key, index) => {\n                    outRow[key] = row[index];\n                });\n                rows.push(outRow);\n            }\n        }\n        const result = {\n            insertId: this.sqliteAPI.last_insert_id(this.dbP),\n            rowsAffected: this.sqliteAPI.changes(this.dbP),\n            rows: {\n                _array: rows,\n                length: rows.length\n            }\n        };\n        return result;\n    }\n    /**\n     * This executes a single statement using SQLite3 and returns the results as an array of arrays.\n     */\n    async executeSingleStatementRaw(sql, bindings) {\n        const results = await this._execute(sql, bindings);\n        return results.flatMap((resultset) => resultset.rows.map((row) => resultset.columns.map((_, index) => row[index])));\n    }\n    async _execute(sql, bindings) {\n        const results = [];\n        for await (const stmt of this.sqliteAPI.statements(this.dbP, sql)) {\n            let columns;\n            const wrappedBindings = bindings ? [bindings] : [[]];\n            for (const binding of wrappedBindings) {\n                // TODO not sure why this is needed currently, but booleans break\n                binding.forEach((b, index, arr) => {\n                    if (typeof b == 'boolean') {\n                        arr[index] = b ? 1 : 0;\n                    }\n                });\n                this.sqliteAPI.reset(stmt);\n                if (bindings) {\n                    this.sqliteAPI.bind_collection(stmt, binding);\n                }\n                const rows = [];\n                while ((await this.sqliteAPI.step(stmt)) === SQLite.SQLITE_ROW) {\n                    const row = this.sqliteAPI.row(stmt);\n                    rows.push(row);\n                }\n                columns = columns ?? this.sqliteAPI.column_names(stmt);\n                if (columns.length) {\n                    results.push({ columns, rows });\n                }\n            }\n            // When binding parameters, only a single statement is executed.\n            if (bindings) {\n                break;\n            }\n        }\n        return results;\n    }\n}\n","import * as Comlink from 'comlink';\nimport { resolveWebPowerSyncFlags } from '../../PowerSyncDatabase.js';\nimport { DEFAULT_CACHE_SIZE_KB, TemporaryStorageOption } from '../web-sql-flags.js';\nimport { WorkerWrappedAsyncDatabaseConnection } from '../WorkerWrappedAsyncDatabaseConnection.js';\nimport { InternalWASQLiteDBAdapter } from './InternalWASQLiteDBAdapter.js';\nimport { WASQLiteOpenFactory } from './WASQLiteOpenFactory.js';\n/**\n * Adapter for WA-SQLite SQLite connections.\n */\nexport class WASQLiteDBAdapter extends InternalWASQLiteDBAdapter {\n    constructor(options) {\n        super({\n            name: options.dbFilename,\n            openConnection: async () => {\n                const { workerPort, temporaryStorage, cacheSizeKb } = options;\n                if (workerPort) {\n                    const remote = Comlink.wrap(workerPort);\n                    return new WorkerWrappedAsyncDatabaseConnection({\n                        remote,\n                        remoteCanCloseUnexpectedly: false,\n                        identifier: options.dbFilename,\n                        baseConnection: await remote({\n                            ...options,\n                            temporaryStorage: temporaryStorage ?? TemporaryStorageOption.MEMORY,\n                            cacheSizeKb: cacheSizeKb ?? DEFAULT_CACHE_SIZE_KB,\n                            flags: resolveWebPowerSyncFlags(options.flags),\n                            encryptionKey: options.encryptionKey\n                        })\n                    });\n                }\n                const openFactory = new WASQLiteOpenFactory({\n                    dbFilename: options.dbFilename,\n                    dbLocation: options.dbLocation,\n                    debugMode: options.debugMode,\n                    flags: options.flags,\n                    temporaryStorage,\n                    cacheSizeKb,\n                    logger: options.logger,\n                    vfs: options.vfs,\n                    encryptionKey: options.encryptionKey,\n                    worker: options.worker\n                });\n                return openFactory.openConnection();\n            },\n            debugMode: options.debugMode,\n            logger: options.logger\n        });\n    }\n}\n","import * as Comlink from 'comlink';\nimport { openWorkerDatabasePort, resolveWorkerDatabasePortFactory } from '../../../worker/db/open-worker-database.js';\nimport { AbstractWebSQLOpenFactory } from '../AbstractWebSQLOpenFactory.js';\nimport { WorkerWrappedAsyncDatabaseConnection } from '../WorkerWrappedAsyncDatabaseConnection.js';\nimport { DEFAULT_CACHE_SIZE_KB, TemporaryStorageOption } from '../web-sql-flags.js';\nimport { InternalWASQLiteDBAdapter } from './InternalWASQLiteDBAdapter.js';\nimport { WASQLiteVFS, WASqliteConnection } from './WASQLiteConnection.js';\n/**\n * Opens a SQLite connection using WA-SQLite.\n */\nexport class WASQLiteOpenFactory extends AbstractWebSQLOpenFactory {\n    constructor(options) {\n        super(options);\n        assertValidWASQLiteOpenFactoryOptions(options);\n    }\n    get waOptions() {\n        // Cast to extended type\n        return this.options;\n    }\n    openAdapter() {\n        return new InternalWASQLiteDBAdapter({\n            name: this.options.dbFilename,\n            openConnection: () => this.openConnection(),\n            debugMode: this.options.debugMode,\n            logger: this.logger\n        });\n    }\n    async openConnection() {\n        const { enableMultiTabs, useWebWorker } = this.resolvedFlags;\n        const { vfs = WASQLiteVFS.IDBBatchAtomicVFS, temporaryStorage = TemporaryStorageOption.MEMORY, cacheSizeKb = DEFAULT_CACHE_SIZE_KB, encryptionKey } = this.waOptions;\n        if (!enableMultiTabs) {\n            this.logger.warn('Multiple tabs are not enabled in this browser');\n        }\n        if (useWebWorker) {\n            const optionsDbWorker = this.options.worker;\n            const workerPort = typeof optionsDbWorker == 'function'\n                ? resolveWorkerDatabasePortFactory(() => optionsDbWorker({\n                    ...this.options,\n                    temporaryStorage,\n                    cacheSizeKb,\n                    flags: this.resolvedFlags,\n                    encryptionKey\n                }))\n                : openWorkerDatabasePort(this.options.dbFilename, enableMultiTabs, optionsDbWorker, this.waOptions.vfs);\n            const workerDBOpener = Comlink.wrap(workerPort);\n            return new WorkerWrappedAsyncDatabaseConnection({\n                remote: workerDBOpener,\n                // This tab owns the worker, so we're guaranteed to outlive it.\n                remoteCanCloseUnexpectedly: false,\n                baseConnection: await workerDBOpener({\n                    dbFilename: this.options.dbFilename,\n                    vfs,\n                    temporaryStorage,\n                    cacheSizeKb,\n                    flags: this.resolvedFlags,\n                    encryptionKey: encryptionKey,\n                    logLevel: this.logger.getLevel()\n                }),\n                identifier: this.options.dbFilename,\n                onClose: () => {\n                    if (workerPort instanceof Worker) {\n                        workerPort.terminate();\n                    }\n                    else {\n                        workerPort.close();\n                    }\n                }\n            });\n        }\n        else {\n            // Don't use a web worker\n            return new WASqliteConnection({\n                dbFilename: this.options.dbFilename,\n                dbLocation: this.options.dbLocation,\n                debugMode: this.options.debugMode,\n                vfs,\n                temporaryStorage,\n                cacheSizeKb,\n                flags: this.resolvedFlags,\n                encryptionKey: encryptionKey\n            });\n        }\n    }\n}\n/**\n * Asserts that the factory options are valid.\n */\nfunction assertValidWASQLiteOpenFactoryOptions(options) {\n    // The OPFS VFS only works in dedicated web workers.\n    if ('vfs' in options && 'flags' in options) {\n        const { vfs, flags = {} } = options;\n        if (vfs !== WASQLiteVFS.IDBBatchAtomicVFS && 'useWebWorker' in flags && !flags.useWebWorker) {\n            throw new Error(`Invalid configuration: The 'useWebWorker' flag must be true when using an OPFS-based VFS (${vfs}).`);\n        }\n    }\n}\n","import { PowerSyncDatabase } from '../../../db/PowerSyncDatabase.js';\nimport { AbstractWebPowerSyncDatabaseOpenFactory } from '../AbstractWebPowerSyncDatabaseOpenFactory.js';\nimport { WASQLiteOpenFactory } from './WASQLiteOpenFactory.js';\n/**\n * @deprecated {@link PowerSyncDatabase} can now be constructed directly\n * @example\n * ```typescript\n * const powersync = new PowerSyncDatabase({database: {\n *  dbFileName: 'powersync.db'\n * }});\n * ```\n */\nexport class WASQLitePowerSyncDatabaseOpenFactory extends AbstractWebPowerSyncDatabaseOpenFactory {\n    openDB() {\n        const factory = new WASQLiteOpenFactory(this.options);\n        return factory.openDB();\n    }\n    generateInstance(options) {\n        return new PowerSyncDatabase(options);\n    }\n}\n","export var TemporaryStorageOption;\n(function (TemporaryStorageOption) {\n    TemporaryStorageOption[\"MEMORY\"] = \"memory\";\n    TemporaryStorageOption[\"FILESYSTEM\"] = \"file\";\n})(TemporaryStorageOption || (TemporaryStorageOption = {}));\nexport const DEFAULT_CACHE_SIZE_KB = 50 * 1024;\nexport function isServerSide() {\n    return typeof window == 'undefined';\n}\nexport const DEFAULT_WEB_SQL_FLAGS = {\n    broadcastLogs: true,\n    disableSSRWarning: false,\n    ssrMode: isServerSide(),\n    /**\n     * Multiple tabs are by default not supported on Android, iOS and Safari.\n     * Other platforms will have multiple tabs enabled by default.\n     */\n    enableMultiTabs: typeof globalThis.navigator !== 'undefined' && // For SSR purposes\n        typeof SharedWorker !== 'undefined' &&\n        !navigator.userAgent.match(/(Android|iPhone|iPod|iPad)/i) &&\n        !window.safari,\n    useWebWorker: true\n};\nexport function resolveWebSQLFlags(flags) {\n    const resolvedFlags = {\n        ...DEFAULT_WEB_SQL_FLAGS,\n        ...(flags ?? {})\n    };\n    if (typeof flags?.enableMultiTabs != 'undefined') {\n        resolvedFlags.enableMultiTabs = flags.enableMultiTabs;\n    }\n    if (flags?.useWebWorker === false) {\n        resolvedFlags.enableMultiTabs = false;\n    }\n    return resolvedFlags;\n}\n","import { BaseObserver, LockType, SyncStatus } from '@powersync/common';\nimport { Mutex } from 'async-mutex';\nexport class SSRStreamingSyncImplementation extends BaseObserver {\n    syncMutex;\n    crudMutex;\n    isConnected;\n    lastSyncedAt;\n    syncStatus;\n    constructor(options) {\n        super();\n        this.syncMutex = new Mutex();\n        this.crudMutex = new Mutex();\n        this.syncStatus = new SyncStatus({});\n        this.isConnected = false;\n    }\n    obtainLock(lockOptions) {\n        const mutex = lockOptions.type == LockType.CRUD ? this.crudMutex : this.syncMutex;\n        return mutex.runExclusive(lockOptions.callback);\n    }\n    /**\n     * This is a no-op in SSR mode\n     */\n    async connect(options) { }\n    async dispose() { }\n    /**\n     * This is a no-op in SSR mode\n     */\n    async disconnect() { }\n    /**\n     * This SSR Mode implementation is immediately ready.\n     */\n    async waitForReady() { }\n    /**\n     * This will never resolve in SSR Mode.\n     */\n    async waitForStatus(status) {\n        return this.waitUntilStatusMatches(() => false);\n    }\n    /**\n     * This will never resolve in SSR Mode.\n     */\n    waitUntilStatusMatches(_predicate) {\n        return new Promise(() => { });\n    }\n    /**\n     * Returns a placeholder checkpoint. This should not be used.\n     */\n    async getWriteCheckpoint() {\n        return '1';\n    }\n    /**\n     * The SSR mode adapter will never complete syncing.\n     */\n    async hasCompletedSync() {\n        return false;\n    }\n    /**\n     * This is a no-op in SSR mode.\n     */\n    triggerCrudUpload() { }\n    /**\n     * No-op in SSR mode.\n     */\n    updateSubscriptions() { }\n}\n","import * as Comlink from 'comlink';\nimport { getNavigatorLocks } from '../../shared/navigator.js';\nimport { AbstractSharedSyncClientProvider } from '../../worker/sync/AbstractSharedSyncClientProvider.js';\nimport { SharedSyncClientEvent } from '../../worker/sync/SharedSyncImplementation.js';\nimport { DEFAULT_CACHE_SIZE_KB, TemporaryStorageOption, resolveWebSQLFlags } from '../adapters/web-sql-flags.js';\nimport { WebStreamingSyncImplementation } from './WebStreamingSyncImplementation.js';\n/**\n * The shared worker will trigger methods on this side of the message port\n * via this client provider.\n */\nclass SharedSyncClientProvider extends AbstractSharedSyncClientProvider {\n    options;\n    statusChanged;\n    webDB;\n    constructor(options, statusChanged, webDB) {\n        super();\n        this.options = options;\n        this.statusChanged = statusChanged;\n        this.webDB = webDB;\n    }\n    async getDBWorkerPort() {\n        const { port } = await this.webDB.shareConnection();\n        return Comlink.transfer(port, [port]);\n    }\n    invalidateCredentials() {\n        this.options.remote.invalidateCredentials();\n    }\n    async fetchCredentials() {\n        const credentials = await this.options.remote.getCredentials();\n        if (credentials == null) {\n            return null;\n        }\n        /**\n         * The credentials need to be serializable.\n         * Users might extend [PowerSyncCredentials] to contain\n         * items which are not serializable.\n         * This returns only the essential fields.\n         */\n        return {\n            endpoint: credentials.endpoint,\n            token: credentials.token\n        };\n    }\n    async uploadCrud() {\n        /**\n         * Don't return anything here, just incase something which is not\n         * serializable is returned from the `uploadCrud` function.\n         */\n        await this.options.uploadCrud();\n    }\n    get logger() {\n        return this.options.logger;\n    }\n    trace(...x) {\n        this.logger?.trace(...x);\n    }\n    debug(...x) {\n        this.logger?.debug(...x);\n    }\n    info(...x) {\n        this.logger?.info(...x);\n    }\n    log(...x) {\n        this.logger?.log(...x);\n    }\n    warn(...x) {\n        this.logger?.warn(...x);\n    }\n    error(...x) {\n        this.logger?.error(...x);\n    }\n    time(label) {\n        this.logger?.time(label);\n    }\n    timeEnd(label) {\n        this.logger?.timeEnd(label);\n    }\n}\n/**\n * The local part of the sync implementation on the web, which talks to a sync implementation hosted in a shared worker.\n */\nexport class SharedWebStreamingSyncImplementation extends WebStreamingSyncImplementation {\n    syncManager;\n    clientProvider;\n    messagePort;\n    isInitialized;\n    dbAdapter;\n    abortOnClose = new AbortController();\n    constructor(options) {\n        super(options);\n        this.dbAdapter = options.db;\n        /**\n         * Configure or connect to the shared sync worker.\n         * This worker will manage all syncing operations remotely.\n         */\n        const resolvedWorkerOptions = {\n            dbFilename: this.options.identifier,\n            temporaryStorage: TemporaryStorageOption.MEMORY,\n            cacheSizeKb: DEFAULT_CACHE_SIZE_KB,\n            ...options,\n            flags: resolveWebSQLFlags(options.flags)\n        };\n        const syncWorker = options.sync?.worker;\n        if (syncWorker) {\n            if (typeof syncWorker === 'function') {\n                this.messagePort = syncWorker(resolvedWorkerOptions).port;\n            }\n            else {\n                this.messagePort = new SharedWorker(`${syncWorker}`, {\n                    /* @vite-ignore */\n                    name: `shared-sync-${this.webOptions.identifier}`\n                }).port;\n            }\n        }\n        else {\n            this.messagePort = new SharedWorker(new URL('../../worker/sync/SharedSyncImplementation.worker.js', import.meta.url), {\n                /* @vite-ignore */\n                name: `shared-sync-${this.webOptions.identifier}`,\n                type: 'module'\n            }).port;\n        }\n        /**\n         * Pass along any sync status updates to this listener\n         */\n        this.clientProvider = new SharedSyncClientProvider(this.webOptions, (status) => {\n            this.updateSyncStatus(status);\n        }, options.db);\n        this.syncManager = Comlink.wrap(this.messagePort);\n        /**\n         * The sync worker will call this client provider when it needs\n         * to fetch credentials or upload data.\n         * This performs bi-directional method calling.\n         */\n        Comlink.expose(this.clientProvider, this.messagePort);\n        this.syncManager.setLogLevel(this.logger.getLevel());\n        this.triggerCrudUpload = this.syncManager.triggerCrudUpload;\n        /**\n         * Opens MessagePort to the existing shared DB worker.\n         * The sync worker cannot initiate connections directly to the\n         * DB worker, but a port to the DB worker can be transferred to the\n         * sync worker.\n         */\n        this.isInitialized = this._init();\n    }\n    async _init() {\n        /**\n         * The general flow of initialization is:\n         *  - The client requests a unique navigator lock.\n         *    - Once the lock is acquired, we register the lock with the shared worker.\n         *    - The shared worker can then request the same lock. The client has been closed if the shared worker can acquire the lock.\n         *    - Once the shared worker knows the client's lock, we can guarentee that the shared worker will detect if the client has been closed.\n         *    - This makes the client safe for the shared worker to use.\n         *    - The client is only added to the SharedSyncImplementation once the lock has been registered.\n         *      This ensures we don't ever keep track of dead clients (tabs that closed before the lock was registered).\n         *    - The client side lock is held until the client is disposed.\n         *    - We resolve the top-level promise after the lock has been registered with the shared worker.\n         * - The client sends the params to the shared worker after locks have been registered.\n         */\n        await new Promise((resolve) => {\n            // Request a random lock until this client is disposed. The name of the lock is sent to the shared worker, which\n            // will also attempt to acquire it. Since the lock is returned when the tab is closed, this allows the share worker\n            // to free resources associated with this tab.\n            // We take hold of this lock as soon-as-possible in order to cater for potentially closed tabs.\n            getNavigatorLocks().request(`tab-close-signal-${crypto.randomUUID()}`, async (lock) => {\n                if (this.abortOnClose.signal.aborted) {\n                    return;\n                }\n                // Awaiting here ensures the worker is waiting for the lock\n                await this.syncManager.addLockBasedCloseSignal(lock.name);\n                // The lock has been registered, we can continue with the initialization\n                resolve();\n                await new Promise((r) => {\n                    this.abortOnClose.signal.onabort = () => r();\n                });\n            });\n        });\n        const { crudUploadThrottleMs, identifier, retryDelayMs } = this.options;\n        const flags = { ...this.webOptions.flags, workers: undefined };\n        await this.syncManager.setParams({\n            dbParams: this.dbAdapter.getConfiguration(),\n            streamOptions: {\n                crudUploadThrottleMs,\n                identifier,\n                retryDelayMs,\n                flags: flags\n            }\n        }, this.options.subscriptions);\n    }\n    /**\n     * Starts the sync process, this effectively acts as a call to\n     * `connect` if not yet connected.\n     */\n    async connect(options) {\n        await this.waitForReady();\n        return this.syncManager.connect(options);\n    }\n    async disconnect() {\n        await this.waitForReady();\n        return this.syncManager.disconnect();\n    }\n    async getWriteCheckpoint() {\n        await this.waitForReady();\n        return this.syncManager.getWriteCheckpoint();\n    }\n    async hasCompletedSync() {\n        return this.syncManager.hasCompletedSync();\n    }\n    async dispose() {\n        await this.waitForReady();\n        await new Promise((resolve) => {\n            // Listen for the close acknowledgment from the worker\n            this.messagePort.addEventListener('message', (event) => {\n                const payload = event.data;\n                if (payload?.event === SharedSyncClientEvent.CLOSE_ACK) {\n                    resolve();\n                }\n            });\n            // Signal the shared worker that this client is closing its connection to the worker\n            const closeMessagePayload = {\n                event: SharedSyncClientEvent.CLOSE_CLIENT,\n                data: {}\n            };\n            this.messagePort.postMessage(closeMessagePayload);\n        });\n        await super.dispose();\n        this.abortOnClose.abort();\n        // Release the proxy\n        this.syncManager[Comlink.releaseProxy]();\n        this.messagePort.close();\n    }\n    async waitForReady() {\n        return this.isInitialized;\n    }\n    updateSubscriptions(subscriptions) {\n        this.syncManager.updateSubscriptions(subscriptions);\n    }\n}\n","import { AbstractRemote, DEFAULT_REMOTE_LOGGER, FetchImplementationProvider } from '@powersync/common';\nimport { getUserAgentInfo } from './userAgent.js';\n/*\n * Depends on browser's implementation of global fetch.\n */\nclass WebFetchProvider extends FetchImplementationProvider {\n    getFetch() {\n        return fetch.bind(globalThis);\n    }\n}\nexport class WebRemote extends AbstractRemote {\n    connector;\n    logger;\n    _bson;\n    constructor(connector, logger = DEFAULT_REMOTE_LOGGER, options) {\n        super(connector, logger, {\n            ...(options ?? {}),\n            fetchImplementation: options?.fetchImplementation ?? new WebFetchProvider()\n        });\n        this.connector = connector;\n        this.logger = logger;\n    }\n    getUserAgent() {\n        let ua = [super.getUserAgent(), `powersync-web`];\n        try {\n            ua.push(...getUserAgentInfo());\n        }\n        catch (e) {\n            this.logger.warn('Failed to get user agent info', e);\n        }\n        return ua.join(' ');\n    }\n    async getBSON() {\n        if (this._bson) {\n            return this._bson;\n        }\n        /**\n         * Dynamic import to be used only when needed.\n         */\n        const { BSON } = await import('bson');\n        this._bson = BSON;\n        return this._bson;\n    }\n}\n","import { AbstractStreamingSyncImplementation, LockType } from '@powersync/common';\nimport { getNavigatorLocks } from '../../shared/navigator.js';\nexport class WebStreamingSyncImplementation extends AbstractStreamingSyncImplementation {\n    constructor(options) {\n        // Super will store and provide default values for options\n        super(options);\n    }\n    get webOptions() {\n        return this.options;\n    }\n    async obtainLock(lockOptions) {\n        const identifier = `streaming-sync-${lockOptions.type}-${this.webOptions.identifier}`;\n        if (lockOptions.type == LockType.SYNC) {\n            this.logger.debug('requesting lock for ', identifier);\n        }\n        return getNavigatorLocks().request(identifier, { signal: lockOptions.signal }, lockOptions.callback);\n    }\n}\n","/**\n * Get a minimal representation of browser, version and operating system.\n *\n * The goal is to get enough environemnt info to reproduce issues, but no\n * more.\n */\nexport function getUserAgentInfo(nav) {\n    nav ??= navigator;\n    const browser = getBrowserInfo(nav);\n    const os = getOsInfo(nav);\n    // The cast below is to cater for TypeScript < 5.5.0\n    return [browser, os].filter((v) => v != null);\n}\nfunction getBrowserInfo(nav) {\n    const brands = nav.userAgentData?.brands;\n    if (brands != null) {\n        const tests = [\n            { name: 'Google Chrome', value: 'Chrome' },\n            { name: 'Opera', value: 'Opera' },\n            { name: 'Edge', value: 'Edge' },\n            { name: 'Chromium', value: 'Chromium' }\n        ];\n        for (let { name, value } of tests) {\n            const brand = brands.find((b) => b.brand == name);\n            if (brand != null) {\n                return `${value}/${brand.version}`;\n            }\n        }\n    }\n    const ua = nav.userAgent;\n    const regexps = [\n        { re: /(?:firefox|fxios)\\/(\\d+)/i, value: 'Firefox' },\n        { re: /(?:edg|edge|edga|edgios)\\/(\\d+)/i, value: 'Edge' },\n        { re: /opr\\/(\\d+)/i, value: 'Opera' },\n        { re: /(?:chrome|chromium|crios)\\/(\\d+)/i, value: 'Chrome' },\n        { re: /version\\/(\\d+).*safari/i, value: 'Safari' }\n    ];\n    for (let { re, value } of regexps) {\n        const match = re.exec(ua);\n        if (match != null) {\n            return `${value}/${match[1]}`;\n        }\n    }\n    return null;\n}\nfunction getOsInfo(nav) {\n    if (nav.userAgentData?.platform != null) {\n        return nav.userAgentData.platform.toLowerCase();\n    }\n    const ua = nav.userAgent;\n    const regexps = [\n        { re: /windows/i, value: 'windows' },\n        { re: /android/i, value: 'android' },\n        { re: /linux/i, value: 'linux' },\n        { re: /iphone|ipad|ipod/i, value: 'ios' },\n        { re: /macintosh|mac os x/i, value: 'macos' }\n    ];\n    for (let { re, value } of regexps) {\n        if (re.test(ua)) {\n            return value;\n        }\n    }\n    return null;\n}\n","export const getNavigatorLocks = () => {\n    if ('locks' in navigator && navigator.locks) {\n        return navigator.locks;\n    }\n    throw new Error('Navigator locks are not available in an insecure context. Use a secure context such as HTTPS or http://localhost.');\n};\n","import * as Comlink from 'comlink';\nimport { WASQLiteVFS } from '../../db/adapters/wa-sqlite/WASQLiteConnection.js';\n/**\n * Opens a shared or dedicated worker which exposes opening of database connections\n */\nexport function openWorkerDatabasePort(workerIdentifier, multipleTabs = true, worker = '', vfs) {\n    const needsDedicated = vfs == WASQLiteVFS.AccessHandlePoolVFS || vfs == WASQLiteVFS.OPFSCoopSyncVFS;\n    if (worker) {\n        return !needsDedicated && multipleTabs\n            ? new SharedWorker(`${worker}`, {\n                /* @vite-ignore */\n                name: `shared-DB-worker-${workerIdentifier}`\n            }).port\n            : new Worker(`${worker}`, {\n                /* @vite-ignore */\n                name: `DB-worker-${workerIdentifier}`\n            });\n    }\n    else {\n        /**\n         *  Webpack V5 can bundle the worker automatically if the full Worker constructor syntax is used\n         *  https://webpack.js.org/guides/web-workers/\n         *  This enables multi tab support by default, but falls back if SharedWorker is not available\n         *  (in the case of Android)\n         */\n        return !needsDedicated && multipleTabs\n            ? new SharedWorker(new URL('./WASQLiteDB.worker.js', import.meta.url), {\n                /* @vite-ignore */\n                name: `shared-DB-worker-${workerIdentifier}`,\n                type: 'module'\n            }).port\n            : new Worker(new URL('./WASQLiteDB.worker.js', import.meta.url), {\n                /* @vite-ignore */\n                name: `DB-worker-${workerIdentifier}`,\n                type: 'module'\n            });\n    }\n}\n/**\n * @returns A function which allows for opening database connections inside\n * a worker.\n */\nexport function getWorkerDatabaseOpener(workerIdentifier, multipleTabs = true, worker = '') {\n    return Comlink.wrap(openWorkerDatabasePort(workerIdentifier, multipleTabs, worker));\n}\nexport function resolveWorkerDatabasePortFactory(worker) {\n    const workerInstance = worker();\n    return isSharedWorker(workerInstance) ? workerInstance.port : workerInstance;\n}\nexport function isSharedWorker(worker) {\n    return 'port' in worker;\n}\n","/**\n * The client side port should provide these methods.\n */\nexport class AbstractSharedSyncClientProvider {\n}\n","import { LogLevel } from '@powersync/common';\n/**\n * Broadcasts logs to all clients\n */\nexport class BroadcastLogger {\n    clients;\n    TRACE;\n    DEBUG;\n    INFO;\n    TIME;\n    WARN;\n    ERROR;\n    OFF;\n    currentLevel = LogLevel.INFO;\n    constructor(clients) {\n        this.clients = clients;\n        this.TRACE = LogLevel.TRACE;\n        this.DEBUG = LogLevel.DEBUG;\n        this.INFO = LogLevel.INFO;\n        this.TIME = LogLevel.TIME;\n        this.WARN = LogLevel.WARN;\n        this.ERROR = LogLevel.ERROR;\n        this.OFF = LogLevel.OFF;\n    }\n    trace(...x) {\n        if (!this.enabledFor(this.TRACE))\n            return;\n        console.trace(...x);\n        const sanitized = this.sanitizeArgs(x);\n        this.iterateClients((client) => client.clientProvider.trace(...sanitized));\n    }\n    debug(...x) {\n        if (!this.enabledFor(this.DEBUG))\n            return;\n        console.debug(...x);\n        const sanitized = this.sanitizeArgs(x);\n        this.iterateClients((client) => client.clientProvider.debug(...sanitized));\n    }\n    info(...x) {\n        if (!this.enabledFor(this.INFO))\n            return;\n        console.info(...x);\n        const sanitized = this.sanitizeArgs(x);\n        this.iterateClients((client) => client.clientProvider.info(...sanitized));\n    }\n    log(...x) {\n        if (!this.enabledFor(this.INFO))\n            return;\n        console.log(...x);\n        const sanitized = this.sanitizeArgs(x);\n        this.iterateClients((client) => client.clientProvider.log(...sanitized));\n    }\n    warn(...x) {\n        if (!this.enabledFor(this.WARN))\n            return;\n        console.warn(...x);\n        const sanitized = this.sanitizeArgs(x);\n        this.iterateClients((client) => client.clientProvider.warn(...sanitized));\n    }\n    error(...x) {\n        if (!this.enabledFor(this.ERROR))\n            return;\n        console.error(...x);\n        const sanitized = this.sanitizeArgs(x);\n        this.iterateClients((client) => client.clientProvider.error(...sanitized));\n    }\n    time(label) {\n        if (!this.enabledFor(this.TIME))\n            return;\n        console.time(label);\n        this.iterateClients((client) => client.clientProvider.time(label));\n    }\n    timeEnd(label) {\n        if (!this.enabledFor(this.TIME))\n            return;\n        console.timeEnd(label);\n        this.iterateClients((client) => client.clientProvider.timeEnd(label));\n    }\n    /**\n     * Set the global log level.\n     */\n    setLevel(level) {\n        this.currentLevel = level;\n    }\n    /**\n     * Get the current log level.\n     */\n    getLevel() {\n        return this.currentLevel;\n    }\n    /**\n     * Returns true if the given level is enabled.\n     */\n    enabledFor(level) {\n        return level.value >= this.currentLevel.value;\n    }\n    /**\n     * Iterates all clients, catches individual client exceptions\n     * and proceeds to execute for all clients.\n     */\n    async iterateClients(callback) {\n        for (const client of this.clients) {\n            try {\n                await callback(client);\n            }\n            catch (ex) {\n                console.error('Caught exception when iterating client', ex);\n            }\n        }\n    }\n    /**\n     * Guards against any logging errors.\n     * We don't want a logging exception to cause further issues upstream\n     */\n    sanitizeArgs(x) {\n        const sanitizedParams = x.map((param) => {\n            try {\n                // Try and clone here first. If it fails it won't be passable over a MessagePort\n                return structuredClone(param);\n            }\n            catch (ex) {\n                console.error(ex);\n                return 'Could not serialize log params. Check shared worker logs for more details.';\n            }\n        });\n        return sanitizedParams;\n    }\n}\n","import { AbortOperation, BaseObserver, ConnectionManager, SqliteBucketStorage, SyncStatus, createLogger } from '@powersync/common';\nimport { Mutex } from 'async-mutex';\nimport * as Comlink from 'comlink';\nimport { WebRemote } from '../../db/sync/WebRemote.js';\nimport { WebStreamingSyncImplementation } from '../../db/sync/WebStreamingSyncImplementation.js';\nimport { LockedAsyncDatabaseAdapter } from '../../db/adapters/LockedAsyncDatabaseAdapter.js';\nimport { WorkerWrappedAsyncDatabaseConnection } from '../../db/adapters/WorkerWrappedAsyncDatabaseConnection.js';\nimport { BroadcastLogger } from './BroadcastLogger.js';\n/**\n * @internal\n * Manual message events for shared sync clients\n */\nexport var SharedSyncClientEvent;\n(function (SharedSyncClientEvent) {\n    /**\n     * This client requests the shared sync manager should\n     * close it's connection to the client.\n     */\n    SharedSyncClientEvent[\"CLOSE_CLIENT\"] = \"close-client\";\n    SharedSyncClientEvent[\"CLOSE_ACK\"] = \"close-ack\";\n})(SharedSyncClientEvent || (SharedSyncClientEvent = {}));\n/**\n * HACK: The shared implementation wraps and provides its own\n * PowerSyncBackendConnector when generating the streaming sync implementation.\n * We provide this unused placeholder when connecting with the ConnectionManager.\n */\nconst CONNECTOR_PLACEHOLDER = {};\n/**\n * @internal\n * Shared sync implementation which runs inside a shared webworker\n */\nexport class SharedSyncImplementation extends BaseObserver {\n    ports;\n    isInitialized;\n    statusListener;\n    fetchCredentialsController;\n    uploadDataController;\n    syncParams;\n    logger;\n    lastConnectOptions;\n    portMutex;\n    subscriptions = [];\n    connectionManager;\n    syncStatus;\n    broadCastLogger;\n    distributedDB;\n    constructor() {\n        super();\n        this.ports = [];\n        this.syncParams = null;\n        this.logger = createLogger('shared-sync');\n        this.lastConnectOptions = undefined;\n        this.portMutex = new Mutex();\n        this.isInitialized = new Promise((resolve) => {\n            const callback = this.registerListener({\n                initialized: () => {\n                    resolve();\n                    callback?.();\n                }\n            });\n        });\n        // Should be configured once we get params\n        this.distributedDB = null;\n        this.syncStatus = new SyncStatus({});\n        this.broadCastLogger = new BroadcastLogger(this.ports);\n        this.connectionManager = new ConnectionManager({\n            createSyncImplementation: async () => {\n                await this.waitForReady();\n                const sync = this.generateStreamingImplementation();\n                const onDispose = sync.registerListener({\n                    statusChanged: (status) => {\n                        this.updateAllStatuses(status.toJSON());\n                    }\n                });\n                return {\n                    sync,\n                    onDispose\n                };\n            },\n            logger: this.logger\n        });\n    }\n    get lastSyncedAt() {\n        return this.connectionManager.syncStreamImplementation?.lastSyncedAt;\n    }\n    get isConnected() {\n        return this.connectionManager.syncStreamImplementation?.isConnected ?? false;\n    }\n    /**\n     * Gets the last client port which we know is safe from unexpected closes.\n     */\n    async getLastWrappedPort() {\n        // Find the last port which is not closing\n        return await this.portMutex.runExclusive(() => {\n            for (let i = this.ports.length - 1; i >= 0; i--) {\n                if (!this.ports[i].isClosing) {\n                    return this.ports[i];\n                }\n            }\n            return;\n        });\n    }\n    /**\n     * In some very rare cases a specific tab might not respond to requests.\n     * This returns a random port which is not closing.\n     */\n    async getRandomWrappedPort() {\n        return await this.portMutex.runExclusive(() => {\n            const nonClosingPorts = this.ports.filter((p) => !p.isClosing);\n            return nonClosingPorts[Math.floor(Math.random() * nonClosingPorts.length)];\n        });\n    }\n    async waitForStatus(status) {\n        return this.withSyncImplementation(async (sync) => {\n            return sync.waitForStatus(status);\n        });\n    }\n    async waitUntilStatusMatches(predicate) {\n        return this.withSyncImplementation(async (sync) => {\n            return sync.waitUntilStatusMatches(predicate);\n        });\n    }\n    async waitForReady() {\n        return this.isInitialized;\n    }\n    collectActiveSubscriptions() {\n        this.logger.debug('Collecting active stream subscriptions across tabs');\n        const active = new Map();\n        for (const port of this.ports) {\n            for (const stream of port.currentSubscriptions) {\n                const serializedKey = JSON.stringify(stream);\n                active.set(serializedKey, stream);\n            }\n        }\n        this.subscriptions = [...active.values()];\n        this.logger.debug('Collected stream subscriptions', this.subscriptions);\n        this.connectionManager.syncStreamImplementation?.updateSubscriptions(this.subscriptions);\n    }\n    updateSubscriptions(port, subscriptions) {\n        port.currentSubscriptions = subscriptions;\n        this.collectActiveSubscriptions();\n    }\n    setLogLevel(level) {\n        this.logger.setLevel(level);\n        this.broadCastLogger.setLevel(level);\n    }\n    /**\n     * Configures the DBAdapter connection and a streaming sync client.\n     */\n    async setParams(params) {\n        await this.portMutex.runExclusive(async () => {\n            this.collectActiveSubscriptions();\n        });\n        if (this.syncParams) {\n            // Cannot modify already existing sync implementation params\n            return;\n        }\n        // First time setting params\n        this.syncParams = params;\n        if (params.streamOptions?.flags?.broadcastLogs) {\n            this.logger = this.broadCastLogger;\n        }\n        const lockedAdapter = new LockedAsyncDatabaseAdapter({\n            name: params.dbParams.dbFilename,\n            openConnection: async () => {\n                // Gets a connection from the clients when a new connection is requested.\n                const db = await this.openInternalDB();\n                db.registerListener({\n                    closing: () => {\n                        lockedAdapter.reOpenInternalDB();\n                    }\n                });\n                return db;\n            },\n            logger: this.logger,\n            reOpenOnConnectionClosed: true\n        });\n        this.distributedDB = lockedAdapter;\n        await lockedAdapter.init();\n        lockedAdapter.registerListener({\n            databaseReOpened: () => {\n                // We may have missed some table updates while the database was closed.\n                // We can poke the crud in case we missed any updates.\n                this.connectionManager.syncStreamImplementation?.triggerCrudUpload();\n                /**\n                 * FIXME or IMPROVE ME\n                 * The Rust client implementation stores sync state on the connection level.\n                 * Reopening the database causes a state machine error which should cause the\n                 * StreamingSyncImplementation to reconnect. It would be nicer if we could trigger\n                 * this reconnect earlier.\n                 * This reconnect is not required for IndexedDB.\n                 */\n            }\n        });\n        self.onerror = (event) => {\n            // Share any uncaught events on the broadcast logger\n            this.logger.error('Uncaught exception in PowerSync shared sync worker', event);\n        };\n        this.iterateListeners((l) => l.initialized?.());\n    }\n    async dispose() {\n        await this.waitForReady();\n        this.statusListener?.();\n        return this.connectionManager.close();\n    }\n    /**\n     * Connects to the PowerSync backend instance.\n     * Multiple tabs can safely call this in their initialization.\n     * The connection will simply be reconnected whenever a new tab\n     * connects.\n     */\n    async connect(options) {\n        this.lastConnectOptions = options;\n        return this.connectionManager.connect(CONNECTOR_PLACEHOLDER, options ?? {});\n    }\n    async disconnect() {\n        return this.connectionManager.disconnect();\n    }\n    /**\n     * Adds a new client tab's message port to the list of connected ports\n     */\n    async addPort(port) {\n        return await this.portMutex.runExclusive(() => {\n            const portProvider = {\n                port,\n                clientProvider: Comlink.wrap(port),\n                currentSubscriptions: [],\n                closeListeners: [],\n                isClosing: false\n            };\n            this.ports.push(portProvider);\n            // Give the newly connected client the latest status\n            const status = this.connectionManager.syncStreamImplementation?.syncStatus;\n            if (status) {\n                portProvider.clientProvider.statusChanged(status.toJSON());\n            }\n            return portProvider;\n        });\n    }\n    /**\n     * Removes a message port client from this manager's managed\n     * clients.\n     */\n    async removePort(port) {\n        // Ports might be removed faster than we can process them.\n        port.isClosing = true;\n        // Remove the port within a mutex context.\n        // Warns if the port is not found. This should not happen in practice.\n        // We return early if the port is not found.\n        return await this.portMutex.runExclusive(async () => {\n            const index = this.ports.findIndex((p) => p == port);\n            if (index < 0) {\n                this.logger.warn(`Could not remove port ${port} since it is not present in active ports.`);\n                return () => { };\n            }\n            const trackedPort = this.ports[index];\n            // Remove from the list of active ports\n            this.ports.splice(index, 1);\n            /**\n             * The port might currently be in use. Any active functions might\n             * not resolve. Abort them here.\n             */\n            [this.fetchCredentialsController, this.uploadDataController].forEach((abortController) => {\n                if (abortController?.activePort == port) {\n                    abortController.controller.abort(new AbortOperation('Closing pending requests after client port is removed'));\n                }\n            });\n            // Close the worker wrapped database connection, we can't accurately rely on this connection\n            for (const closeListener of trackedPort.closeListeners) {\n                await closeListener();\n            }\n            this.collectActiveSubscriptions();\n            return () => trackedPort.clientProvider[Comlink.releaseProxy]();\n        });\n    }\n    triggerCrudUpload() {\n        this.withSyncImplementation(async (sync) => {\n            sync.triggerCrudUpload();\n        });\n    }\n    async hasCompletedSync() {\n        return this.withSyncImplementation(async (sync) => {\n            return sync.hasCompletedSync();\n        });\n    }\n    async getWriteCheckpoint() {\n        return this.withSyncImplementation(async (sync) => {\n            return sync.getWriteCheckpoint();\n        });\n    }\n    async withSyncImplementation(callback) {\n        await this.waitForReady();\n        if (this.connectionManager.syncStreamImplementation) {\n            return callback(this.connectionManager.syncStreamImplementation);\n        }\n        const sync = await new Promise((resolve) => {\n            const dispose = this.connectionManager.registerListener({\n                syncStreamCreated: (sync) => {\n                    resolve(sync);\n                    dispose?.();\n                }\n            });\n        });\n        return callback(sync);\n    }\n    generateStreamingImplementation() {\n        // This should only be called after initialization has completed\n        const syncParams = this.syncParams;\n        // Create a new StreamingSyncImplementation for each connect call. This is usually done is all SDKs.\n        return new WebStreamingSyncImplementation({\n            adapter: new SqliteBucketStorage(this.distributedDB, this.logger),\n            remote: new WebRemote({\n                invalidateCredentials: async () => {\n                    const lastPort = await this.getLastWrappedPort();\n                    if (!lastPort) {\n                        throw new Error('No client port found to invalidate credentials');\n                    }\n                    try {\n                        this.logger.log('calling the last port client provider to invalidate credentials');\n                        lastPort.clientProvider.invalidateCredentials();\n                    }\n                    catch (ex) {\n                        this.logger.error('error invalidating credentials', ex);\n                    }\n                },\n                fetchCredentials: async () => {\n                    const lastPort = await this.getLastWrappedPort();\n                    if (!lastPort) {\n                        throw new Error('No client port found to fetch credentials');\n                    }\n                    return new Promise(async (resolve, reject) => {\n                        const abortController = new AbortController();\n                        this.fetchCredentialsController = {\n                            controller: abortController,\n                            activePort: lastPort\n                        };\n                        abortController.signal.onabort = reject;\n                        try {\n                            this.logger.log('calling the last port client provider for credentials');\n                            resolve(await lastPort.clientProvider.fetchCredentials());\n                        }\n                        catch (ex) {\n                            reject(ex);\n                        }\n                        finally {\n                            this.fetchCredentialsController = undefined;\n                        }\n                    });\n                }\n            }, this.logger),\n            uploadCrud: async () => {\n                const lastPort = await this.getLastWrappedPort();\n                if (!lastPort) {\n                    throw new Error('No client port found to upload crud');\n                }\n                return new Promise(async (resolve, reject) => {\n                    const abortController = new AbortController();\n                    this.uploadDataController = {\n                        controller: abortController,\n                        activePort: lastPort\n                    };\n                    // Resolving will make it retry\n                    abortController.signal.onabort = () => resolve();\n                    try {\n                        resolve(await lastPort.clientProvider.uploadCrud());\n                    }\n                    catch (ex) {\n                        reject(ex);\n                    }\n                    finally {\n                        this.uploadDataController = undefined;\n                    }\n                });\n            },\n            ...syncParams.streamOptions,\n            subscriptions: this.subscriptions,\n            // Logger cannot be transferred just yet\n            logger: this.logger\n        });\n    }\n    /**\n     * Opens a worker wrapped database connection. Using the last connected client port.\n     */\n    async openInternalDB() {\n        const client = await this.getRandomWrappedPort();\n        if (!client) {\n            // Should not really happen in practice\n            throw new Error(`Could not open DB connection since no client is connected.`);\n        }\n        // Fail-safe timeout for opening a database connection.\n        const timeout = setTimeout(() => {\n            abortController.abort();\n        }, 10_000);\n        /**\n         * Handle cases where the client might close while opening a connection.\n         */\n        const abortController = new AbortController();\n        const closeListener = () => {\n            abortController.abort();\n        };\n        const removeCloseListener = () => {\n            const index = client.closeListeners.indexOf(closeListener);\n            if (index >= 0) {\n                client.closeListeners.splice(index, 1);\n            }\n        };\n        client.closeListeners.push(closeListener);\n        const workerPort = await withAbort({\n            action: () => client.clientProvider.getDBWorkerPort(),\n            signal: abortController.signal,\n            cleanupOnAbort: (port) => {\n                port.close();\n            }\n        }).catch((ex) => {\n            removeCloseListener();\n            throw ex;\n        });\n        const remote = Comlink.wrap(workerPort);\n        const identifier = this.syncParams.dbParams.dbFilename;\n        /**\n         * The open could fail if the tab is closed while we're busy opening the database.\n         * This operation is typically executed inside an exclusive portMutex lock.\n         * We typically execute the closeListeners using the portMutex in a different context.\n         * We can't rely on the closeListeners to abort the operation if the tab is closed.\n         */\n        const db = await withAbort({\n            action: () => remote(this.syncParams.dbParams),\n            signal: abortController.signal,\n            cleanupOnAbort: (db) => {\n                db.close();\n            }\n        }).finally(() => {\n            // We can remove the close listener here since we no longer need it past this point.\n            removeCloseListener();\n        });\n        clearTimeout(timeout);\n        const wrapped = new WorkerWrappedAsyncDatabaseConnection({\n            remote,\n            baseConnection: db,\n            identifier,\n            // It's possible for this worker to outlive the client hosting the database for us. We need to be prepared for\n            // that and ensure pending requests are aborted when the tab is closed.\n            remoteCanCloseUnexpectedly: true\n        });\n        client.closeListeners.push(async () => {\n            this.logger.info('Aborting open connection because associated tab closed.');\n            /**\n             * Don't await this close operation. It might never resolve if the tab is closed.\n             * We mark the remote as closed first, this will reject any pending requests.\n             * We then call close. The close operation is configured to fire-and-forget, the main promise will reject immediately.\n             */\n            wrapped.markRemoteClosed();\n            wrapped.close().catch((ex) => this.logger.warn('error closing database connection', ex));\n        });\n        return wrapped;\n    }\n    /**\n     * A method to update the all shared statuses for each\n     * client.\n     */\n    updateAllStatuses(status) {\n        this.syncStatus = new SyncStatus(status);\n        this.ports.forEach((p) => p.clientProvider.statusChanged(status));\n    }\n}\n/**\n * Runs the action with an abort controller.\n */\nfunction withAbort(options) {\n    const { action, signal, cleanupOnAbort } = options;\n    return new Promise((resolve, reject) => {\n        if (signal.aborted) {\n            reject(new AbortOperation('Operation aborted by abort controller'));\n            return;\n        }\n        function handleAbort() {\n            signal.removeEventListener('abort', handleAbort);\n            reject(new AbortOperation('Operation aborted by abort controller'));\n        }\n        signal.addEventListener('abort', handleAbort, { once: true });\n        function completePromise(action) {\n            signal.removeEventListener('abort', handleAbort);\n            action();\n        }\n        action()\n            .then((data) => {\n            // We already rejected due to the abort, allow for cleanup\n            if (signal.aborted) {\n                return completePromise(() => cleanupOnAbort?.(data));\n            }\n            completePromise(() => resolve(data));\n        })\n            .catch((e) => completePromise(() => reject(e)));\n    });\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite__;","module.exports = __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite_src_examples_AccessHandlePoolVFS_js__;","module.exports = __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite_src_examples_IDBBatchAtomicVFS_js__;","module.exports = __WEBPACK_EXTERNAL_MODULE__journeyapps_wa_sqlite_src_examples_OPFSCoopSyncVFS_js__;","module.exports = __WEBPACK_EXTERNAL_MODULE__powersync_common__;","module.exports = __WEBPACK_EXTERNAL_MODULE_async_mutex__;","module.exports = __WEBPACK_EXTERNAL_MODULE_comlink__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Check if module exists (development only)\n\tif (__webpack_modules__[moduleId] === undefined) {\n\t\tvar e = new Error(\"Cannot find module '\" + moduleId + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; (typeof current == 'object' || typeof current == 'function') && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.umd.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/^blob:/, \"\").replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","export * from '@powersync/common';\nexport * from './attachments/IndexDBFileSystemAdapter.js';\nexport * from './db/adapters/AbstractWebPowerSyncDatabaseOpenFactory.js';\nexport * from './db/adapters/AbstractWebSQLOpenFactory.js';\nexport * from './db/adapters/AsyncDatabaseConnection.js';\nexport * from './db/adapters/wa-sqlite/WASQLiteConnection.js';\nexport * from './db/adapters/wa-sqlite/WASQLiteDBAdapter.js';\nexport * from './db/adapters/wa-sqlite/WASQLiteOpenFactory.js';\nexport * from './db/adapters/wa-sqlite/WASQLitePowerSyncDatabaseOpenFactory.js';\nexport * from './db/adapters/web-sql-flags.js';\nexport * from './db/PowerSyncDatabase.js';\nexport * from './db/sync/SharedWebStreamingSyncImplementation.js';\nexport * from './db/sync/WebRemote.js';\nexport * from './db/sync/WebStreamingSyncImplementation.js';\n"],"names":[],"ignoreList":[],"sourceRoot":""}